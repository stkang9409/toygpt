1일차
- 전반적인 내용
DDD, MSA 전반을 다룬다. MSA를 하기 위해선 도메인 주도 설계가 선행되어야 한다. MSA를 잘 만들기 위한 전반적인 설계 방법을 다룬다.

- 독서 전략
이전 회사들에서 경험했던 모놀리식, 잘못된 MSA에 대해 반성해보고, 지금 회사에서 잘된 MSA를 보며 책을 깊이있게 이해해본다. 지금 구조에서의 문제점도 찾아본다.

- 다짐
더 나은 구조에 대해 항상 고민하는 개발자로 거듭나자

---------------------------

2일차
도메인MSA

# 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

클라우드 환경의 등장과 이를 잘 활용한 기업들은 성공했다. 클라우드 환경이 그것을 어떻게 촉진했는지 보자.

## 1.1.1 성공 사례: 아마존의 배포 속도

빠른 배포 주기는 비즈니스의 민첩성을 간접적으로 보여주는 지표다.

아마존은 초당 1.5번의 배포를 한다. (2019년 기준) 

어떻게 이런 속도를 갖게 되었을지 시스템을 구성하는 인프라와 애플리케이션 측면에서 살펴보자.

## 1.1.2 클라우드 인프라의 등장

- 전형적인 시스템 인프라 구축 과정은 시간, 금전, 관리 비용이 많이 든다.
    
    서비스가 실패한다면 초기 투자 비용도 건질 수 없다.
    
- 클라우드 인프라의 등장으로 이런 문제가 해결되었다.

## 1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건

- 클라우드 인프라를 사용하면 사용량에 따라 비용을 유연하게 조정할 수 있다.
- 클라우드는 여러 개의 서버 장비가 모여 논리적으로 하나처럼 관리된다. 레고처럼 조각이 모여 하나의 큰 덩어리가 되고 쉽게 분리되기도 한다.
    
    애플리케이션도 이런 형태라면 효율성을 극대화할 수 있다. 애플리케이션 블록이 작으면 작을수록 효율적이다.
    
- 사용량 증가에 따른 인프라 용량 성능과 가용성을 높이는 일반적인 방법
    
    ### 스케일 업과 스케일 아웃
    
    쇼핑몰 타임세일로 특정 기간에 트래픽이 밀려온다면 스케일업이나 스케일 아웃을 고려할 수 있다.
    
    - 스케일 업
        
        아무리 스케일 업해도 예상 트래픽을 초과하면 시스템이 다운될 수 있다.
        
    - 스케일 아웃
        
        한계 수치에 달하면 인스턴스를 복제해서 증가시키고, 사용량이 분산된다.
        
    
    ### 특정 서비스만 탄력성 있게 확장 (스케일 아웃)
    
    세일 기간 중 바쁜 업무는 세일 이벤트를 수행하는 부분이므로, 스케일 아웃 시, 전체를 복제할 필요가 없다. 세일 이벤트를 담당하는 조각만 용량이 증설되고 복제되어 트래픽에 대비하면 된다.
    
    시스템을 작은 단위의 독립적인 서비스 연계로 구성해야 한다.
    
    ### 클라우드 프렌들리와 클라우드 네이티브
    
    - 클라우드 프렌들리
        
        큰 한덩어리도 클라우드 인프라에 올릴 수는 있다. 하지만 특정 기능만 확장하거나 배포할 수 없는 비효율은 감수해야 한다.
        
    - 클라우드 네이티브
        
        독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션
        
    
    궁극적으로 클라우드 프렌들리 → 클라우드 네이티브가 되어야 한다.
    

# 1.2 마이크로서비스란 무엇인가?

## 1.2.1 모노리스와 마이크로서비스 비교

- 모노리스는 하나의 단위로 개발되는 일체식 애플리케이션이다.
    
    서버 측 애플리케이션이 논리적인 단일체로서 아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 한다.
    
- 스케일 아웃되면 큰 덩어리가 복제되어 여러 개가 뜬다. 변경이 발생하면 여러 개의 모노리스가 수평으로 확장된 상태이므로 여러 개의 모노리스 시스템 전부를 다시 빌드하고 배포해야 한다.
    
    데이터베이스는 하나이므로 스케일 업을 통해 용량을 증설해야 한다.
    
- 마이크로서비스는 여러 서비스 인스턴스가 모여 하나의 비즈니스 애플리케이션을 구성한다.
    
    각기 저장소가 다르므로 업무 단위로 모듈 경계가 명확하게 구분된다.
    
    확장 시에는 특정 기능별로 독립적으로 확장할 수 있고, 특정 서비스를 변경할 필요가 있다면 해당 서비스만 빌드해서 배포하면 된다.
    

## 1.2.2 SOA와 마이크로서비스

- 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 `폴리글랏하다`라고 표현한다.
- SOA는 애플리케이션은 모듈별로 분리했지만 저장소까지는 분리하지 못했다.
- MSA는 SOA에는 없던 두 가지 개념으로 모듈화 방식을 강화했고 실현한다.
    1. 서비스별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화한다. 즉, 다른 서비스의 저장소에 접근하는 수단은 API밖에 없다.
    2. REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다.

---------------------------

3일차
도메인MSA

# 1.3 마이크로 서비스를 위한 조건은 무엇인가?

## 1.3.1 조직의 변화: 업무 기능 중심 팀

- 시스템을 개발할 때 항상 시스템의 모양이 팀의 의사소통 구조를 반영한다.
- 예전에 일하는 방식은 기술별로 팀이 나눠져 있고, 하나의 애플리케이션을 만들려면 팀간의 의사소통이 필요하다.
- 마이크로서비스를 만드는 팀은 업무 기능 중심의 팀이어야 한다.
    
    이는 자율적으로 담당 비즈니스에 관련된 서비스를 만들뿐 아니라 개발 이후에 운영할 책임까지 진다.
    

## 1.3.2 관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏

- 마이크로서비스를 만드는 조직은 중앙의 강력한 거버넌스를 추구하지 않는다.
- 각 서비스 팀이 팀에 맞는 개발 언어 및 저장소를 선택하는 것을 각각 폴리글랏 프로그래밍, 폴리글랏 저장소라고 한다.

## 1.3.3 개발 생명주기의 변화: 프로젝트가 아니라 제품 중심으로

- 기존에는 개발 조직과 운영 조직이 분리돼 있고, 초기에 모든 일정을 계획했다.
- 마이크로서비스팀의 개발은 소프트웨어 전체 생명주기를 책임져야 한다. 즉, 소프트웨어를 완성해야 할 기능의 집합으로 보는 것이 아니라 비즈니스를 제공하는 제품으로 바라본다.
    
    제품 중심의 애자일 개발 방식을 채택한다.
    
    마이크로서비스는 계속 피드백을 받아 지속적으로 변화, 개선되고 향상되는 존재다.
    

## 1.3.4 개발 환경의 변화: 인프라 자동화

- 마이크로서비스는 독립적으로 배포되므로, 이렇게 여러 개로 쪼개진 상태에서는 수동으로 배포하는 방식은 바람직하지 않다. 이를 빠르게 배포하기 위한 자동화된 방법이 필요하다.
- 빌드/배포 파이프라인은 일반적으로 소스코드 빌드 → 개발환경 배포 → 스테이징 환경 배포 → 운영 환경 배포 로 구성된다.
    
    이를 효율적으로 관리하기 위해 인프라 구성과 자동화를 마치 소프트웨어처럼 코드로 처리하는 방식인 Infrastructure as code가 각광받고 있다.
    

## 1.3.5 저장소의 변화: 통합 저장소가 아닌 분권 데이터 관리

- 폴리글랏 저장소 접근법에서는 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다.
    
    여기서 각 마이크로서비스의 저장소에 담긴 데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제가 있다.
    
- 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다.
    
    이를 결과적 일관성이라고 표현하기도 한다. 여러 트랜잭션을 하나로 묶지 않고 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다.

---------------------------

4일차
도메인MSA

# 2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

- 현대 애플리케이션에 대한 기대를 잘 표현한 리액티브 선언문이라는 문서가 있다.
    
    응답성, 탄력성, 유연성, 메시지 기반의 4가지 특성
    
    - 응답성 : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공
    - 탄력성 : 장애에서 빠르게 복구하는 능력
    - 유연성 : 사용량에 변화가 있어도 균일한 응답성을 제공
    - 메시지 기반 : 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신 지향
- 리액티브란 급변하는 상황에 적응할 수 있는 시스템을 요구하는 것이다.
- 리액티브 시스템이 반드시 갖춰야 할 공통적인 특성은 아키텍처 유연성이다.

# 2.2 강결합에서 느슨한 결합의 아키텍처로의 변화

- 예전에는 특정 벤더의 제품에 전적으로 의존해서 강결합된 경우가 많았다.
    
    최근에는 클라우드 환경하에서 오픈소스 기반으로 하여 벤더에 의존할 필요가 적어졌다.
    
- 예전에는 검증된 기술이나 솔루션 기반으로 직접 구현하는 폐쇄적인 방식
    
    최근에는 필요한 영역에 적절한 솔루션을 선택하고 조합하는 개방적인 방식
    

# 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

- 인프라, 플랫폼, 애플리케이션 영역
    
    기반이 되는 하드웨어 인프라, 인프라 위에 애플리케이션 운영 및 구동을 위한 플랫폼이 올라가고, 플랫폼 위에 애플리케이션 서비스가 구동된다.
    
- 외부 아키텍처는 마이크로서비스가 운영되는 환경을 정의한다.
- 내부 아키텍처는 실제로 비즈니스가 실행되는 비즈니스 애플리케이션의 구조를 말한다.

# 2.4 MSA 구성요소 및 MSA 패턴

- MSA 구성요소 및 패턴의 유형
    - 인프라 구성요소
        
        MSA를 지탱하는 하부구조 인프라를 구축하는 데 필요한 구성요소
        
    - 플랫폼 패턴
        
        인프라 위에서 MSA의 운영과 관리를 지원하는 플랫폼 차원의 패턴
        
    - 애플리케이션 패턴
        
        MSA 애플리케이션을 구성하는 데 필요한 패턴
        

## 2.4.1 인프라 구성요소

IT 환경 운영, 관리에 필요한 하드웨어, 소프트웨어, 네트워킹 구성요소, 운영체제, 데이터 스토리지 등을 모두 포괄한다.

### 퍼블릭 클라우드와 베어 메탈, 프라이빗 클라우드 환경

인프라 아키텍트는 퍼블릭 클라우드를 사용할 것인지, 베어 메탈에 프라이빗 클라우드 환경을 사용할 것인지 결정해야 한다. 마이크로서비스는 어떠한 환경에서도 유연하도록 구성돼야 하므로 특정 인프라를 고집하지 않는다. 그러므로 인프라로 어떤 것을 선택해도 상관없다.

### VM과 컨테이너

- 가상 인프라 환경에서는 가상 머신과 컨테이너 중 하나를 선택해야 한다.
- 가상머신은 하이퍼바이저라는 소프트웨어로 하나의 시슽메에서 여러 개의 운영체제를 사용할 수 있다. 컨테이너는 하이퍼바이저 없이 컨테이너 엔진으로 가상된 격리 공간을 생성한다.
- 둘의 차이는 게스트 OS 유무이다. 게스트 OS를 사용하는 가상 머신에서는 운영체제 패치 설치나 관련 라이브러리 설치 같은 오버헤드가 지속적으로 발생한다. 따라서 MSA 같은 작은 서비스를 패키지하고 배포하기에는 컨테이너 환경이 더 적합하다.
- 도커 컨테이너는 레이어 단위의 이미지를 포개는 방식으로 구성되며, 밑에서부터 애플리케이션 구동을 위한 기반 이미지, 운영체제, 런타임, 애플리케이션이 이미지로 정의된다.
- 도커 컨테이너의 이점
    - 이식성 : 어떤 커널이나 플랫폼 버전에 상관없이 도커만 실행할 수 있으면 사용 가능하며 동일하게 동작된다.
    - 신속성 : 크기가 작고 가벼워 빠르게 배포 가능
    - 재사용성 : 동일한 환경 재사용이 쉬워서 개발, 테스트, 스테이징, 프로덕트 환경을 동일한 환경으로 구축 가능

---------------------------

5일차
DDD, MSA

### 컨테이너 오케스트레이션

- 컨테이너 관리를 위한 기능을 컨테이너 오케스트레이션이라 하고, 쿠버네티스를 많이 사용한다.
- 쿠버네티스의 이점
    - 자동화된 자원 배정
    - 셀프 치유
    - 수평 확장

## 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

인프라 환경 위에서 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법이다. 애플리케이션을 빌드하고 인프라에 배포할 수 있는 환경이 중요하다.

### 개발 지원 환경: 데브옵스 인프라 구성

- 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말한다.
- 자동화된 빌드나 배포 작업을 보통 CI/CD라고 하며, CI는 지속적 통합을 가리킨다.
- CD는 지속적 제공 및 지속적 배포를 의미한다.
- 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동을 CI라고 하고, 실행 환경에 내보내는 활동을 CD라 한다.

### 빌드/배포 파이프라인 설계

- 빌드/배포 파이프라인은 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시작화된 절차로 구축하는 것이다.
- 빌드/배포 파이프라인은 마이크로서비스별로 별도로 설계해야 한다.

### 마이크로서비스 생태계와 운영 관리 요소의 탄생

- 전체 서비스를 여러 개의 서비스로 분산 구성했을 때 한 서비스에서 발생한 장애가 다른 서비스로 전파된다거나 여러 서비스에 분산된 로그를 관리해야 하는 불편함, 서비스 하나가 동작하지 않아 시스템 일부 기능이 동작하지 않아도 알아채지 못하고 장애가 방치되는 문제들이 발생했다.
- 넷플릭스를 주도로 이를 해결할 기술들이 공유되고 자연스럽게 업계가 발전하게 됐다.
- MSA 발전에 따라 도커, 스프링 부트, 쿠버네티스가 등장했다.

### 경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴

- 넷플릭스 oss는 넷플릭스가 마이크로서비스를 개발, 운영하면서 생긴 노하우를 공개한 오픈소스다.
- 스프링 진영에서는 넷플릭스 oss 모듈들을 스프링 프레임워크로 감싸서 스프링 클라우드라는 명칭으로 발표했다.
    
    스프링 클라우드: 스프링 부트 + 넷플릭스 OSS

---------------------------

6일차
ddd, msa

### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

- 서비스 디스커버리 패턴
    
    클라이언트가 여러 개의 마이크로서비스를 호출하기 위해 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드 밸런싱 기능이 제공돼야 한다.
    
    넷플릭스 oss에서 라우팅 기능은 zuul, 로드밸런싱은 ribbon이 담당한다.
    
- 서비스 레지스트리 패턴
    
    라우터는 최적 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다. 이런 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경에서 동적으로 변경되는 유동 IP 정보를 매번 전송받아 변경해야 한다. 백엔드 마이크로서비스 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관할 저장소가 필요하다. 이렇게 분리한 것을 서비스 레지스트리 패턴이라 한다.
    
    넷플릭스 oss의 유레카가 이 기능을 담당한다.
    
- 쿠버네티스의 경우 서비스 레지스트리, 디스커버리 기능을 자체 기능인 쿠버네티스 DNS 및 쿠버네티스 서비스로 제공한다.

### 서비스 단일 진입을 위한 API 게이트웨이 패턴

- 다양한 클라이언트가 다양한 서비스에 접근하기 위해서는 단일 진입점을 만들어 놓으면 여러모로 효율적이다.
    
    다른 유형의 클라이언트에게 서로 다른 API 조합을 제공할 수도 있고, 각 서비스에 접근할 때 필요한 인증/인가 기능을 한 번에 처리할 수도 있다. 서비스 요청에 대한 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경하는 기능이 작동되게 할 수도 있다.
    
- 서비스 라우팅 기능은 L4 같은 하드웨어 장비로 구현할 수도 있지만, 소프트웨어로 구현할 경우 애플리케이션 레벨의 라우팅 기능을 수행한다. 또한 로드 밸런싱이나 필터를 둬서 선행 처리와 후행 처리, 에러 처리 등을 쉽게 구현할 수 있다.
- API 게이트웨이 패턴은 스프링 클라우드의 스프링 API 게이트웨이 서비스로 쉽게 구현할 수 있다.

### BFF 패턴

- BFF 패턴은 API 게이트웨이와 같은 진입점을 하나로 두지 않고 프런트엔드 유형에 따라 각각 두는 패턴이다.
- 웹용 API 게이트웨이, 모바일용 API 게이트웨이 등 클라이언트 종류에 따라 최적화된 처리를 할 수 있게 구성 가능하다.
- 각 프런트엔드에 대한 처리만 수행하는 BFF를 두고 이후에 통합적인 API 게이트웨이를 둠으로써 공통적인 인증/인가, 로깅 등의 처리를 통제하는 구조로 구성할 수도 있다.

### 외부 구성 저장소 패턴

- 컨피그 원칙
    
    애플리케이션이 배포되는 환경이 매번 달라지기 때문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다.
    
    클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안된다.
    
- 분리해야 할 환경 정보로는 DB 연결 정보, 배포 시 변경해야 할 호스트명, 백엔드 서비스 연결을 위한 리소스 정보 등이 있다.
- 스프링 클라우드 컨피그
    
    이런 환경 정보를 코드에서 분리하고 컨피그 서비스를 통해 런타임 시 주입되게 한다. 환경 정보는 git같은 별도 형상관리 리포지토리에 보관하고 컨피그 서비스는 해당 서비스에 특정 환경에 배포될 때 적절한 환경 정보를 형상관리 리포지토리에서 가져와 해당 서비스에 주입한다.
    
- 쿠버네티스에서는 이런 외부 구성 저장소 패턴을 쿠버네티스 컨피그맵으로 제공한다.

### 인증/인가 패턴

- 각 서비스가 모두 인증/인가를 하는 것은 비효율적이다. 마이크로서비스에서 인증/인가를 처리하기 위해서는 다음과 같은 패턴을 사용한다.
    - 중앙 집중식 세션 관리
        
        공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 한다. 이때 세션 저장소로는 보통 레디스나 멤캐시드를 사용한다.
        
    - 클라이언트 토큰
        
        JWT와 같은 클라이언트 토큰을 사용한다.
        
        1. 브라우저가 서버에 사용자명, 패스워드로 인증 요청
        2. 서버는 인증 후 토큰 생성하고 브라우저에 토큰에 인증/인가 정보를 포함하여 전송
        3. 브라우저는 서버에 요청할 때 토큰을 함께 보내어 서버는 토큰 정보를 확인함
    - API 게이트웨이를 사용한 클라이언트 토큰
        
        토큰 인증 프로세스와 유사하지만 API 게이트웨이가 외부 요청의 입구로 추가된다.
        
        인증/인가를 처리하기 위한 별도의 전담 서비스를 만들어서 다른 서비스의 인증/인가 처리를 위임할 수 있다.

---------------------------

7일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발

### 장애 및 실패 처리를 위한 서킷 브레이커 패턴

- 서킷 브레이커 패턴
    
    여러 서비스로 구성된 시스템에서 한 서비스에 장애가 발생했을 때 다른 서비스가 영향을 받지 않도록, 장애가 발생한 서비스를 격리해서 유연하게 처리할 수 있는 방법
    
- 서비스 상태를 실시간으로 관리해서 시각화, 모니터링하고, 특정 서비스에서 장애가 감지되면 장애가 다른 서비스로 전이되지 않게 하는 것을 전기회로 차단기와 비슷하다고 해서 서킷 브레이커 패턴이라고 한다.
- 설명
    
    A서비스가 B서비스를 호출해 서비스를 제공하는데, B서비스에서 장애가 발생하면 동기 요청의 성격상 A는 계속 기다린다. 그러면 A서비스까지 장애가 발생한 것처럼 사용자가 느낀다. 서킷 브레이커 패턴은 이 경우 B서비스 호출에 대한 연속 실패 횟수가 임곗값을 초과하면 회로 차단기가 작동해 이후 서비스를 호출하려는 모든 시도를 즉시 실패하게 만든다. 
    
    그리고 폴백 메서드를 지정해두면 장애가 발생했을 때 폴백 메서드가 자연스럽게 처리한다. 그러면 사용자는 장애가 발생했는지 눈치채치 못하고, 시간이 흘러 장애가 복구됐을 때 다시 호출을 정상화하면 된다.
    

### 모니터링과 추적 패턴

마이크로서비스에서는 실시간으로 장애를 감지하는 모니터링, 추적 패턴이 필요하다.

### 중앙화된 로그 집계 패턴

- 마이크로서비스에서는 사용량에 따라 탄력적으로 변하면서 인스턴스가 생성,삭제되는 과정에서 로컬 로그가 초기화될 수 있다.
- 로그를 이벤트 스트림으로 처리해야 한다. 서비스는 스트림의 전달이나 저장에 절대 관여하지 않아야 한다. → 그래서 필요한 것이 중앙화된 로그 집계 패턴이다.
- 서비스에서 발생한 이벤트 스트림 형태의 로그를 수집하고 살펴볼 도구가 필요한데, 대표적으로 ELK 를 많이 쓴다.
    - 엘라스틱서치 : 분석 엔진 (로그 인덱싱)
    - 로그 스태시 : 로그 집합기
    - 키바나 : 시각적으로 로그 내역을 보여주는 대시보드

### MSA 기술 변화 흐름

- MSA + Neflix oss == 1.0
- MSA + OpenShift  == 1.0, MSA + k8s == 2.0
- MSA + Istio == 3.0

### 서비스 메시 패턴

- 초창기 MSA 기술인 넷플릭스 oss나 스프링 클라우드 기반 서비스 구축 및 운용 시 문제점
    - 운영 관리를 위한 여러 개의 기반 서비스를 별도로 각각 만들어야 하는 번거로움
    - 업무 처리 MSA에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재해야 한다는 점
    - 스프링 클라우드는 자바 기반이므로 자바 외의 언어로 구현된 경우 사용할 수 없음
- 최근에는 MSA 문제 영역 해결을 위한 기능을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 서비스 메시 패턴이 선호되고 있다.
- 이스티오는 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴을 적용해서 서비스 디스커버리, 라우팅, 로드 밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다.
- 사이드카 패턴은 모든 서비스 컨테이너에 추가로 사이드카 컨테이너가 배포되는 패턴이다. 각 서비스를 연계할 때 한 서비스가 다른 서비스를 직접 호출하지 않고 사이드카인 프록시를 통해 연계해서 개발자가 별도의 작업 없이 관리 및 운영에 대한 서비스를 적용할 수 있다.
- 서비스 메시를 적용하는 경우, 마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 담겨있기 때문에 마이크로서비스는 순수 비즈니스 로직에 집중할 수 있다.
- 컨트롤 플레인 기능에 의해 중앙에서 통제되며, 사이드카끼리 통신해서 관련 운영 관리 기능을 제공한다.
- 쿠버네티스의 컨테이너 단위인 파드에 서비스 컨테이너와 사이드카 구현체인 엔보이 컨테이너가 함께 배포된다.
- 넷플릭스 oss나 스프링 클라우드 기반은 비즈니스 로직과 함께 코드로 표현돼야 하지만, 이스티오는 완전히 사이드카로 격리되며 yaml 파일과 같은 설정 파일에 의해 정의된다.

---------------------------

8일차
ddd, msa

## 2.4.3 애플리케이션 패턴

프론트엔드는 어떻게 설계해야할까. 백엔드가 MSA인데 프론트가 모노리스라면 프론트에서도 모노리스의 문제점을 똑같이 가져가게 된다. 구성 패턴을 알아보자.

### UI 컴포지트 패턴 또는 마이크로 프런트엔드

프론트엔드도 백엔드 마이크로서비스처럼 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프론트엔드를 조합해서 동작하게 한다. 이 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 한다.

### 마이크로서비스 통신 패턴

- 동기 통신 방식
    
    클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를 호출할 때 사용되는 기본 통신 방법이다.
    
    서버 간 호출도 기본적으로 REST API 동기식 호출이 기본이다.
    
    하지만 동기식 호출은 여러 서비스 간 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 장애가 연쇄적으로 발생할 수 있다.
    
- 비동기 통신 방식
    
    카프카 등의 메시지 브로커를 활용해 메시지 기반의 비동기 호출을 할 수 있다.
    
    메시지 브로커에 의해 중계되므로 서로 통신하는 서비스들 사이에 의존성이 없다. 그러므로 마이크로서비스에 효과적인 방법이다.
    
    느슨한 결합으로 확장성, 탄력성 측면에서 이점이 많다.
    

### 저장소 분리 패턴

- 기존 모노리스 시스템의 저장소는 통합 저장소다. 애플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용하는 구조다.
    
    이러한 구조를 데이터 중심 애플리케이션이라 하는데, 성능 문제가 발생하면 스케일 업에 의존할 수밖에 없다.
    
- 저장소 분리 패턴은 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다. 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근할 수 있다.
    
    이런 패턴은 여러 개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것이냐는 문제가 있다.

---------------------------

9일차
ddd,msa

### 분산 트랜잭션 처리 패턴

- 분산 트랜잭션 처리를 위한 전통적인 방법으로 2단계 커밋 같은 기법이 있다. 이는 원자성을 보장하기 위해 분산 트랜잭션에 포함돼있는 모든 노드가 커밋되거나 롤백하는 메커니즘이다.
    
    이 방법은 각 서비스에 잠금이 걸려 발생하는 성능 문제 때문에 효율적인 방법이 아니다. 또한 MongoDB 같은 NoSQL 저장소는 2단계 커밋을 지원하지 않는다.
    
- 마이크로서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴이 사가 패턴이다.
    
    사가 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다. 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춘다. 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 다음, 사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 메시지 또는 이벤트를 게시해서 데이터의 일관성을 맞춘다.
    
- 데이터 일관성에 대한 생각의 전환: 결과적 일관성
    - 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것은 아니다. 실시간으로 맞지 않더라도 어느 일정 시점이 됐을 때 일관성을 만족해도 되는 것이 있다.
    - 결과적 일관성의 개념은 고가용성을 극대화한다.

### 읽기와 쓰기 분리: CQRS 패턴

- 일반적인 애플리케이션에서는 조회가 쓰기보다 많이 쓰인다. 그래서 조회와 쓰기를 분리하는 패턴을 CQRS 패턴이라 한다.
- 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 아예 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있다.
- CQRS 패턴에서 데이터 일관성 유지를 위해 필요한 것이 이벤트 주도 아키텍처다. 명령 서비스는 저장소에 데이터를 쓰면서 저장한 내역이 담긴 이벤트를 발생시켜 메시지 브로커에 전달한다. 조회 서비스는 메시지 브로커의 이벤트를 구독하고 있다가 이벤트 데이터를 가져와 데이터를 최신 상태로 동기화한다. 결과적 일관성이 보장된다.

### API 조합과 CQRS

여러 개의 마이크로 서비스를 연계해서 서비스로 제공하는 경우 사용할 수 있는 방법들

- API 조합
    
    각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있다. 이런 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져온다.
    
- CQRS
    
    조회용 마이크로서비스를 별도로 생성하고 다른 서비스로부터 비동기 이벤트로 일관성을 맞춤으로써 API 조합 방식의 단점인 직접적인 의존성을 줄일 수 있다.

---------------------------

10일차
ddd, msa

### 쓰기 최적화: 이벤트 소싱 패턴

- 사가 패턴 및 CQRS 패턴에서 비즈니스 불일치를 피하기 위해서는 저장소에 저장하는 일과 메시지를 보내는 작업이 언제나 완전하게 진행되어 함께 실행돼야 한다.
- 객체의 상태 변화를 이벤트 메시지로 발행하고 또 객체의 상태 변경에 따라 데이터 모델로 처리되고 최종값을 반영하는 과정은 복잡하고 느릴 수밖에 없다.
- 이를 해결하기 위해, 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장하는 이벤트 소싱 기법을 사용할 수 있다. 이렇게 하면 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있고, 복잡한 과정이 없어 쓰기 속도가 훨씬 빠르다.
- 현재 시점의 상태가 필요하면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산한다.
- 서비스가 이벤트 저장소에 대한 CRUD를 모두 처리할 필요 없이, CR만 처리하면 된다. 변경과 삭제가 없어 명령 측면의 서비스를 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않는다.
    
    한번 발생한 후에 수정되지 않고 업데이트나 삭제 없이 입력만 되므로 동시성이나 정합성 등의 문제에 자유롭다.

# 3.1 비즈니스 로직은 어디에? - 관심사의 분리

- 개발자의 역할은 문제 영역의 비즈니스 로직을 분석 및 이해하고 프로그래밍 언어라는 도구로 잘 표현하는 일이다.
- 관심사의 분리 원칙에 따라 각 영역은 고유 관심사에 의해 분리되고 집중돼야 한다.
- 비즈니스 로직 영역과 기술 문제를 처리하기 위한 기술 영역은 철저히 분리하는 것이 좋다.
    
    이것은 비즈니스 로직이 기술보다는 오랫동안 지속되고 안정적이어야 할 애플리케이션의 핵심 영역이기에 기술에 영향을 적게 받도록 설계하는 것을 강조한 데서 기인한다.
    
- 애플리케이션의 유지보수성이 높다는 의미는 특정 개인에 의존하기보다는 어느 누구라도 손쉽게 애플리케이션을 이해하고 유지보수할 수 있음을 의미한다.

## 3.1.1 데이터베이스 중심 아키텍처의 문제점

- 데이터베이스 중심 아키텍처란 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 다음 이 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식이다.
- 비즈니스 민첩성을 위해서는 유연성과 확장성이 중요한데, 데이터베이스 중심 아키텍처에서는 저장소와 강결합되어있기 때문에 저장소를 변경하려 해도 쉽게 변경할 수 없다.
- 대부분의 성능을 데이터베이스에 의존하게 된다. 그러면 성능을 위해 스케일 업을 선택해야 하는데, 이는 클라우드 인프라의 장점인 자동 스케일 아웃이 의미 없어진다.
- 클라우드의 풍부한 자원 환경에서는 애플리케이션 자체의 성능보다는 애플리케이션의 확장성과 유연함이 더 중요하다. 비즈니스 로직 처리와 데이터 처리를 철저히 분리하는 것이 반드시 필요하다.

---------------------------

11일차
ddd,msa 

# 3.2 헥사고날 아키텍처와 클린 아키텍처

## 3.2.1 레이어드 아키텍처

- 프레젠테이션, 비즈니스 로직, 데이터 액세스의 3계층으로 구분하는 것이 일반적이다.
- 상위 계층은 직접적으로 하위 계층을 호출하지 않고 추상적인 인터페이스에 의존한다. 이 경우 하위 계층에서는 추상적 인터페이스를 만족하는 다양한 방식의 구현체를 선택적으로 적용할 수 있다.
- 애플리케이션에서는 비즈니스 로직이 핵심 영역이다. 비즈니스 로직을 보통 고수준 영역이라고 하고, 프레젠테이션 계층 및 데이터 액세스 계층을 저수준 영역이라고 한다. 고수준 영역은 핵심 영역이므로 보호를 받아야 하고, 따라서 저수준 영역의 변경이나 확장에 영향을 받지 않아야 한다. 그러나 일반적인 레이어트 아키텍처의 규칙만 따르면 고수준 영역이 저수준 영역에 의존하게 되고 영향을 받게 된다.
- 이를 해결하기 위해 의존성 역전 원칙을 적용해야 한다. 인터페이스를 고수준의 비즈니스 로직 계층에서 정의하여 기존의 위에서 아래로 흘렀던 의존 관계를 역전시키고 고수준 영역이 저수준 영역의 변경에 영향을 받지 않게 하는 것이다.

## 3.2.2 헥사고날 아키텍처

- 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 존재한다. 단방향 계층구조에서는 이러한 점을 지원하기 힘들다. 다방면으로 열려있는 헥사고날 아키텍처는 이러한 문제점을 해결할 수 있다.
- 헥사고날 아키텍처에서는 고수준의 비즈니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부 영역으로 나눈다. 내부 영역은 순수 비즈니스 로직을 표현하는 기술 독립적인 영역이다. 그리고 외부 영역과 연계되는 포트를 가지고 있다. 외부 영역은 외부에서 들어오는 요청을 처리하는 인바운드 어댑터와 비즈니스 로직에 의해 호출되어 외부와 연계되는 아웃바운드 어댑터로 구성된다.
- 헥사고날 아키텍처의 가장 큰 특징은 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게 하는 것이다. 이를 가능하게 하는 것이 내부 영역에 구성되는 포트다.
- 인바운드 포트는 내부 영역의 사용을 위해 표출된 API이며, 외부 영역의 인바운드 어댑터가 호출한다. 아웃바운드 포트는 내부 영역이 외부를 호출하는 방법을 정의한다.
    
    아웃바운트 어댑터가 아웃바운드 포트에 의존해서 구현된다.
    
- 인바운드 어댑터로는 REST API를 발행하는 컨트롤러, 이벤트 메시지 구독 핸들러 등이 될 수 있고,
아웃바운드 어댑터로는 데이터 액세스 처리를 담당하는 DAO, 이벤트 메시지를 발행하는 클래스, 외부 서비스를 호출하는 프락시 등이 될 수 있다.

## 3.2.3 클린 아키텍처

- 로버트 C. 마틴이 제안한 아키텍처로, 헥사고날 아키텍처의 아이디어와 유사하다.
- 소프트웨어는 행위 가치와 구조 가치로 나뉘며, 소프트웨어를 부드럽게 만드는 것이 구조 가치이므로 구조 가치가 더 중요하다.
- 소프트웨어를 부드럽게 유지하는 방법은 구조 중에서 선택할 수 있는 것을 가능한 한 오래 열어두는 것이다.
- 구조
    
    여러 겹으로 둘러싸인 구조이며, 중앙부터 소개한다.
    
    - 엔티티
        
        해당 도메인의 업무를 규정하는 핵심 규칙 (비즈니스 업무 규칙)
        
        핵심 규칙은 데이터와 본질적으로 결합돼 있으므로 객체로 쉽게 만들 수 있다.
        
    - 유스케이스
        
        유스케이스는 자동화된 시스템을 사용하는 처리 절차를 기술한다.
        
        유스케이스는 애플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다.
        
        엔티티 같은 고수준 영역은 저수준의 유스케이스 영역을 알게 해서는 안된다.
        
    - 세부사항
        
        유스케이스를 감싸고 있는 나머지 모든 영역.
        
        입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
        
        이렇게 분리하면 테스트 용이성, 개발 독립성, 배포 독립성을 강화할 수 있다.

---------------------------

12일차
ddd,msa

# 3.3 마이크로서비스의 내부 구조 정의

## 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스

- 마이크로서비스의 내부 구조를 정의할 때, 마이크로서비스 시스템에서 정의해야 할 마이크로서비스 내부 구조가 다양할 수 있다는 것이다. 마이크로서비스는 폴리글랏한 내부 구조를 가질 수 있기 때문이다.
- 지향하는 원칙들
    - 지향 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮춰야 한다.
    - 비즈니스 로직 영역을 기술 기반 영역으로부터 분리해야 한다.
    - 기술 중심의 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다.
    - 고수준 영역은 저수준 영역에 의존하지 않아야 한다.
    - 저수준 영역은 언제든 교체, 확장 가능해야 하며, 이 변화가 고수준 영역에 영향을 미치면 안된다.
    - 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전 원칙을 적용한다.
    - 인터페이스는 고수준 영역에 존재해야 하며, 저수준 어댑터가 이를 구현한다.

## 3.3.2 내부 영역 - 업무 규칙

- 업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재한다.
- 서비스 인터페이스는 외부 영역이 내부 영역에 대해 많이 알지 못하게 하는 역할을 한다.
- 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스는 의존 관계 역전의 원칙을 지원한다.
- 서비스와 도메인은 클린 아키텍처의 유스케이스와 엔티티의 역할과 같다. 도메인은 비즈니스 개념을 표현하고 서비스는 도메인을 활용해 시스템 흐름 처리를 수행한다.

### 트랜잭션 스크립트 패턴

- 도메인 객체가 행위를 가지고 있지 않고, 모든 비즈니스 행위가 서비스에 있다.
- 도메인 객체는 정보 묶음일 뿐이고, 서비스는 점점 비대해져 유지보수가 어려워진다.
- 절차식 프로그래밍 방식이므로 간단한 비즈니스를 처리할 때 적용하는 것이 좋다.

### 도메인 모델 패턴

- 도메인 객체가 데이터와 비즈니스 행위를 가지므로, 정보 은닉성을 가진다.
- 객체지향적이므로 복잡한 비즈니스 로직을 처리하는 데 유용하므로, 복잡한 비즈니스 로직이 많은 마이크로서비스의 구조로 선택하는 것이 좋다.

### 도메인 주도 설계의 애그리거트 패턴

- 도메인 모델링에서 객체 간의 관계를 참조로 정의할 경우, 일대다 관계로 쉽게 사용할 수 있지만 업무가 복잡해지면 관계가 복잡해지고 무거워진다.
- 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴이다.
- 엔티티와 값 객체가 개념적으로 묶인 모음 전체를 애그리거트라고 한다.
- 애그리거트 패턴 규칙
    - 애그리거트 루트만 참조한다.
    - 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. 수정할 때도 마찬가지다.
    - 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.
    - 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리거트를 함께 수정하는 실수를 방지한다.
    - 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다.

---------------------------

13일차
ddd, msa

## 3.3.3 외부 영역 - 세부사항

- 외부 영역 구성
    - 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터
    - 내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터
- 어댑터는 플러그인처럼 교체, 확장에 자유롭다.
    
    내부 영역이 먼저 정의된 후 외부 영역의 세부사항은 늦게 정의돼도 상관없어야 한다.
    

### API 퍼블리싱 어댑터

REST API를 발행하는 인바운드 어댑터.

엔티티를 직접 제공하지 않고 API 필요에 맞는 DTO를 생성해서 엔티티를 변환 및 매핑해서 전달해야 클라이언트로 도메인 규칙이 유출되지 않는다.

### API 프락시 어댑터

다른 서비스의 API를 호출하는 아웃바운드 어댑터.

기술에 맞는 적절한 통신 방법을 구현해야 한다.

### 저장소 처리 어댑터

저장소 처리 어댑터 구현 시, 데이터 처리 메커니즘을 선택해야 한다. (ORM or SQL매핑)

### 도메인 이벤트 발행 어댑터

도메인 이벤트가 생성되는 위치는 내부 영역이며, 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

### 도메인 이벤트 핸들러

외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달하는 일을 수행한다.

4장
애자일에는 빨리, 자주 실패를 경험해 보는 것이 중요하므로 단순한 설계를 통해 우선 MVP를 만들어 자주 배포하는 것이 중요하다. 이를 위해 기민한 반복 주기에 적합한, 군더더기를 제거하고 핵심 활동에 집중할 수 있는 마이크로서비스 설계 및 개발 방법이 필요하다.

# 4.1 도메인 주도 설계와 마이크로서비스

- 마이크로서비스를 도출하고 내부 구조를 설계하는 데 도메인 주도 설계 기법을 활용하는 것이 효과적이다.
- DDD에는 전략적 설계와 전술적 설계가 있다.
    - 전략적 설계
        
        도메인 전문가 및 기술팀이 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고, 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트로 정의하고 경계의 관계를 컨텍스트 맵으로 정의하는 활동
        
    - 전술적 설계
        
        식별된 바운디드 컨텍스트 내의 도메인 개념인 도메인 모델을 구성하는 유용한 모델링 구성요소들을 설명

---------------------------

14일차
ddd, msa

# 4.2 기민한 설계/개발 프로세스

## 4.2.1 점진/반복적인 스크럼 생명주기

- 기본 생명주기는 스크럼의 스프린트를 활용한다. 보통 1~4주다.
- 백로그라는 일감 목록을 기반으로 각 스프린트에 일감이 배분되어 진행된다.
- 스프린트를 진행하다 보면 일정 내에 완료해야 할 일의 우선순위를 결정하는 것이 매우 중요해지고, 우선순위가 높은 핵심 기능에 집중할 수 있게 해준다.

## 4.2.2 아키텍처 정의와 마이크로서비스 도출

- 아키텍처 정의
    - 기술 세부사항은 늦게 결정할 수 있어야 한다.
    - 순수 비즈니스 로직이 존재하는 내부 영역과 기술 영역을 표현하는 외부 영역으로 구분해보면, 외부 영역은 언제든 교체딜 수 있으므로 내부 영역에 집중하고, 외부 영역은 천천히 결정해도 된다는 말이다.
- 마이크로서비스 도출
    
    전략적 설계 기법으로 마이크로서비스를 도출하고 우선순위에 근거해 스프린트를 진행한다.
    

## 4.2.3 스프린트 내 개발 공정

### 백엔드 설계 및 개발

- 백엔드 설계의 시작은 API 설계다.
- 그 다음 설계는 정의된 마이크로서비스 내부 구조에 따라 도메인 모델과 데이터 모델을 설계하는 것이다.

### 프런트엔드 영역 설계와 개발

- 프런트엔드 영역 설계는 UI 레이아웃을 정의하고 API를 호출해서 API 데이터 기반으로 UI를 어떻게 표현할지 정의하는 활동이다.

### 빌드 및 배포

기민한 개발을 위해 개발 과정에서 지속적으로 빌드되고 자동으로 배포되도록 빌드 및 배포 환경을 자동화해야 한다.

5장
모듈화는 중요하다. 모듈화의 근본적인 가치는 각 모듈을 기능적으로 응집성 높게 만들고, 기능이 다른 타 모듈 간의 의존도를 낮추는 것이다. 마이크로서비스 설계에서도 똑같다.

# 5.1 마이크로서비스를 도출하는 방법

각 마이크로서비스가 다른 서비스와 의존하지 않게 도출해야 하므로, 어떤 비즈니스 기능들을 묶어서 독립적인 마이크로서비스로 도출할 것인가가 매우 중요하다.

## 5.1.1 비즈니스 능력에 근거한 도출

- 회사에서 부서가 나뉘어진 방식대로 도출하는 방식이다.
- 장점 : 쉽고 직관적으로 도출할 수 있다.
- 단점 : 전체적인 비즈니스 이해에는 유용하지만, 서비스간 관계를 파악하기에는 미흡하다.

---------------------------

15일차
ddd, msa

## 5.1.2 DDD의 바운디드 컨텍스트 기반 도출

- 마이크로서비스를 도출할 때 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요하다.
- DDD에서는 데이터를 기능과 분리해서 식별하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다.
- 마이크로서비스의 크기는 코드의 크기처럼 양적으로 판단하는 것이 아니라, 전체 업무 맥락에서 질적으로 판단해야 한다.

# 5.2 DDD에서의 설계

- DDD의 전략적 설계에서는 비즈니스 응집성이 있는 컨텍스트를 구분하고, 이를 바운디드 컨텍스트라 하는데, 이 단위가 마이크로서비스를 식별하기 위한 훌륭한 단위가 될 수 있다.
- 마이크로서비스 내부 구조를 정의하고 상세히 설계하기 위해 DDD의 객체 설계 기법인 전술적 설계를 사용할 수 있다.

# 5.3 DDD의 전략적 설계

## 5.3.1 도메인과 서브도메인

- 많은 개념들이 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리해야 한다. 이렇게 분리된 하위 도메인을 서브도메인이라고 한다.
- 서브도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반 서브도메인로 나뉜다.
    - 핵심 서브도메인
        
        경쟁자와 차별화를 만들 비즈니스 영역이므로 가장 중요하고, 소프트웨어 개발에서 전략적으로 가장 큰 투자가 필요한 영역이다.
        
    - 지원 서브도메인
        
        비즈니스에 필수적이지만 핵심은 아닌 부분이다. 핵심 도메인을 성공시키기 위해 반드시 필요한 영역이다.
        
    - 일반 서브도메인
        
        비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에 필요한 부분으로, 기존 제품을 구매해서 대체 가능하다.
        
- 전략적 설계를 수행하기 위해 중요한 개념
    - 도메인의 주요 개념을 정의하고 도메인 간의 경계를 식별하는 바운디드 컨텍스트
    - 도메인의 모든 구성원이 공통으로 사용하는 유비쿼터스 언어

## 5.3.2 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트

- DDD에서는 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 유비쿼터스 언어라고 한다.
- 특정 도메인의 업무 개념을 표현하는 언어다. 결제 도메인에서의 고객과 배송 도메인에서의 고객은 의미가 다르다.
- 도메인 모델은 특정 비즈니스 맥락에서 통용되는 개념들의 관계를 잘 정의한 모형이다.
- 이곳에서 사용하는 언어와 저곳에서 사용하는 언어와 개념이 상이한 경계가 바로 도메인의 경계인 바운디드 컨텍스트다.
- 유비쿼터스 언어는 코드에서도 살아 숨 쉬어야 한다.

## 5.3.3 컨텍스트 매핑

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 생긴다. 이런 컨텍스트 간의 의존 관계를 DDD에서는 컨텍스트 매핑이라 한다.
- 컨텍스트 간의 매핑 관계를 표시한 다이어그램을 컨텍스트 맵이라 한다.

### 주요 컨텍스트 매핑 관계

- 공유 커널
    
    바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계다.
    
- 소비자와 공급자
    
    공급하는 컨텍스트는 upstream, 소비하는 컨텍스트는 downstream으로 표시한다. 공급자의 변화를 소비자는 따라야 한다. 공급자는 소비자가 원하는 기능을 제공해야 한다.
    
- 준수자
    
    소비자와 공급자 관계와 유사하지만 upstream이 downstream의 요구를 지원하지 못하는 경우 사용한다. 이 경우 downstream은 upstream에서 제공하는 모델을 그대로 사용한다.
    
- 충돌 방지 계층 (ACL; anti-corruption layer)
    
    downstream이 upstream 모델에 영향을 받을 때 downstream 고유 모델을 지키기 위한 번역 계층을 만드는 것이다.
    
    클라우드 기반 마이크로서비스 아키텍처를 적용하는 새로운 시스템을 레거시 시스템과 통합하기 위해 주로 사용한다.

---------------------------

16일차
ddd, msa

- 공개 호스트 서비스 (OHS; Open Host Service)
    
    공개 호스트 서비스는 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다. 보통 다른 컨텍스트에서 사용할 수 있는 공유된 API가 여기에 해당한다.
    
- 발행된 언어 (PL; Published Language)
    
    downstream 컨텍스트가 upstream 컨텍스트가 제공하는 기능을 사용하게 하기 위해 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어다. XML이나 JSON 스키마로 표현될 수 있다. 주로 공개 호스트 서비스와 짝을 이루어 사용한다.
    

### 컨텍스트 맵

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하고 이들 간의 관계를 표현한 그림을 컨텍스트 맵이라 한다.
- 각 서브도메인 간의 관계는 일반 서브도메인이 핵심 서브도메인, 지원 서브도메인과 공급자/소비자 관계를 맺고 있으며, 일반 서브도메인이 공개 호스트 서비스로 일반 서브도메인을 사용할 수 있도록 프로토콜/인터페이스를 제공하면서 발행된 언어를 다른 컨텍스트에 제공한다.
    
    핵심 서브도메인에 포함되는 컨텍스트는 일반 서브도메인과 지원 서브도메인에 속하는 컨텍스트를 사용하고 지원 서브도메인에 포함된 컨텍스트는 일반 서브도메인의 컨텍스트들을 사용한다.
    

# 5.4 이벤트 스토밍을 통한 마이크로서비스 도출

시스템의 액터는 원하는 바를 얻기 위해 시스템을 조작하고, 이 조작은 시스템을 동작하게 한다. 이 동작을 통해 사용자의 요청에 해당하는 데이터를 만들고 이 정보는 간단한 스케치 형태의 UI 형태로 액터에서 제공된다.

## 5.4.1 이벤트 스토밍 워크숍 준비

포스트잇을 벽에 붙여가며 설계한다.

### 스티커 유형별 의미

- 도메인 이벤트 - 오렌지색
    
    발생한 사건. 과거시제동사로 표현
    
- 커맨드 - 파란색
    
    도메인 이벤트를 트리거하는 명령
    
- 외부 시스템 - 핑크색
    
    도메인 이벤트가 호출하거나 관계가 있는 레거시 또는 외부 시스템
    
- 액터 - 작은 노란색
    
    개인 또는 조직의 역할
    
- 애그리거트 - 노란색
    
    도메인 이벤트와 커맨드가 처리하는 데이터 상태가 변경되는 데이터
    
- 정책 - 라일락색
    
    이벤트 조건에 따라 진행되는 결정
    
- 읽기 모델 - 초록색
    
    도메인 이벤트 액터에게 제공되는 데이터
    
- 사용자 인터페이스 - 흰색
    
    스케치 형태의 레이아웃
    
- 핫스폿 - 자주색
    
    의문, 질문, 미결정 사항

---------------------------

17일차
ddd, msa

## 5.4.2 이벤트 스토밍 워크숍 진행

다음과 같은 순서로 진행한다.

도메인 이벤트 찾기 → 외부 시스템/외부 프로세스 찾기 → 커맨드 찾기 → 핫스폿 찾기 → 액터 찾기 → 애그리거트 정의하기 → 바운디드 컨텍스트 정의하기 → 컨텍스트 매핑하기

1. 도메인 이벤트 찾기
    
    데이터나 데이터 구조가 아닌 비즈니스 흐름에서 발생한 이벤트에 초점을 두어야 한다. 시스템의 화면을 연상하지 말고 비즈니스가 흘러감에 따라 비즈니스를 구성하는 요소들의 상태가 어떻게 변경되는지 생각한다.
    
2. 외부 시스템 도출
    
    이벤트를 도출하면서 레거시 시스템이나 외부 시스템과의 연계를 통해 업무 흐름이 진행될 때는 이벤트의 오른쪽 상단에 붙이고 화살표로 이 외부 시스템을 호출한다는 것을 표시한다.
    
3. 커맨드 도출
    
    도메인 이벤트를 찾은 후에 이 이벤트를 동작하게 하는 커맨드를 찾는다.
    
4. 핫스폿 도출
    
    워크숍 중에 해결할 수 없는 사항들을 기록해둔다.
    
5. 액터 도출
    
    액터는 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 도출한다.
    
    액터를 도출하면서 문장을 만들어 식별한 커맨드와 이벤트를 검토해보자.
    
6. 애그리거트 정의
    
    애그리거트는 커맨드와 도메인 이벤트가 영향을 주는 데이터로, 도메인의 실체 개념을 표현하는 객체인 엔티티가 된다.
    
7. 바운디드 컨텍스트 정의하기
    
    이름이 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 그린다. 기능을 제공할 책임들을 응집성 있도록 동일한 애그리거트 중심으로 모듈화해야 한다.
    
    정책을 도출하면서 연관관계를 생각해본다. 정책은 도메인 이벤트와 커맨드 사이에 존재한다.
    
8. 컨텍스트 매핑하기
    
    호출 관계의 방향, 호출 방식에 대해 생각해야 한다.
    
    호출 방식은 데이터의 일관성 측면과 컨텍스트의 가용성 측면을 고려해서 선택한다. 항상 일관된 데이터가 필요한 관계는 동기 호출로 표현하고, 결과적 일관성으로 충분하면 비동기 방식 호출로 표현한다.
    
    동기 방식은 두 컨텍스트 간의 의존도가 높아지고, 비동기 방식은 의존도를 낮출 수 있다. 즉, 반드시 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋다.
    
    이렇게 도출된 바운디드 컨텍스트는 마이크로서비스 후보가 된다.

---------------------------

18일차
DDD MSA

# 5.5 마이크로서비스 상세설계

## 5.5.1 프런트엔드 모델링

프런트엔드 모델링의 설계 영역은 다음과 같다.

- 프런트 아키텍처 정의
- 표준 레이아웃 정의
- UI레이아웃 설계
- UI 디자인 및 UI레이아웃 반영
- 이벤트 설계

## 5.5.2 백엔드 모델링

- 백엔드 마이크로서비스를 위한 설계는 헥사고날 아키텍처를 적용해 외부 영역과 내부 영역으로 구분되어 진행된다.
- 이벤트 스토밍의 커맨드는 헥사고날 인바운드 어댑터의 하나인 REST API가 되고, 애그리거트는 헥사고날 내부 영역인 도메인 모델이 되며, 도메인 이벤트는 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상이 되고, 외부 시스템은 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템으로 매핑된다.

### API 설계

- API는 백엔드 서비스에 존재하지만 프런트엔드의 요구사항을 충족하도록 정의해야 한다.
- REST API
    - 직접적인 사용의 주체가 되는 요소를 자원이라 하며, URI 형식으로 표현된다.
    - API를 사용하기 위한 입출력 데이터로 JSON 포맷을 활용한다. 행위를 표현하기 위해 HTTP 메서드를 활용한다.

---------------------------

19일차
ddd,msa

# 5.6 도메인 모델링

- 마이크로서비스 내부 구조는 폴리글랏하게 접근할 수 있다.
    
    서비스 내부 영역의 구조를 도메인 모델 중심으로 만들 수도 있고 트랜잭션 스크립트 형태로 만들 수도 있다.
    
- 도메인 모델 중심 구조
    
    도메인 모델을 중심으로 모델링을 수행해야 하며, 서비스가 모든 로직을 처리하지 않고 비즈니스 로직이 도메인 모델로 위임되어 적절히 분산된다.
    
- 모데인 모델이 없는 트랜잭션 스크립트 구조
    
    DTO는 데이터 묶음으로써의 역할만 수행하고, 서비스가 많은 로직을 보유하게 되어 시스템이 복잡해질수록 비대해진다.
    

## 5.6.1 DDD의 전술적 설계(도메인 모델링 구성요소)

기존 객체 모델링 방식은 자유도가 높아 문제 영역을 파고들수록 여러 층의 복잡한 계층 구조를 만들게 될 가능성이 높다. 이를 정리하기 위해 객체들의 역할에 따른 유형을 정의하고 이런 규칙에 따라 모델링하면 단순, 이해하기 쉬워진다.

- 엔티티
    
    엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체다. 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다.
    
- 값 객체
    
    값 객체는 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다.
    
    값 객체는 속성과 속성의 합에 의해 전체 개념이 부여되며, 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체다.
    
- 표준 타입
    
    표준 타입은 대상의 타입을 나타내는 서술적 객체다. 속성을 구분하는 용도로 사용한다.
    
- 애그리거트
    
    연관된 엔티티와 값 객체들의 묶음이 애그리거트다. 애그리거트 단위가 트랜잭션의 기본 단위가 된다.
    
    애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정하고, 이 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있다.
    
    애그리거트 간 참조는 애그리거트 루트의 식별자를 활용해 간접 참조하는 것이 바람직하다.
    
    도메인 이벤트를 통한 결과적 일관성을 사용해 다른 애그리거트를 갱신해서 일관성을 유지한다.
    
    DDD에서는 명확한 클래스의 유형과 애그리거트 단위 식별을 통해 또메인 모델을 간결하고 단순하게 유지하는 것을 추구한다.
    
- 도메인 서비스
    
    도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 하는데, 이를 도메인 서비스라 한다. 도메인 서비스에서는 상태를 관리하지 않고 행위만 존재한다.
    
- 도메인 이벤트
    
    도메인 이벤트는 DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체다. 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다.

---------------------------

20일차 (사례연구라 내용이 많이 없네요ㅠㅠ)
ddd, msa

이번 장은 실제 업무 사례로 마이크로서비스를 도출하고 아키텍처를 구성한다.

다음과 같은 순서로 이루어진다.

요구사항 정의 → 이벤트 스토밍을 통한 마이크로서비스 도출 → 외부 아키텍처 정의 → 내부 아키텍처 정의 → JHipster를 이용한 아키텍처 구성

# 6.1 요구사항 정의

도서대출시스템은 다음과 같은 서브도메인으로 나눌 수 있다.

- 사용자 관리 및 로그인
- 도서 관리
- 도서 대출 및 반납
- 배송
- 이메일

---------------------------

21일차
ddd, msa

# 6.2 이벤트 스토밍을 통한 마이크로서비스 도출

## 6.2.2 바운디드 컨텍스트 식별

- 사용자 관리 서브도메인
    - [로그인], [회원]으로 바운디드 컨텍스트 분리
- 게시판, 도서관리, 배송 서브도메인
    - 서브도메인 그대로 각각 바운디드 컨텍스트로 식별됨
- 대출,반납 서브도메인
    - [대출], [반납], [연체] 애그리거트는 [대출자] 액터 중심으로 밀접한 관계가 있으므로 [대출] 컨텍스트로 도출
    - [도서검색정보], [최다대출도서집계]는 [도서] 바운디드 컨텍스트로 식별하려했으나, 이 개념들은 도서 컨텍스트가 보유한 도서 정보보다 빈번하게 일반 회원에게 공개되어 사용돼야 하는 개념이므로 조회와 생성, 변경을 분리하는 CQRS 패턴 적용하여 [카탈로그] 바운디드 컨텍스트로 도출
    - [카탈로그] 컨텍스트는 도서 정보 조회 및 검색을 위한 역할만 전담하고, [도서] 컨텍스트의 도서가 변경됐을 때 도메인 이벤트에 의해 일관성을 맞춰야 한다.
- 이메일 서브도메인
    - [이메일] 바운디드 컨텍스트로 도출

---------------------------

22일차
DDD, MSA

## 6.2.3 컨텍스트 다이어그램

이렇게 식별된 컨텍스트가 마이크로서비스 후보가 된다. 후보라고 언급한 이유는 서비스는 이후에 배포, 운영 효율성 등을 고려해 더 분할되거나 통합될 수 있기 때문이다.

## 6.2.4 이벤트 스토밍 결과를 헥사고날 아키텍처로 표현하기

이벤트 스토밍을 통해 식별한 애그리거트는 헥사고날의 내부 영역인 도메인 모델의 후보가 되고, 커맨드 요소는 외부 영역의 인바운드 어댑터인 API의 후보, 이벤트는 외부 영역의 아웃바운드 어댑터를 통해 전송될 메시지의 대상이 된다.

식별된 정책의 일부는 내부 비즈니스 로직 구현의 규칙으로, 또다른 일부는 다른 서비스와의 호출 방향을 결정할 자료가 된다.

# 6.4 내부 아키텍처 정의

## 6.4.1 패키지 구조 및 명명 규칙

### 내부 영역

- domain
    - 유형 : 클래스
    - 명명 규칙 : 명사형
    - 명칭 및 역할
        - 도메인 모델 : 비즈니스 개념 및 로직 표현
        - 애그리거트, 엔티티, VO 표준 타입 패턴으로 구현
    - 작성 기준 : 애그리거트 단위
- service
    - 유형, 명명 규칙 : 인터페이스는 ~Service, 클래스는 ~ServiceImpl
    - 명칭 및 역할
        - 서비스 인터페이스 : 서비스 퍼사드 역할
        - 서비스 구현체 : 업무 처리 흐름 구현
- repository
    - 유형, 명명 규칙 : 인터페이스로 ~Repository
    - 명칭 및 역할
        - 리포지토리: 저장소 처리
    - 작성 기준 : 엔티티당 1개

---------------------------

23일차
ddd, msa

# 6.5 JHipster를 활용한 아키텍처 구성

- JHipster란?
    
    JHipster란 모던 웹 애플리케이션과 마이크로서비스 아키텍처를 빠르게 적용, 개발, 배포할 수 있도록 도와주는 오픈소스 개발 플랫폼이다.
    
    - 지원영역
        - 프론트엔드 : Angular, React, Vue.js
        - 백엔드 : Spring Boot, Micronaut, Quakus, Node.js, .NET
        - 배포 : Docker, k8s, Azure, GCP ..
- JHipster의 목적
    
    완전하고 현대적인 웹 애플리케이션과 마이크로서비스 아키텍처를 생성
    
- JHipster 마이크로서비스 아키텍처
    - JHipster 레지스트리
        
        MSA 디스커버리 패턴의 구현, 다른 모든 구성요소들을 서로 연결하고 서로 통신할 수 있게 한다.
        
    - 마이크로서비스
        
        백엔드 코드가 들어 있고, 실행 후 도메인에 대한 API를 노출한다. 여러 마이크로서비스로 구성될 수 있다.
        
    - 게이트웨이
        
        모든 프론트엔드 코드를 가지고 있으며, 전체 마이크로서비스에서 생성한 API를 사용한다.
        
    - 백엔드 소스코드
        
        src/main/java 폴더에 존재
        
    - 프론트엔드 소스코드
        
        src/main/webapp 폴더에 존재