Date,User,Message
2023-04-22 14:10:25,"강민규","강민규님이 들어왔습니다.
운영정책을 위반한 메시지로 신고 접수 시 카카오톡 이용에 제한이 있을 수 있습니다."
2023-04-22 14:12:26,"강민규","책너두 2기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 3월 12일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 14:12:35,"오픈채팅봇","오픈채팅봇님이 들어왔습니다."
2023-04-22 14:12:35,"오픈채팅봇","앞으로 오픈채팅봇의 자동응답을 이용하실 수 있습니다. 지금 오픈채팅봇 소개를 확인해보세요!"
2023-04-22 14:23:09,"박소환","박소환님이 들어왔습니다."
2023-04-22 14:23:09,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 14:23:15,"최다봄","최다봄님이 들어왔습니다."
2023-04-22 14:25:19,"김형우","김형우님이 들어왔습니다."
2023-04-22 14:25:19,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 14:27:30,"Bo","Bo님이 들어왔습니다."
2023-04-22 14:27:30,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 14:34:04,"최희윤","최희윤님이 들어왔습니다."
2023-04-22 14:34:04,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 15:27:38,"이찬영","이찬영님이 들어왔습니다."
2023-04-22 15:27:38,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 15:29:40,"다운","다운님이 들어왔습니다."
2023-04-22 15:29:41,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 15:30:58,"다운","다운님이 나갔습니다."
2023-04-22 15:39:24,"다운","다운님이 들어왔습니다."
2023-04-22 15:39:24,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 16:01:08,"김용기","김용기님이 들어왔습니다."
2023-04-22 16:01:08,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 16:08:17,"정성훈","정성훈님이 들어왔습니다."
2023-04-22 16:08:17,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 16:09:09,"정성훈","안녕하세요 반갑습니다 :) "
2023-04-22 17:34:08,"Hailey 박정현","Hailey 박정현님이 들어왔습니다."
2023-04-22 17:34:08,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 19:03:06,"김연정","김연정님이 들어왔습니다."
2023-04-22 19:03:06,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 19:40:02,"최윤지","최윤지님이 들어왔습니다."
2023-04-22 19:40:02,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 22:32:43,"송예은","송예은님이 들어왔습니다."
2023-04-22 22:32:43,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-22 23:39:13,"이소민","이소민님이 들어왔습니다."
2023-04-22 23:39:14,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 11:47:38,"궈노","궈노님이 들어왔습니다."
2023-04-23 11:47:38,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 13:01:33,"한종우","한종우님이 들어왔습니다."
2023-04-23 13:01:34,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 15:43:59,"김성태","김성태님이 들어왔습니다."
2023-04-23 15:43:59,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 15:48:00,"강민규","안녕하세요 여러분 책너두 운영자 강민규입니다!

아직 다섯 분 정도 안들어오신 분 계셔서 참여자분들 다 들어오면 한번에 일정 관련하여서 공지하겠습니다~"
2023-04-23 15:58:13,"강세훈","강세훈님이 들어왔습니다."
2023-04-23 15:58:13,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 16:06:45,"뚯뚜오","뚯뚜오님이 들어왔습니다."
2023-04-23 16:06:45,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 16:28:14,"김연수","김연수님이 들어왔습니다."
2023-04-23 16:28:14,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 17:13:51,"수정","수정님이 들어왔습니다."
2023-04-23 17:13:51,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 19:57:36,"쏘이쏘이양","쏘이쏘이양님이 들어왔습니다."
2023-04-23 19:57:36,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-23 20:18:05,"강민규","한분 안들어오셨지만 너무 늦었으니 전체 일정에 관한 공지 및 독서 스케줄을 안내드리도록 하겠습니다!"
2023-04-23 20:18:23,"강민규","https://breakbook.notion.site/3-40cbbab07fe2466186829974a5e9c832"
2023-04-23 20:18:34,"강민규","읽어보시고 궁금한 점 있으시면 언제든지 질문해주세요~"
2023-04-23 20:20:31,"강민규","최고 중요한 사항 요약:
1. 2일 연속 결석 시 강퇴
2. 월요일까지 책 변경 혹은 이탈 가능
3. 독서 일지 작성 시 가장 앞에 '~일차 제출' 이라고 써서 제출할 것
"
2023-04-23 20:21:54,"강민규","톡게시판 '공지': https://breakbook.notion.site/3-40cbbab07fe2466186829974a5e9c832"
2023-04-23 20:49:38,"김연수","혹시 함수형코딩으로 책 변경 가능할까요?"
2023-04-23 20:49:48,"박소환","- **5주차 (4/10 ~ 4/14)**
    
    독서 활동을 잠시 멈추고 특별 활동을 진행합니다.  향후 안내 드릴 예정입니다.

링크에 날짜가 이상해요"
2023-04-23 21:44:37,"강민규","함수형 코딩은 이번 기수에 진행을 안합니다!"
2023-04-23 21:45:17,"강민규","소환님 감사합니다. 날짜를 제거했습니다!"
2023-04-23 21:47:36,"박소환","노션 중간에 독서스케쥴 링크가 있는데, 지난 기수 내용이 그대로 남아있습니다. 해당 링크도 변경 부탁드립니다."
2023-04-23 21:48:50,"강민규","아 넵 감사합니다~ 지금 독서스케줄 작업하고 있어서 내일 확인 가능합니다! "
2023-04-23 23:46:14,"강민규","정성훈님을 내보냈습니다."
2023-04-23 23:52:23,"호02","호02님이 들어왔습니다."
2023-04-23 23:52:23,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-24 07:40:36,"강민규","안녕하세요 여러분 좋은 아침입니다. 오늘은 책너두 3기의 첫날이네요!

제가 어제 공유드린 링크는 들어가서 읽어보셨나요? 혹시 아직 못 읽으신 분은 공지로 고정해두었으니 확인해주세요!

첫날은 공지드린대로 다짐 작성을 할겁니다. 준비하신 도서의 머리말, 서문 그리고 목차를 꼼꼼히 보고 앞으로의 계획을 세워보세요~

첫날은 특별 규정으로 결석 시 바로 탈락입니다! 그럼 다들 화이팅입니다~ 😊"
2023-04-24 09:34:53,"강민규","여러분 개근상은 1등이 여러명이면 여러명에게 드립니다"
2023-04-24 09:35:24,"강민규","모두가 매일 출석하시면 모두 상품을 받으실 수 있습니다"
2023-04-24 09:38:33,"리경","리경님이 들어왔습니다."
2023-04-24 09:38:33,"오픈채팅봇","책너두 3기 운영방에 오신 것을 환영합니다!

앞으로 여기서 독서 스케줄 공지, 리마인드, 독서 일지와 같은 각종 과제 제출 등이 이뤄집니다.

프로그램에 대한 상세 일정은 4월 23일 일요일에 공지드릴 예정입니다. 그 전까지는 신청하신 도서를 미리 준비해주세요.

9주 동안 서로 자극 받으며 성장하는 시간이 되길 기대합니다!"
2023-04-24 09:39:26,"강민규","안녕하세요 리경님 공지 읽어주세요! 오늘은 독서 다짐을 제출해주시면 되겠습니다!"
2023-04-24 09:43:06,"강민규","여러분 본인이 신청한 책과 함께 간단한 자기소개를 해주세요~"
2023-04-24 09:43:47,"강민규","저는 책너두 운영자 강민규입니다. 선릉역에서 3년차 개발자로 일하고 있습니다"
2023-04-24 09:49:32,"김연정","저는 컨설팅회사에서 컨설턴트로 근무하고있는 김연정이라고 합니다. 초전설득 신청했습니다! 반갑습니다 :)"
2023-04-24 09:51:15,"쏘이쏘이양","안녕하세요 패션IT 스타트업 마케팅팀에서 일하고 있습니다, 김소이라고 합니다! 
초전설득 신청했습니다 ㅎㅎ 끝까지 잘 부탁 드립니다!! "
2023-04-24 09:51:30,"쏘이쏘이양","오옷 같은 책이시네용! 반갑습니다 ㅎㅎ :)"
2023-04-24 12:10:19,"궈노","안녕하세요 성수역 근처에서 일하고있는 웹 개발자 권오정입니다.
신청도서는 헤드퍼스트 디자인패턴 입니다.
앞으로 잘부탁드립니다. 반갑습니다 (-:"
2023-04-24 12:30:46,"Hailey 박정현","안녕하세요 강남구청역 근처에서 일하는 웹 개발자 박정현입니다
<데이터 중심 어플리케이션 설계> 신청했습니다 잘 부탁드립니다! "
2023-04-24 12:31:12,"이찬영","안녕하세요.
웹개발자 이찬영입니다.
아직 부족한 점이 많아 헤드퍼스트 디자인패턴 책을 통해 성장하기 위해 선택했습니다.
잘 부탁드립니다~"
2023-04-24 12:35:54,"Bo","안녕하세요. 개발자로 일하고 있는 김보경입니다. <헤드퍼스트 디자인패턴> 을 신청했습니다. 잘 부탁드립니다! "
2023-04-24 12:36:46,"김용기","안녕하세요. 잠실에서 일하는 백엔드 개발자 김용기입니다. '도메인 주도 설계로 시작하는 마이크로 서비스 개발'을 신청했습니다. 잘 부탁드립니다."
2023-04-24 12:40:26,"김성태","안녕하세요 역삼역에 있는 IT b2b 회사에서 일하고 있는 백엔드 개발자 김성태라고 합니다. 
'헤드 퍼스트 디자인 패턴' 신청했습니다. 반갑습니다!"
2023-04-24 12:40:57,"김용기","@강민규 님. 도메인 주도 설계로~ 책 목표가 1주차에는 2~51page로 되어있는데 '이번주 독서 스케줄'에는 1주차가 138page 까지로 설정되어 있어서 확인부탁드립니다. "
2023-04-24 12:41:33,"강민규","그 전체 스케줄은 아직 보지않으시길 권합니다"
2023-04-24 12:42:57,"최다봄","안녕하세요. 선릉역에서 근처에서 일하고 있는 프론트엔드 개발자 최다봄 입니다. 헤드 퍼스트 디자인 패턴 신청했습니다. 잘부탁드립니다 !!"
2023-04-24 13:05:35,"리경","안녕하세요, 서초에서 일하는 백엔드 개발자 홍리경입니다. ‘오브젝트’ 신청했습니다. 반갑습니다 :)"
2023-04-24 13:06:03,"김형우","안녕하세요. 2년차 백엔드개발자 김형우라고 합니다. 도메인 주도 설계로 시작하는 마이크로 서비스 개발 책 신청했습미다. 잘 부탁드립니다!"
2023-04-24 13:11:49,"이소민","안녕하세요~
2년 동안 웹프론트 개발 하다가 서버 개발로 전향한지 만 1년이 조금 안 된 개발자 이소민 이라고 합니다.
헤드퍼스트 디자인패턴 신청했습니다
잘부탁드립니다~~~👏"
2023-04-24 13:19:20,"박소환","안녕하세요,
백엔드 개발자로 판교에서 근무한지 이제 곧 1년 되는 서버개발자 박소환입니다.
“도메인 주도 설계로 시작하는 마이크로 서비스 개발” 신청했습니다.
부족한게 많아 공부를 많이 해야하는데 혼자서는 의지가 안 생겨 신청하게 되었습니다.
잘 부탁드립니다 !"
2023-04-24 13:27:31,"최희윤","안녕하세요 백엔드 개발자 최희윤입니다.
도메인 주도 설계로 시작하는 마이크로 서비스 개발 신청했습니다.
개발 서적을 많이 읽어야하는 것은 알지만 여러 이유로 미루다가 좋은 그룹이 있다고 추천받아서 전 기수에서 많은 도움을 받았습니다.
이번에도 완주하면 좋겠습니다~!
잘 부탁드립니다^_^"
2023-04-24 13:45:56,"최윤지","안녕하세요. 반갑습니다. 저는 데이터분석 이직준비중이고 현재는 법무법인에서 법률사무원으로 일하고 있는 최윤지라고 합니다.  ‘7가지 코드’신청했습니다. 잘부탁드립니다~"
2023-04-24 13:52:13,"한종우","안녕하세요. 성수역 근처에서 신입으로 웹개발하고 있는 한종우입니다. 헤드 퍼스트 디자인 패턴 신청했습니다. 잘 부탁드립니다!"
2023-04-24 13:52:19,"송예은","안녕하세요. 은행원 송예은입니다.
도메인 주도 설계로 시작하는 마이크로 서비스 개발 책 신청했습니당 잘 부탁드립니다!"
2023-04-24 15:59:54,"수정","@강민규 님! 헤드퍼스트 디자인 패턴으로 책 변경해도 괜찮을까요?"
2023-04-24 16:56:18,"다운","안녕하세요. 작가 나다운 입니다.
‘사피엔스’ 신청했습니다.
잘부탁드립니다!"
2023-04-24 18:25:38,"이찬영","[월요일] 헤드퍼스트 디자인패턴

## 전반적인 내용

디자인 패턴을 잘 활용하면 단지 코드만 ‘재사용’하는 것이 아니라, 더 큰 그림을 그리기 위한 디자인도 재사용할 수 있다고 한다. 유지보수가 잘되는 코드를 만드려면 디자인 패턴을 잘 활용해야 한다.

이 책은 독자를 ‘학습자’라고 생각하여 어떻게 독자가 쉽게 정보를 습득해야할지 알고 여러 학습유형을 보여주고 있다. 그림과 대화체를 사용하고 연습문제까지 덧붙여 디자인 패턴에 대해 지루하지 않게 접근할 수 있게 한다.

이 책을 통해 유지보수가 쉬운 코드를 만들 수 있기를 기대해본다.

## 독서 전략

내용을 빠르게 훑되, 핵심내용은 놓치지 않기로 한다.

실무에서 잘 이용할 수 있도록 연습문제를 충분히 고민해보고 풀고 깃헙에 기록할 것이다.

## 다짐

유지보수가 쉬운 멋진 코드를 짤 수 있게 되길~!! 더 멋진 개발자가 되기위해!!!

그리고 일단 개근을 목표로 정진~!!"
2023-04-24 18:46:22,"뚯뚜오","이집트와 로마는 왜 찬란했던 영광의 시절을 회복하지 못하고 있을까요? 왜 중국 문명은 영미권에 밀리고 반지성주의의 상징이 되었을까요? 백제시대에 기술을 전수해 줄 정도로 먼저 발전했던 한국은 어쩌다 일본에 추월당하고 지배당하게 되었을까요? 

같은 저자의 ‘대변동 : 위기, 선택, 변화’라는 책을 먼저 접했는데, 총균쇠도 대변동 못지 않은 좋은 책이라 들었습니다.

고령화, 인공지능, 지정학적 불안정성 등 불확실성으로 가득한 미래를 앞두고 고민이 많은데, 과거를 반추해보고 앞으로 어떻게 할 지 고민해보고자 총균쇠를 선택하여 독서모임에 참여하게 되었습니다.

성실히 참여하도록 하겠습니다."
2023-04-24 18:48:47,"Bo","[월요일] 헤드퍼스트 디자인패턴
https://wealthy-background-f1f.notion.site/14799ead037645a190a1cc0e3c31757a"
2023-04-24 19:02:07,"강민규","총균쇠 읽으시는 분들 어떤 판으로 읽고계신가요?"
2023-04-24 19:02:18,"강민규","사진"
2023-04-24 19:02:58,"강민규","여러분 독서일지는 아래와 같은 양식으로 작성 부탁합니다

1일차

이집트와 로마는 왜 찬란했던 영광의 시절을 회복하지 못하고 있을까요? 왜 중국 문명은 영미권에 밀리고 반지성주의의 상징이 되었을까요? 백제시대에 기술을 전수해 줄 정도로 먼저 발전했던 한국은 어쩌다 일본에 추월당하고 지배당하게 되었을까요? 

같은 저자의 ‘대변동 : 위기, 선택, 변화’라는 책을 먼저 접했는데, 총균쇠도 대변동 못지 않은 좋은 책이라 들었습니다.

고령화, 인공지능, 지정학적 불안정성 등 불확실성으로 가득한 미래를 앞두고 고민이 많은데, 과거를 반추해보고 앞으로 어떻게 할 지 고민해보고자 총균쇠를 선택하여 독서모임에 참여하게 되었습니다.

성실히 참여하도록 하겠습니다."
2023-04-24 19:03:20,"강민규","반드시 가장 앞에 ~일차를 붙여주세요"
2023-04-24 19:03:48,"강민규","오늘이 1일차입니다"
2023-04-24 19:03:53,"뚯뚜오","아 네 알겠습니다."
2023-04-24 19:04:10,"뚯뚜오","전 2005년 좌측버전으로 읽고 있습니다."
2023-04-24 19:18:40,"강민규","넵 물론입니아"
2023-04-24 19:18:54,"강민규","헤드퍼스트는 다들 개정판이신가요?"
2023-04-24 19:29:34,"궈노","1일차

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_1_%EB%8B%A4%EC%A7%90.md"
2023-04-24 19:30:25,"이찬영","네"
2023-04-24 19:31:06,"이소민","네 개정판입니다~"
2023-04-24 19:33:24,"이찬영","1일차 

*수정 후 재업
 [월요일] 헤드퍼스트 디자인패턴

## 전반적인 내용

디자인 패턴을 잘 활용하면 단지 코드만 ‘재사용’하는 것이 아니라, 더 큰 그림을 그리기 위한 디자인도 재사용할 수 있다고 한다. 유지보수가 잘되는 코드를 만드려면 디자인 패턴을 잘 활용해야 한다.

이 책은 독자를 ‘학습자’라고 생각하여 어떻게 독자가 쉽게 정보를 습득해야할지 알고 여러 학습유형을 보여주고 있다. 그림과 대화체를 사용하고 연습문제까지 덧붙여 디자인 패턴에 대해 지루하지 않게 접근할 수 있게 한다.

이 책을 통해 유지보수가 쉬운 코드를 만들 수 있기를 기대해본다.

## 독서 전략

내용을 빠르게 훑되, 핵심내용은 놓치지 않기로 한다.

실무에서 잘 이용할 수 있도록 연습문제를 충분히 고민해보고 풀고 깃헙에 기록할 것이다.

## 다짐

유지보수가 쉬운 멋진 코드를 짤 수 있게 되길~!! 더 멋진 개발자가 되기위해!!!

그리고 일단 개근을 목표로 정진~!!
"
2023-04-24 19:37:10,"Bo","1일차
https://wealthy-background-f1f.notion.site/14799ead037645a190a1cc0e3c31757a
"
2023-04-24 19:39:40,"수정","네 개정판입니다!"
2023-04-24 19:55:14,"이소민","1일차 제출

[헤드퍼스트 디자인패턴]

📍전반적인 내용
수많은 GoF 디자인 패턴 중 핵심 패턴들(옵저버, 팩토리 등)에 대해 다룬다.
각 패턴의 정의와 특징들을 알려주고, 코드 예제를 통해 어떻게 사용해야 하는지 등의 주요 부분을 중점적으로 파헤친다.


📍독서 전략
책에서 말하는 것 처럼 이해를 통한 학습을 하자.
독서 후 개념을 잘 이해했는지 점검을 하고 실습을 통해 머리에 더욱 잘 남게 하자.
중간중간 메모도 열심히 하자.


📍다짐
꾸준히 할 수 있는 동기가 있음에 감사하며 열심히 해보자."
2023-04-24 20:10:30,"강민규","여러분 다들 퇴근하셨나요? 오늘 다짐 쓰는 것 잊지마세요~ 꼭이요! 첫날 어떤 마음으로 시작했는가에 따라 나중의 결과가 많이 차이가 납니다. 오늘 하루 잘 마무리하세요~ 

내일부터는 독서 시작입니다! 독서 스케줄은 현재 총균쇠 제외하고는 다 해두었구요~ 매일 아침 여덟시에 제가 공지 해드리니 기대해주세요"
2023-04-24 20:19:23,"송예은","1일차
- 전반적인 내용
DDD, MSA 전반을 다룬다. MSA를 하기 위해선 도메인 주도 설계가 선행되어야 한다. MSA를 잘 만들기 위한 전반적인 설계 방법을 다룬다.

- 독서 전략
이전 회사들에서 경험했던 모놀리식, 잘못된 MSA에 대해 반성해보고, 지금 회사에서 잘된 MSA를 보며 책을 깊이있게 이해해본다. 지금 구조에서의 문제점도 찾아본다.

- 다짐
더 나은 구조에 대해 항상 고민하는 개발자로 거듭나자"
2023-04-24 21:21:30,"최희윤","시작 전 다짐
https://charm-bearberry-5b7.notion.site/95d464fb964b4047b849eaa6ec3063b2"
2023-04-24 21:51:59,"강민규","1일차 앞에 붙여주세요"
2023-04-24 21:52:21,"최희윤","죄송합니다"
2023-04-24 21:52:45,"최희윤","1일차 (04/24)시작 전 다짐
https://charm-bearberry-5b7.notion.site/95d464fb964b4047b849eaa6ec3063b2"
2023-04-24 21:52:58,"김연정","앗 저도 시작 전 다짐이라고 쓰고있었는데ㅋㅋ 그냥 올릴뻔했네여~!"
2023-04-24 21:54:09,"강민규","아닙니다 ㅎㅎ 나중에 독서일지만 모아서 볼 수 있게 하려는데 앞에 ~일차가 붙어있어야해서 양해부탁드립니다!"
2023-04-24 21:59:20,"다운","1일차(4/24)

-전반적인 내용
호모 사피엔스를 이야기하는 동물로 보며 어떻게 사피엔스가 역사상 가장 치명적인 동물이 되었는지 사회, 생물, 종교 등으로 풀어 설명하는 책

-독서전략
인간의 전반적인 심리 구조 이해를 위해 전달하고자 하는 핵심 내용을 밑줄 긋고 노트에 따로 정리한다. 
a4 한장에 전체적인 내용과 간단한 예시를 정리한다

-다짐
사피엔스 뿐만 아니라 시간적 여유가 된다면 유발 하라리의 다른 작품( 호모데우스, 21세기를 위한 21가지 제언) 도 읽어보기

권위있는 책은 가급적 2회독 목표
"
2023-04-24 22:05:56,"김연정","1일차(4/24) 시작 전 다짐

- 전반적인 내용
인간이 왜 다른 사람들로부터 영향력을 받고, 왜 특정한 상황에서 특정한 행동을 하게 되는지에 대한 이론과 사례를 다뤘다. 사람들의 마음을 반드시 움직이게 하는 공식을 알려주는 책이다.

- 독서 전략
일단은 끝까지 꼭 완주하기
읽기만 하면 무용지물이라는 것을 명심하고 실제 생활에서 적용해볼 수 있는 부분은 표시한 뒤 고객사와 소통할 때 사용하기
5주차에 1~4주차 다시 훑어보고 복습하고 그 동안 책 속 내용을 적용한 적이 있는지 회고하기

- 다짐
마케팅, 영업 분야에서 유명한 책이라고 해서 항상 읽고 싶었던 책이었는데, 이런 저런 핑계로 계속 못 읽고 있다가 드디어 읽는다. 회사에 다니면서 누군가를 설득하는 일이 정말 많고, 나 자신을 홍보해야하는 경우가 많은데 부디 이 책을 읽고 성장해서 사람들의 마음을 움직일 수 있는 사람이 되고싶다."
2023-04-24 22:11:07,"강민규","@김성태 @리경 @수정 @Hailey 박정현 @김형우 @강세훈 @박소환 @최다봄 @호02 @쏘이쏘이양 @김용기 @최윤지 @한종우 @김연수 

원래 이틀 결석하면 이맘 때쯤 이렇게 멘션 해드립니다!
오늘은 첫날이라 특별히 아직 다짐 작성하지 않으신 분들 모두 태그드립니다~~

첫날은 특별 규정으로 결석 시 바로 탈락입니다! 그럼 다들 화이팅입니다!!"
2023-04-24 22:27:31,"김용기","스터디끝나고 바로 올릴게요~"
2023-04-24 22:30:19,"호02","[초전설득]
1일차(4/24) 시작 전 다짐

- 전반적인 내용
상대를 설득하기 위해서 언제, 어떻게 해야하는 지를 기술한 책
초전 설득에 대한 정의를 시작으로 유리한 순간을 포착하고, 주의를 이끌어내는 상황까지 설계하는 방법을 설명하고  있다.

- 독서 전략
완독을 목표로 하기보다면 목차를 보면서 지금 필요하다 싶은 부분부터 정독하기

- 다짐
회의를 하다보면 설득시키기 위한 상황이 발생하는 데 이 책을 통해서 이미지 트레이닝을 해보고 싶다."
2023-04-24 22:30:53,"강민규","호영님 제일 앞에 1일차를 붙여주시면 감사하겠습니다. 번거롭게 하여 죄송합니다"
2023-04-24 22:34:18,"강민규","나중에 독서일지만 모아서 볼 수 있게 하려고 하는데 메시지 분석할 때 앞에 ~일차가 붙어있어야 독서일지임을 확인할 수 있어 양해부탁드립니다!"
2023-04-24 22:34:58,"강민규","번거롭겠지만 수정 부탁합니다~"
2023-04-24 22:37:59,"한종우","1일차 (4/24)

[헤드퍼스트 디자인 패턴] 

## 전반적인 내용
그림과 예제 코드를 통해 다양한 디자인 패턴들에 대해 소개하고 있다. 각 챕터의 마지막에는 연습 문제를 통해 해당 챕터의 내용을 복습할 수 있도록 구성되어 있다.

## 독서 전략
내가 작성하는 코드에는 어떤 디자인 패턴이 적절할지 고민하면서 읽자. 디자인 패턴을 무작정 적용하려 하지 말고, 어떤 상황에서 왜 적용하면 좋을지 고민하면서 읽자.

## 다짐
끝까지 완독하자."
2023-04-24 22:53:42,"수정","# 1일차 (4/24)

### 전반적인 내용

- 여러가지 디자인 패턴에 대해 예시와 그림으로 쉽게 설명한다

### 독서 전략

- 프론트엔드 디자인패턴 책과 비교해 읽으면서, 어떤 부분들이 같고 다르게 나타날 수 있는지 확인한다
- 해당 패턴이 사용된 라이브러리나 프로젝트들을 찾아보고, 실제로 장단점이 어떻게 나타났는지 알아본다
- 각 챕터를 복습할때는 이해한 내용을 쉬운 말들로 정리해본다

### 다짐

- 미루지 말자
- 완독만 하자"
2023-04-24 23:00:36,"호02","1일차 (4/24) 

[초전설득]

시작 전 다짐

- 전반적인 내용
상대를 설득하기 위해서 언제, 어떻게 해야하는 지를 기술한 책
초전 설득에 대한 정의를 시작으로 유리한 순간을 포착하고, 주의를 이끌어내는 상황까지 설계하는 방법을 설명하고  있다.

- 독서 전략
완독을 목표로 하기보다면 목차를 보면서 지금 필요하다 싶은 부분부터 정독하기

- 다짐
회의를 하다보면 설득시키기 위한 상황이 발생하는 데 이 책을 통해서 이미지 트레이닝을 해보고 싶다."
2023-04-24 23:08:59,"최윤지","1일차(04/24) 

-전반적인 내용
pm은 한가지 분야에 전문가가 되기 보다는 다양한 분야에 전문적인 지식을 갖추어야 한다. 이 책은 pm이 체득해야 하는 7가지 세부적인 전문 분야와 각 분야와 관련된 실무사례를 엮어냈다. pm과 회사가 최종적으로 어떠한 상품을 기획하고 고민하는지 보고 데이터 분석시  분석에만 매몰되지 않고 어떠한 방향성을 잡아야 기획에 필요한 분석을 할 수 있을지 유념하며 읽어보려한다. 

-독서전략
면접, 실무에 활용할 수 있는 내용 밑줄
인상깊은 구절 밑줄 및 어떤 느낌을 받았는지, 생각 메모
이해가 안되는 부분 심화학습
새로운 아이디어 및 질문들 메모

-다짐
책의 내용을 훑기보다는 제대로 체화하여 내것으로 만들면 좋겠다.  올출석을 목표로 하루하루 꾸준히 읽고 독서전략에 따라 내용을 정리해야겠다. "
2023-04-24 23:16:47,"박소환","어..음.. 근데 궁금한게..
""전반적인 내용"", ""독서 전략"", ""다짐"" 을 쓰는 양식인가요 ??"
2023-04-24 23:17:16,"강민규","넵 맞습니다. 권장하는 양식이고 자유롭게 하셔도 됩니다!"
2023-04-24 23:19:52,"박소환","앗 넵 감사합니다!"
2023-04-24 23:20:03,"박소환","1일차 (04/24)
https://bleetoteelb.tistory.com/68"
2023-04-24 23:35:04,"Hailey 박정현","1일차(4/24) 시작 전 다짐

[전반적인 내용]
데이터 처리의 기본기를 다지기에 좋은 참고서다. 데이터 모델 설계, 질의 언어, 복제, 트랜잭션, 일괄처리, 스트림 처리 등 데이터 처리의 다양한 측면을 다루면서도 내용이 충실하고 이해하기 쉽게 쓰였다. 1부에서는 데이터 시스템의 기초를 다루고 2부에서는 복제와 파티셔닝 등 분산 환경에서 쓰이는 데이터 처리 기술을 다룬다. 3부에서는 일괄 처리와 스트림 처리를 설명한 후 미래의 데이터 시스템은 어떠해야 하는지에 관한 저자의 의견을 제시한다. 빠른 시간 내에 읽기 쉽지 않은 분량이지만 차근차근 읽어나가면 데이터 기술을 잘 이해하고 데이터 시스템을 구축하는 데 큰 도움이 될 것이다.
- 역자 서문 중

[독서 전략]
- 읽다가 모르는 용어나 개념이 나오는데 시간이 부족할 경우 일단 메모해둔다.
- 업무와 연관되는 포인트들도 따로 메모해둔다.
- 하루에 10~20페이지 내외이므로, 쉬운 부분과 어려운 부분이 고루 분배되어 있지 않을 수 있다. 쉬운 내용이 많은 파트일 경우 미리 다음 분량을 읽어두거나 이전 파트에서 메모해 둔 내용을 따로 조금 더 공부한다. 


- 다짐
미루지 않고 완독한다."
2023-04-24 23:43:52,"최다봄","1일차 (04/24) 시작 전 다짐

## 전반적인 내용

[목차]
1. 디자인 패턴 소개와 전략 패턴 - 디자인 패턴의 세계로 떠나기
2. 옵저버 패턴 - 객체들에게 연락 돌리기
3. 데코레이터 패턴 - 객체 꾸미기
4. 팩토리 패턴 - 객체지향 빵 굽기
5. 싱글턴 패턴 - 하나뿐인 특별한 객체 만들기
6. 커맨드 패턴 - 호출 캡슐화 하기
7. 어댑터 패턴과 퍼사드 패턴 - 적응시키기
8. 템플릿 메소드 패턴 - 알고리즘 캡슐화하기
9. 반복자 패턴과 컴포지트 패턴 - 컬렉션 잘 관리하기
10. 상태 패턴 - 객체의 상태 바꾸기
11. 프록시 패턴 - 객체 접근 제어하기
12. 복합 패턴 - 패턴을 모아 패턴 만들기
13. 실전 디자인 패턴 - 패턴과 행복하게 살아가기
14. 기타 패턴 - 다양한 패턴 빠르게 알아보기

헤드 퍼스트 디자인 패턴에서는 14가지 GoF 디자인 패턴과 9가지 디자인 원칙을 담고 있다. 
그 책의 전반적인 내용을 확인하기 위해선 목차를 훑고 파악해본다. 각 예제와 연습문제를 통해 디자인 패턴을 익히는 과정을 반복한다. 

## 독서 전략

- 시간 내에 집중해서 읽은 이후, 전반적인 내용과 핵심을 요약정리한다.
- 구조를 생각해야할 때, 어떻게 적용할 수 있는지 생각하는 시간을 가져본다.
- 연습문제는 꼭 풀라고 하기에 꼭 푼다.
- 시간을 더 투자할 수 있을 때, typescript로 디자인패턴을 적용해본다.

## 다짐

- 더 깔끔하고 효율적인 코드를 작성하기 위한 밑거름 만들기.
    - 옮긴이의 말
    - 상황에 따라 적절한 도구를 사용하는 건 정말 중요한 능력입니다.
    - 디자인 패턴을 활용하면 단지 코드만 ‘재사용’하는 것이 아니라, 더 큰 그림을 그리기 위한 디자인도 재사용할 수 있습니다.
    - 디자인 패턴이 만병통치약은 아닙니다.
- 설명해보기.
- 완독하기.
- 아자!"
2023-04-24 23:50:57,"김성태","- 1일차(4/24) 시작 전 다짐

### 전반적인 내용

- 다양한 디자인 패턴과 객체지향에 대해서 코드로 설명하기 보다는 알기 쉽게 그림과 대화체를 사용해서 친근하게 설명함

### 독서 전략

- 각 패턴을 익히면서 현재 사용하고 있는 프로젝트의 코드에 어떻게 적용되어 있는지 살펴본다.
- 각 챕터별 퀴즈를 풀어본다.

### 다짐

- 디자인 패턴에 대해 익혀서 프로젝트에 적용시켜보자
- 완독하기
- 완독보다 중요한 건 한 챕터를 보더라도 제대로 이해하고 넘어가는 것"
2023-04-25 00:07:26,"강민규","— 출첵 완료 --"
2023-04-25 00:09:54,"강민규","출첵 끝났다는 의미가 아니라 아침에 일어나서 제출 했는지 안했는지 확인할 인원을 적어두고 내일 아침에 다시 확인하려고 마킹해두는거니 걱정하지않으셔도 됩니다요~"
2023-04-25 00:17:39,"김용기","1일차 (04/24)

[전반적인 내용]

- 마이크로 서비스 아키텍처의 개념과 패턴
- 도메인 주도 설계(DDD)를 마이크로 서비스에 접목하는 방법
- 이벤트 스토밍을 통한 마이크로 서비스 설계
- 예제로 보는 마이크로 서비스
- 마이크로 서비스에서 활용되는 CI/CD

[독서 전략]

- 왜 마이크로 서비스인가?
- 실례를 중심으로
- 마이크로 서비스를 구성할 때 고려해야하는 것은 무엇인가?
- 한 마이크로 서비스가 담당하는 것은 어디까지인가?
- 모놀리식 서버에서 마이크로 서비스로 이관하기 위해서는 어떻게 해야하나?
- 성숙한 마이크로 서비스 아키텍쳐란 무엇인가?
- 주로 사용되는 툴과 패턴은 어떤 것인가?

[다짐]

- 현재 회사에서 구성되어있는 마이크로서비스가 어떠한 관점에서 이루어졌는지 파악하자.
- 새로 마이크로 서비스를 구성한다면 지켜야할 원칙이 어떤 것이 있는지 생각하자."
2023-04-25 00:32:27,"김형우","[1일차]
https://engineer-diary.tistory.com/189"
2023-04-25 01:24:06,"리경","1일차 (4/24)

오브젝트

- 전반적인 내용

*  역할, 책임, 협력에 기반해 객체지향 프로그램을 설계하고 구현하는 방법
* 응집도와 결합도를 이용해 설계를 트레이드오프하는 방법
* 설계를 유연하게 만드는 다양한 의존성 관리 기법
* 타입 계층을 위한 상속과 코드 재사용을 위한 합성의 개념
* 다양한 설계 원칙과 디자인 패턴

- 독서 전략

의문 해결하기
* 왜 객체지향이어야 하는가
* 클래스에 초점을 맞추지 않고 역할, 책임, 협력의 관계로 표현할 수 있는가
* 응집도와 결합도, 캡슐화로 설계를 개선할 수 있는가

- 다짐

* 완독하기
* 각 장을 코드로 이해하고, 프로젝트에 적용해 생각해보기 
"
2023-04-25 02:48:49,"김연수","다음에 책 선정을 다시해서 참여하도록 하겠습니당 ㅜ "
2023-04-25 02:48:56,"김연수","김연수님이 나갔습니다."
2023-04-25 05:47:30,"강세훈","저도 다시 참여하도록 하겠습니다!"
2023-04-25 05:47:45,"강세훈","강세훈님이 나갔습니다."
2023-04-25 05:47:48,"쏘이쏘이양","초전설득 1일차: 독서 전략을 고민해보는 시간/ 서문과 목차 읽기

[전반적인 내용]
    - 정통한 의사 전달자들이 자신의 메시지를 전달하고 그것을 납득시키기에 앞서 하는 활동들과 날카로운 타이밍의 본질에 대해 다루는, 일상생활에서 멀리 계획하거나 바로 적용 가능한 행동과학 정보

[독서전략]
    - 완벽히 다 이해하려 하기보다는 여러번 읽을 여유 있는 태도로 읽자
    - 필요하지 않다고 느껴지는 부분은 과감히 스킵하자(다음 기회에 읽으면 된다는 마음)

[다짐]
    - 완독
    - 회사에서 한번이라도 써보자
"
2023-04-25 05:49:04,"쏘이쏘이양","쓰다가 잠들어버려서 깨자마자 부랴부랴 올립니다ㅠ"
2023-04-25 07:42:23,"강민규","다들 잘 작성해주셨군오 오늘부터 함께 해봅시다~"
2023-04-25 07:42:31,"강민규","사진"
2023-04-25 07:43:25,"강민규","2일차 
헤드퍼스트
...
...

위와같이 작성 부탁합니다~"
2023-04-25 10:06:54,"Bo","2일차
헤드퍼스트 
https://wealthy-background-f1f.notion.site/09bc3bfce45842748da172dd328a2917"
2023-04-25 10:54:33,"송예은","2일차
도메인MSA

# 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

클라우드 환경의 등장과 이를 잘 활용한 기업들은 성공했다. 클라우드 환경이 그것을 어떻게 촉진했는지 보자.

## 1.1.1 성공 사례: 아마존의 배포 속도

빠른 배포 주기는 비즈니스의 민첩성을 간접적으로 보여주는 지표다.

아마존은 초당 1.5번의 배포를 한다. (2019년 기준) 

어떻게 이런 속도를 갖게 되었을지 시스템을 구성하는 인프라와 애플리케이션 측면에서 살펴보자.

## 1.1.2 클라우드 인프라의 등장

- 전형적인 시스템 인프라 구축 과정은 시간, 금전, 관리 비용이 많이 든다.
    
    서비스가 실패한다면 초기 투자 비용도 건질 수 없다.
    
- 클라우드 인프라의 등장으로 이런 문제가 해결되었다.

## 1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건

- 클라우드 인프라를 사용하면 사용량에 따라 비용을 유연하게 조정할 수 있다.
- 클라우드는 여러 개의 서버 장비가 모여 논리적으로 하나처럼 관리된다. 레고처럼 조각이 모여 하나의 큰 덩어리가 되고 쉽게 분리되기도 한다.
    
    애플리케이션도 이런 형태라면 효율성을 극대화할 수 있다. 애플리케이션 블록이 작으면 작을수록 효율적이다.
    
- 사용량 증가에 따른 인프라 용량 성능과 가용성을 높이는 일반적인 방법
    
    ### 스케일 업과 스케일 아웃
    
    쇼핑몰 타임세일로 특정 기간에 트래픽이 밀려온다면 스케일업이나 스케일 아웃을 고려할 수 있다.
    
    - 스케일 업
        
        아무리 스케일 업해도 예상 트래픽을 초과하면 시스템이 다운될 수 있다.
        
    - 스케일 아웃
        
        한계 수치에 달하면 인스턴스를 복제해서 증가시키고, 사용량이 분산된다.
        
    
    ### 특정 서비스만 탄력성 있게 확장 (스케일 아웃)
    
    세일 기간 중 바쁜 업무는 세일 이벤트를 수행하는 부분이므로, 스케일 아웃 시, 전체를 복제할 필요가 없다. 세일 이벤트를 담당하는 조각만 용량이 증설되고 복제되어 트래픽에 대비하면 된다.
    
    시스템을 작은 단위의 독립적인 서비스 연계로 구성해야 한다.
    
    ### 클라우드 프렌들리와 클라우드 네이티브
    
    - 클라우드 프렌들리
        
        큰 한덩어리도 클라우드 인프라에 올릴 수는 있다. 하지만 특정 기능만 확장하거나 배포할 수 없는 비효율은 감수해야 한다.
        
    - 클라우드 네이티브
        
        독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션
        
    
    궁극적으로 클라우드 프렌들리 → 클라우드 네이티브가 되어야 한다.
    

# 1.2 마이크로서비스란 무엇인가?

## 1.2.1 모노리스와 마이크로서비스 비교

- 모노리스는 하나의 단위로 개발되는 일체식 애플리케이션이다.
    
    서버 측 애플리케이션이 논리적인 단일체로서 아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야 한다.
    
- 스케일 아웃되면 큰 덩어리가 복제되어 여러 개가 뜬다. 변경이 발생하면 여러 개의 모노리스가 수평으로 확장된 상태이므로 여러 개의 모노리스 시스템 전부를 다시 빌드하고 배포해야 한다.
    
    데이터베이스는 하나이므로 스케일 업을 통해 용량을 증설해야 한다.
    
- 마이크로서비스는 여러 서비스 인스턴스가 모여 하나의 비즈니스 애플리케이션을 구성한다.
    
    각기 저장소가 다르므로 업무 단위로 모듈 경계가 명확하게 구분된다.
    
    확장 시에는 특정 기능별로 독립적으로 확장할 수 있고, 특정 서비스를 변경할 필요가 있다면 해당 서비스만 빌드해서 배포하면 된다.
    

## 1.2.2 SOA와 마이크로서비스

- 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 `폴리글랏하다`라고 표현한다.
- SOA는 애플리케이션은 모듈별로 분리했지만 저장소까지는 분리하지 못했다.
- MSA는 SOA에는 없던 두 가지 개념으로 모듈화 방식을 강화했고 실현한다.
    1. 서비스별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화한다. 즉, 다른 서비스의 저장소에 접근하는 수단은 API밖에 없다.
    2. REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다."
2023-04-25 17:53:00,"궈노","2일차
헤드퍼스트
https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_2_26-40.md"
2023-04-25 18:52:53,"이찬영","삭제된 메시지입니다."
2023-04-25 18:54:35,"이찬영","2일차
헤드퍼스트 디자인패턴

# 요약

1. 책 읽는 방법과 책의 구성
    - 연습문제를 신중하고 고민해서 풀어본다.
    - 기억되기 쉽도록 그림이 많다.
    - 사적인 대화체를 사용하여 접근하기 쉽게함.
    - <무엇이든 물어보세요> 부분이 핵심이다.
    - 직접 디자인해본다. 기존 프로젝트를 리팩토링 해보거나, 연습문제를 활용하거나.
    - 참고서X, 학습서O
    - 처음부터 순서대로 읽어야 한다.
    
2. 책을 읽기 전 알아두어야 할 것
    - 오리지널 GoF 패턴 중 몇 가지 핵심 패턴만 다룬다.
    - 패턴을 언제, 어떻게 사용해야 할지 확실히 알 수 있다.
    - 이 책에서 말하는 ‘구성’의 뜻 : composition, 일반적인 객체지향 언어에서 쓰이는 의미.

---

**CHAPTER 01. 디자인 패턴의 세계로 떠나기. (디자인 패턴 소개와 전략 패턴)**

- 타 개발자의 경험을 통한 디자인 패턴의 활용분야
    - 오리시뮬레이션 게임, SimUduck
        - 상속을 이용했을 때의 단점알기

# 발췌

💡 슈퍼클래스에 fly() 메소드를 넣은 결과, 날아다니면 안 되는 오리에게도 날아다니는 기능이 추가됐습니다.


# 메모

타 개발자의 경험이 평소 내가 하는 코드짜기라서 굉장히 반성하게되었다.."
2023-04-25 19:56:15,"김연정","삭제된 메시지입니다."
2023-04-25 20:36:03,"김연정","2일차
초전설득

요약

최고성과자는 설득 계획에 많은 시간과 노력 할애
메시지 전하기 전 공감 먼저 유도
순간적인 주의집중이 심리를 바꾼다.큰숫자 던지기, 배경음악, 선의 길이 등 직접적인 홍보보다 무언가를 통해 특정 행동이나 심리를 연상시킬 수 있다.
좋은 영업사원 예시: 고객의 집을 방문 할 때 실수한 척 물건 두고왔다고 열쇠받아 나갔다 들어오기, 신뢰하는 사람에게 하는 특징적인 행동 유도

메모

포지션에 따라 특징적인 행동을 유도할 수 있다.
친구같이 친근한 관계가 되고싶을 때->사적인 이야기나 고민 상담
"
2023-04-25 20:36:25,"김연정","ㅎㅎ..1일차로 잘못올려서 다시 올렸습ㄴ다"
2023-04-25 20:39:34,"강민규","여러분 다들 퇴근하셨나요? 오늘은 독서 첫날인만큼 결석하지않도록 해봅시다. 화이팅입니다~"
2023-04-25 20:39:44,"강민규","(참고)💡독서일지 작성 팁입니다.

1. 요약은 짧게 작성하세요.
2. 가장 중요한 부분만 발췌하세요.
3. 메모는 톡방에서 적극적으로 공유하세요.

요약 작성 시, 당일 독서 분량의 핵심을 간결하게 요약하고, 모든 내용을 다 적으려 하지 마세요. 요약을 너무 길게 쓰면 시간이 많이 들고 내용에 대한 소화를 충분하지 못할 수 있습니다. 

책에서 가장 중요한 부분을 인용하면 해당 부분의 중요성을 파악하는 데 도움이 됩니다. 발췌한 것을 완독 후에 빠르게 읽으면 복습에 큰 효과가 있습니다.

메모에는 독서 중 떠올랐던 아이디어나 주제, 이해하지 못한 내용에 대해 작성하고 공유하세요. 활발한 소통으로 책너두 동료들의 성장을 도와주세요. "
2023-04-25 20:52:59,"이소민","2일차 제출

[헤드퍼스트 디자인패턴]

📍요약
이 책의 독자는 학습자 이다.
단순히 독서를 하는 것이 아닌 책에 나오는 지식을 습득해야 한다.
그렇기 때문에 책을 읽으면서 깊게 생각하고, 직접 실습해보고, 꾸준한 메모를 하는 등의 방법으로 학습 효율을 높여야 한다.

📍발췌
“천천히 하세요. 더 많이 이해할수록 외워야 할 양은 줄어듭니다.”

📍메모
공부를 하는 방법은 사람마다 모두 다르다. 
하지만 이 책을 읽는 동안은 저자가 제안한 학습 방법대로 차근차근 따라가볼 생각이다.
왜인지 저자의 학습 방법에 대한 믿음이 생긴다."
2023-04-25 20:59:39,"한종우","2일차
[헤드퍼스트 디자인 패턴]

## 요약
- 이 책에서는 오리지널 GoF 중 몇가지 핵심 패턴만을 다루고 확실하게 이해할 수 있도록 한다
- 연습문제는 눈으로만 보지 말고 꼭 풀자
- 예제 코드는 최소한으로만 구성되어 있다
- 똑같은 문제를 해결했던 경험을 배우고 어떻게 활용할 수 있을지 배우자
- 여러가지 디자인 패턴이 어떤 식으로 동작하는지 배우자

### 오리 시뮬레이션 게임
- 오리가 날아야 한다는 결정
- Duck 클래스에 fly() 메소드만 추가하면 모든 오리가 그걸 상속받겠지

## 발췌
- 코드를 재사용한다는 점에서 상속을 기가 막히게 활용했다고 생각했는데 유지보수를 생각하면 별로 안좋아보이네요"
2023-04-25 21:52:18,"호02","2일차 제출

[초전 설득]

1. 요약
 - 초전 설득이란 본격적인 설득에 앞서 물밑 작업을 하는 것.
 - 상대방이 이미지를 자연스레 연상 시킬 수 있도록 하기 위함.
 - 책에서 나온 사례로는 상대방의 집 키를 받아 허락을 받지 않고 집 안으로 들어올 수 있는 상황을 만들어 냄으로써 신뢰받는 사람이라는 이미지를 자연스레 심어줌.
 
2. 메모
 - 상대방을 설득시키는 과정에서 내 이득을 위함이 드러나는 상황을 거부감없이 받아들이게 하는 것은 상당한 고민과 시간이 필요할 거 같다."
2023-04-25 22:25:52,"김용기","2일차
도메인MSA
# 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

- 성공한 서비스들의 공통점은 비즈니스 민첩성이다.

## 1.1 성공 사례 : 아마존의 배포 속도

- 빠른 배포주기는 비즈니스 민첩성을 간접적으로 보여주는 지표이다.

### 1.1.2 클라우드 인프라의 등장

- 클라우드 인프라의 등장으로 서비스 개발에 필요한 시스템 인프라를 준비하는 데 오랜 시간이 들지 않는다.

### 1.1.13 클라우드 인프라에 어울리는 애플리케이션의 조건

- 클라우드 인프라를 사용하면 사용량에 따라 비용을 유연하게 조정할 수 있다.
- 애플리케이션이 탑재되느 클라우드 인프라는 사용한 단위 만큼만 비용을 지불하므로 애플리케이션 블록이 작으면 작을수록 효율적이다.
- 서비스 비용을 유연하게 관리할 수 있다.

### 스케일 업과 스케일 아웃

- 스케일 업은 기존 시스템 자체의 물리적 용량을 증가시켜 성능을 높이는 방법
- 스카일 아웃은 기존 시스템과 용량이 같은 다수의 장비를 병행 추가해서 가용성을 높이는 방법

### 특정 서비스만 탈력성 있게 확장 (스케일 아웃)

- 시스테을 작은 단위의 독럽적인 서비스 연계로 구성해야 한다.

### 클라우드 프렌들리와 클라우드 네이티브

- 모놀리식 서버로 운용한다면 특정 기능만 확장하거나 배포할 수 없는 비효율을 감수해야 한다.
- 독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션을 클라우드 인프라에 가장 어울리고 효과적이라는 의미로 클라우드 네이티브 애플리케이션이라 부른다.
- 시스템이 비즈니스 민첩성을 잘 지원하기 위해서는 칼루읃 인프라를 효율적으로 활용하도록 애플리케이션 조각으로 구성된 클라우드 네이티브 애플리케이션이 가장 효과적이다.

# 1.2 마이크로 서비스란 무엇인가?

## 1.2.1 모노리스와 마이크로서비스 비교

- 마이크로서비스는 여러 서비스 인스턴스가 모여 하나의 비즈니스 애플리케이션을 구성한다. 업무 단위로 모듈 경계가 명확히 구분된다.

## 1.2.2 SOA와 마이크로서비스

- 마이크로서비스는 각 서비스와 저장소는 다른 서비스 및 저장소와 격리되어있다.
- API를 통해서만 느슨하게 연계된다.
- 독립적으로 확장 가능하고 하나의 서비스만 독립적으로 배포 가능하다.
- 내부의 언어나 저장소를자율적으로 선택할 수 있다."
2023-04-25 22:37:49,"수정","2일차
[헤드퍼스트 디자인 패턴]

# 요약
- 이 책의 목적: 독자가 책의 내용을 최대한 많이 기억하고 학습하도록 하기
- 책에서 공부한 내용을 오래 기억하려면?
    - 대화체를 사용한다
    - 더 깊이 생각하도록 한다
    - 여러 가지 감각을 섞어서 사용한다
    - 잠들기 전에 본다
- 오리 클래스 사례
    - 슈퍼 클래스에 fly()메서드를 추가해 모든 오리가 날게 됨 → 오류

# 발췌
- 디자인 패턴은 코드가 아닌 경험을 재사용하는 것"
2023-04-25 22:58:25,"리경","2일차
오브젝트

✨ 요약
- 프로그래밍 패러다임은 개발자 공동체가 동일 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 오해와 충돌을 제거한다.
- 프로그래밍 패러다임은 발전적이다

01) 객체, 설계

- 소프트웨어 개발에서 실무가 이론보다 앞서 있는 대표적인 분야로 ‘소프트웨어 설계’와 ‘소프트웨어 유지보수’를 들 수 있다. 
- 설계를 설명시 가장 유용한 도구는 코드 그 자체다

Ex. 티켓 판매 애플리케이션

✨ 메모
ex. 알약 어플 

Client 객체 여러개와 관리 Server 하나 연결시, 
Client 객체 하나는 ip, 상위 파일, 연결여부라는 상태를 가지고 있음.
Server는 연결된 클라이언트 리스트, 연결시 추가 함수, 끊길시 삭제 함수 갖고 있음."
2023-04-25 23:38:12,"최윤지","2일차
[7가지 코드]

https://quiet-jade-e60.notion.site/2-0425-d89d813bf1794d2aad0e93aab22ce6d7"
2023-04-25 23:45:34,"최다봄"," 2일차 
[헤드 퍼스트 디자인 패턴]

- 요약
CHAPTER 00: 들어가며 - 이 책을 읽는 방법
- 누구를 위한 책인지 설명
- 머리가 먼저 반응하는 학습법
   - 느린 방법은 반복하는 것.
   - 빠른 방법은 서로 다른 유형의 두뇌활동을 증가시키는 것.
   - 빠른 방법의 예시는 단어와 그림 사이의 관계 이해   
- 책의 구성
   - 단어  + 그림 + a(대화체, 연습 문제, 도전 의식 등)
- 두뇌 정복하는 방법 9가지
    
CHAPTER 01 디자인 패턴 소개와 전략 패턴 - 디자인 패턴 세계로 떠나기    
- 오리 시뮬레이션 게임      
   - 오리를 날 수 있도록 해야함 ⇒ Duck 클래스에 fly() 메소드 추가
   - 문제: 날 수 없는 서브 클래스들도 fly() 메소드 상속받음

- 발췌
슈퍼클래스에 fly() 메소드를 넣은 결과, 날아다니면 안 되는 오리에게도 날아다니는 기능이 추가됐습니다.

- 메모
“코드를 재사용한다는 점에서 상속을 기가 막히게 활용했다고 생각했는데 유지보수를 생각하면 별로 안 좋아보이네요.” - 고려한다고 생각하지만, 그래도 계속 생각해보기."
2023-04-25 23:59:54,"박소환","2일차
도메인 주도 설계로 시작하는 마이크로서비스 개발
https://bleetoteelb.tistory.com/69

오늘의 3줄 요약
- 기업 성공에 비즈니스 민첩성(Agility)는 중요하다
- 애플리케이션은 궁극적으로 Cloud friendly 에서 Cloud Native로 전이해야 한다.
- 특정 서비스를 구축하는데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 가리켜 'Ployglot하다""라고 표현한다. "
2023-04-26 00:44:06,"Hailey 박정현","2일차 [데이터 중심 애플리케이션 설계]
https://www.notion.so/haileypark/2-3c0b8df474804dac9def3a0baea7e8b0?pvs=4"
2023-04-26 01:41:52,"최희윤","2일차 도메인 주도 설계로 시작하는 마이크로서비스 개발
https://charm-bearberry-5b7.notion.site/04-25-DDD-2-bf009b2b81504f3a81f40e8ed5452be8"
2023-04-26 01:53:25,"뚯뚜오","2일차

총균쇠

요약

저자의 문명의 발전 차이를 연구하게 된 배경

유라시아가 문명발전의 주도권을 쥐게 된 아주 간략한 설명

주변 환경과 우리가 속한 문명의 발전단계가 우리에게 얼마나 큰 영향을 미치는지 ex) 키위 원주민도 미국에서 태어났으면 앱개발 한다. 나도 폴리네시아 파푸아뉴기니에서 태어났으면 사탕수수 베고 뗀석기 만들고있다.

발췌

당신네 백인들은 그렇게 많은 화물들을 발전시켜 뉴기니까지 가져왔는데 어째서 우리 흑인들은 그런 화물들을 만들지 못한 겁니까?"
2023-04-26 02:05:00,"김성태","2일차
[헤드 퍼스트 디자인 패턴]

### 요약

**Chapter 00 이 책을 읽는 방법**

- 학습자가 지루하지 않고 재미있게 배울 수 있도록 그림, 대화체를 사용하고 유머와 예시 및 연습문제 등을 통해서 책을 구성했다.

**Chapter 01 디자인 패턴의 세계로 떠나기**

- 오리 시뮬레이션 게임 예시를 통해 상속에 대해 알려준다.
- Duck()을 super class로 만든 다음, MallardDuck(), RedheadDuck() 등의 sub class들을 만든다
- RubberDuck()은 fly(), quack()을 다르게 만들어야 하므로 메소드를 변경하거나 override 한다
- → Duck의 행동을 상속을 했을 때 단점이 될 수 있는 요소
    - sub class에서 코드가 중복된다
    - 실행 시에 특징을 바꾸기 힘들다
    - 모든 오리의 행동을 알기 힘들다
    - 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.

### 발췌

p37. 

- 누군가가 이미 여러분의 문제를 해결해 놓았습니다.
- 1장에서는 다른 개발자가 여러분과 똑같은 문제를 경험하고 해결하면서 익혔던 지혜와 교훈을 살펴보고, 그것을 어떻게 활용할 수 있는지를 배웁니다.
- 패턴을 잘 사용하려면 패턴을 머릿속에 집어넣은 다음 애플리케이션에 어떻게 적용할지를 파악해야 합니다."
2023-04-26 02:12:24,"김형우","[2일차]
https://engineer-diary.tistory.com/190"
2023-04-26 04:59:46,"쏘이쏘이양","2일차
초전설득

#요약
가장 뛰어난 설득 전문가들은 설득을 시작하는 그 순간의 심리적 프레임이 설득하려는 내용만큼 중요하거나, 혹은 더 중요할 수 있다는 점을 간파하고 있었다. 가장 먼저 무엇을 말하고 보여주느냐에 따라 상대방이 그 다음 내용을 어떻게 받아들일지가 결정된다는 것이다. "
2023-04-26 07:28:40,"다운","2일차

[사피엔스]

-요약
역사의 진로를 형성한 것은 인지혁명, 농업혁명, 과학혁명이다.
선사시대 인류는 침팬치, 코끼리 등과 같이 주변환경에 별 영향을 미치지 못하는 종이었다. 
같은 ‘종' 은 교배하여 번식 가능한 후손을 낳으면 된다. 같은 조상에서 진화한 다른 종을 묶어서 ’속‘ 이라고 부르고 속의 상위에 있는것이 '과'다.
인간은 단일종이 아닌 호모 네안데르탈렌시스 등 최소 6개의 종이 있었지만 현재 존재하는건 호모 사피엔스 뿐이다.

-발췌
우리는 거대 영장류라는 크고 유달리 시끄러운 과의 한 일원이다. ( 영장류 ’과‘ - 호모’속‘ - 호모사피엔스)
"
2023-04-26 07:43:22,"강민규","밤 중에 다들 애써주셨군요~ 이런 템포로 첫주차 끝까지 달려보아요"
2023-04-26 07:44:17,"강민규","사진"
2023-04-26 08:24:35,"김연정","3일처
초전설득

요약
설득에서 보편적이고 공통적인 원칙 6가지: 상호성 사회적 증거 권위 희소성 일관성(설득의심리학 책 참고)
특권의 순간(초전 설득으로 다른 사람의 반응을 바꿀 수 있는 일시적인 기회)이 있다. 타이밍이 중요. (지금 술취해있고 퇴사를 고민 중인 자에게 파업을 주도해달라는 부탁을 한다면, 굿타이밍)


메모

없음"
2023-04-26 10:50:50,"송예은","3일차
도메인MSA

# 1.3 마이크로 서비스를 위한 조건은 무엇인가?

## 1.3.1 조직의 변화: 업무 기능 중심 팀

- 시스템을 개발할 때 항상 시스템의 모양이 팀의 의사소통 구조를 반영한다.
- 예전에 일하는 방식은 기술별로 팀이 나눠져 있고, 하나의 애플리케이션을 만들려면 팀간의 의사소통이 필요하다.
- 마이크로서비스를 만드는 팀은 업무 기능 중심의 팀이어야 한다.
    
    이는 자율적으로 담당 비즈니스에 관련된 서비스를 만들뿐 아니라 개발 이후에 운영할 책임까지 진다.
    

## 1.3.2 관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏

- 마이크로서비스를 만드는 조직은 중앙의 강력한 거버넌스를 추구하지 않는다.
- 각 서비스 팀이 팀에 맞는 개발 언어 및 저장소를 선택하는 것을 각각 폴리글랏 프로그래밍, 폴리글랏 저장소라고 한다.

## 1.3.3 개발 생명주기의 변화: 프로젝트가 아니라 제품 중심으로

- 기존에는 개발 조직과 운영 조직이 분리돼 있고, 초기에 모든 일정을 계획했다.
- 마이크로서비스팀의 개발은 소프트웨어 전체 생명주기를 책임져야 한다. 즉, 소프트웨어를 완성해야 할 기능의 집합으로 보는 것이 아니라 비즈니스를 제공하는 제품으로 바라본다.
    
    제품 중심의 애자일 개발 방식을 채택한다.
    
    마이크로서비스는 계속 피드백을 받아 지속적으로 변화, 개선되고 향상되는 존재다.
    

## 1.3.4 개발 환경의 변화: 인프라 자동화

- 마이크로서비스는 독립적으로 배포되므로, 이렇게 여러 개로 쪼개진 상태에서는 수동으로 배포하는 방식은 바람직하지 않다. 이를 빠르게 배포하기 위한 자동화된 방법이 필요하다.
- 빌드/배포 파이프라인은 일반적으로 소스코드 빌드 → 개발환경 배포 → 스테이징 환경 배포 → 운영 환경 배포 로 구성된다.
    
    이를 효율적으로 관리하기 위해 인프라 구성과 자동화를 마치 소프트웨어처럼 코드로 처리하는 방식인 Infrastructure as code가 각광받고 있다.
    

## 1.3.5 저장소의 변화: 통합 저장소가 아닌 분권 데이터 관리

- 폴리글랏 저장소 접근법에서는 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다.
    
    여기서 각 마이크로서비스의 저장소에 담긴 데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제가 있다.
    
- 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다.
    
    이를 결과적 일관성이라고 표현하기도 한다. 여러 트랜잭션을 하나로 묶지 않고 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다."
2023-04-26 11:26:57,"Hailey 박정현","3일차 [데이터 중심 애플리케이션 설계]
https://www.notion.so/haileypark/3-7626015b29da48408444a4d15baff154?pvs=4"
2023-04-26 11:45:06,"김연정","3일차
초전설득

요약
설득에서 보편적이고 공통적인 원칙 6가지: 상호성 사회적 증거 권위 희소성 일관성(설득의심리학 책 참고)
특권의 순간(초전 설득으로 다른 사람의 반응을 바꿀 수 있는 일시적인 기회)이 있다. 타이밍이 중요. (지금 술취해있고 퇴사를 고민 중인 자에게 파업을 주도해달라는 부탁을 한다면, 굿타이밍)


메모
"
2023-04-26 12:26:02,"김연정","2장 유리한 순간을 포착하라 전까지 내용입니다. @쏘이쏘이양 "
2023-04-26 16:18:22,"뚯뚜오","3일차

요약 

- 다윈의 진화론 이래서구 백인들이 제국주의열강을 합리화하며  흑인 및 아메리카, 폴리네시아인을 지배하기 위한 근거를 찾아보려 했으나 아직 뚜렷한 근거를 찾지 못함.

- 기후, 인구밀도, 리버사이드 관개시설 등 다양한 질문들 소개 및  문화인류학을 연구하게 된 계기 및 본인 혈통 (의사아들, 여러 학위 보유 등) 설명 & 자랑 (참고로 아직도 프롤로그임)


발췌

- 정복이나 노예 수입의 시대로부터 수세기가 지난 오늘날에도 일상 생활 속에서 우리는 그 정복당했던 민족들의 일부가 여전히 하층 계급을 형성하고 있는 것을 본다.

- ""민족마다 역사가 다르게 진행된 것은 각 민족의 생물학적 차이 때문이 아니라 환경적 차이 때문이다"""
2023-04-26 16:18:40,"뚯뚜오","총균쇠입니다."
2023-04-26 16:28:30,"한종우","3일차

[헤드퍼스트 디자인 패턴]

### 요약

- 모든 서브 클래스에서 슈퍼 클래스의 기능이 있어야 하는 것이 아니라면 상속이 올바른 방법은 아니다.
- 서브 클래스에서 Flyable, Quackalbe을 구현하면 코드 재사용을 하지 않아 코드 관리에 어려움이 생길 수 있다.
- 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있는 방법은 무엇일까?
- 요구 사항이 바뀌는 부분은 따로 뽑아서 캡슐화하자. 그러면 코드를 변경하는 과정에서 의도치 않은 영향을 줄이면서 시스템의 유연성을 향상시킬 수 있다
    - 변화하는 부분과 그대로 있는 부분, 2개의 클래스 집합을 만들자
- 실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 상위 형식에 맞춰 프로그래밍해서 다형성을 활용해야 한다. 객체를 선언할때는 추상 클래스나 인터페이스 같은 상위 형식으로 하면 객체를 변수에 대입하는 실제 형식을 몰라도 상위 형식을 구체적으로 구현한 어떤 형식이든 대입할 수 있다.
- 나는 행동하는 별도의 인터페이스를 만들고 실제 동작은 구현 클래스에 구현하면 Duck 클래스와 무관하게 새로운 행동을 추가할 수 있다. 이렇게 디자인하면 나는 행동은 Duck 클래스 안에 있지 않으므로 다른 형식의 객체(탈 것)에서도 나는 행동을 재사용할 수 있다.
    - 상속의 단점을 버리고 재사용의 장점을 누릴 수 있다.

### 발췌

- 가장 중요한 점은 나는 행동과 꽥꽥거리는 행동을 Duck 클래스(또는 그 서브클래스)에서 정의한 메소드를 써서 구현하지 않고 다른 클래스에 위임한다는 것입니다."
2023-04-26 17:56:44,"궈노","3일차
헤드퍼스트 디자인패턴
https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_3_41-55.md"
2023-04-26 19:46:37,"쏘이쏘이양","오 감사합니다"
2023-04-26 20:34:42,"강민규","여러분~ 퇴근은 하셨나요? 아직 얼마 안되어 그런지 다들 잘하시네요 감동의 눈물을 흘립니다. 매번 탈락위기에 놓인 사람들과 챌린지를 이어가는게 굉장한 정신적 압박이었는데, 이번 기수는 끝까지 탈락위기 없이 잘 갔으면 좋겠군요.. 화이팅입니다!"
2023-04-26 22:18:11,"이소민","3일차 제출

[헤드퍼스트 디자인패턴]

📍요약
인터페이스 설계 시, 슈퍼 클래스 하나에만 의존하는 상속은 좋지 않은 방법이다. 서브 클래스마다 또 다른 특징이 있기 때문에 공통점의 부재, 코드 중복 등의 문제점이 발생하기 때문이다. 이럴땐 변화하는 부분을 따로 ‘캡슐화’를 하면 된다. 이는 모든 디자인 패턴의 기반이 되는 원칙이다. 캡슐화 된 인터페이스를 사용하면 추후 따로 수정하거나 확장할 수 있다는 점에서 유지보수가 더욱 수월해진다.


📍발췌
1.디자인 원칙 : 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
2.디자인 원칙 : 구현보다는 인터페이스에 맞춰서 프로그래밍한다.


📍메모
회사에서도 공통 모듈을 쓴다해도 수정해야하는 부분이  항상 나오게 된다. 이럴 때 인터페이스를 구현한다면 더욱 수월 했을거라는 생각이 든다. 이렇게 실무와 엮어 생각하면 이해가 더 빨리 되는 것 같다!"
2023-04-26 22:34:14,"호02","3일차 제출

[초전 설득]

1. 요약
 - 사람은 확증을 찾으려고 한다. 예를 들어, 당신은 완고한 사람인가요? 라는 질문을 던지면 내가 완고한 적이 있는 지를 떠올리고 내가 완고하다고 생각한다 (완고했던 적은 분명히 있을 것이다).
 - 즉, 질문을 통해 그 사람이 그렇게 생각하도록 유도하는 것이다. 
 - 따라서, 한 쪽으로 치우친 설문 조사는 좋지 않다. 양 쪽을 다 생각하게끔 유도하는 설문 조사가 좋은 편이다.
 
2. 메모
 - 글 내용 중에 ""전화가 울리지 않으면, 그건 나아"" 라는 문구가 있는데, 마치 '코끼리를 생각하지마""를 떠올리게 된다."
2023-04-26 22:34:43,"다운","3일차
<사피엔스>

요약
인간의 이례적 특징은 
1)큰 뇌 2) 직립보행

큰 뇌를 가지며 근육이 퇴화했고 직립보행을 하며 높은 시야와 팔이 할 수 있는 일이 늘어나 도구를 만들 수 있게 되었다. 
단 직립보행으로 분만중 사망이 늘어나 여성의 이른 출산과 인간의 뛰어난 사회적 능력이 선호됐다. 

이때 불을 길들이며 먹이사슬의 정점의 핵심단계가 되었는데 불은 숲을 초원으로 바꾸고 식량을 얻고 음식을 익힐 수 있었다. 소화하기 훨씬 쉬워져 인간은 작은 치아와 짧은 창자를 가지고 에너지 소비를 뇌에 집중 할 수 있었다.
또한 불은 신체의 힘의 한계를 뛰어넘는다.

호모 사피엔스는 다른 대륙에 상륙했을때 일부 종과는 교배하기도 했지만 대부분 인종학살을 해 (교체이론) 유일종이 되었다.

사피엔스가 유일종이 된 이유는 고유한 언어 때문이다.

메모 
관용은 사피엔스의 특징이 아니다. 현대의 경우를 보아도 사피엔스 집단은 피부색이나 언어, 종교의 작은 차이만으로도 곧잘 다른 집단을 몰살시키지 않는가.

반면에 사피엔스는 중남미 후진국의 독재자에 가깝다. 인간은 최근까지도 사바나의 패배자로 지냈기 때문에 자신의 지위에 대한 공포와 걱정으로 가득 차 있고 그 때문에 두배오 잔인해지고 위험해졌다.

혼자 사는 엄마는 줄줄이 딸린 자녀와 자긴을 위한 식량을 충분리 조달하기가 어렵다. 애를 키우려면 가족의 다른 구성원 및 이웃의 지속적인 도움이 필요하다. 인간을 키우려면 부족이 필요했고 따라서 진화에서 선호된 것은 강한 사뢰적 결속을 이룰 능력이 있는 존재였다."
2023-04-26 23:29:15,"김용기","3일차
도메인MSA

# 1.3 마이크로서비스를 위한 조건은 무엇인가?

- MSA는 CBD, SOA처럼 기술에만 의존한 아키텍처 스타일을 추구하는 데 그치지 않고 개발 환경, 문화, 일하는 방식과도 연계돼 있음을 보여준다.

## 1.3.1 조직의 변화: 업무 기능 중심 팀

- 마이크로서비스 팀의 구조는 업무 중심 팀이어야 한다. 업무 기능을 중심으로 기술이 다양한 사람들이 하나의 팀이 되어 서비스를 만드는 것을 의미한다. 이팀은 같은 공간, 같은 시간을 공유하기 때문에 의사소통도 원활하고 의사 결정도 빠르게 진행될 수 있다.

## 1.3.2 관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏

- 마이크로서비스팀으로 구성된 조직은 중앙의 강력한 표준이나 절차 준수를 강요하지 않는다.
- 각 마이크로 서비스 팀은 빠르게 서비스를만드는 것을 최우선 목적으로 두고 스스로 효율적인 방법론과 도구, 기술을 찾아 적용한다.

## 1.3.2 개발 생명주기의 변화: 프로젝트가 아니라 제품 중심으로

- 마이크로 서비스팀의 개발은 비즈니스의 갑작스런 트렌드 변화에 유여하게 대처해야 하고 개발뿐만 아니라 운영을 포함한 소프트웨어의 전체 생명주기를 책임져야 한다.
- 소프트웨어를 완성해야 할 기능들의 집합으로 보는 것이 아니라 비즈니스를 제공하는 제품으로 바라보고, 우선 개발한 뒤에 반응을 보고 개선하는 방식으로 소프트웨어를 개발한다. → 애자일 방법론

## 1.3.4 개발 환경의 변화: 인프라 자동화

- 자동화를 통해서 개발이 완료된 후에 필요한 빌드, 테스트, 배포와 같은 개발지원과정의 속도를 높일 수 있다.
- 자동화를 위해서는 소스코드르르 빌드하는 도구, 테스트하는 도구, 가상화된 인프라에 배포하는 도구가 모두 필요하다.
- 인프라 자동화는 마이크로 서비스 개발과정의 필수 조건이 돼야한다.
- `Infrastructrue as Code` 는 코드를 이용해 인프라 구성부터 애플리케이션 빌드, 배포를 정의하는 것을 의미한다.
- 수많은 하드웨어 리소스 설정을 동일하게 통제할 수 있으며, 상황에 따른 검증되고 적절한 설정을 쉽게 복제하고 누구한ㄴ테나 공유할 수 있게 돼서 인프라를 매우 효율적으로 관리할 수 있다.

## 1.3.5 저장소의 변화: 통합 저장소가 아닌 분권 데이터 관리

- 폴리그랏 저장소 접근법은 각 저장소가 서비스별로 분산돼 있어야 하며, 다른 서비스의 저장소를 직접 호출할 수가 없고 API를 통해서만 접근해야 한다는 의미다.
- 마이크로 서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묵는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다.
- 결과적 일관성은 두 서비스의 데이터가 일시적으로 불일치하는 시점에 잇고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념이다. 여러 트랜잭션을 하나로 묶지 않고 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다.
- 마이크로 서비스가 추구하는 방법은 각 트랜잭션을 분리하고 큐 메커니즘을 이요해서 보상 트랜잭션을 활용하는 방법이다."
2023-04-26 23:32:02,"최희윤","삭제된 메시지입니다."
2023-04-26 23:33:36,"최희윤","3일차 DDD 
https://www.notion.so/04-26-DDD-3-a490d2e5241547d5b9dc58e65227d638?pvs=4"
2023-04-26 23:59:20,"최윤지","3일차
[7가지 코드]

https://quiet-jade-e60.notion.site/3-0426-4f0d2bb2845d47f9901673835d4d38f9"
2023-04-27 00:01:20,"최다봄","3일차

[헤드퍼스트 디자인 패턴]

### 요약

**문제점**

- 상속 활용 시, 규격이 바뀔 때마다 Duck 서브 클래스의 fly()와 quack() 메소드를 오버라이드 해야한다.

**해결점 도출** 

- 기존 코드에 미치는 영향을 최소한으로 줄이는 방법으로 !
- 바뀌는 부분은 따로 뽑아서 캡슐화 한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

**해결방법**

- 바뀌는 부분과 그렇지 않는 부분을 분리한다.
- 바뀌는 부분은 “나는 행동(fly)”과 “꽥꽥거리는 행동(quack)”
- 각 행동은 **인터페이스**(ex. FlyBehavior, QuackBehavior)로 **표현**하고, 해당 인터페이스를 사용하여 **행동을 구현**
- 즉, 행동(behavior) 인터페이스는 Duck 클래스가 아니라 행동 클래스에서 구현된다. (== 실제 행동 구현이 Duck 서브클래스에 국한 X)

### 발췌

- **“인터페이스 맞춰서 프로그래밍한다”라는 말은 사실 “상위 형식에 맞춰서 프로그래밍한다”라는 말입니다.** (p.48)
    - 핵심은 **실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록** 상위 형식(supertype)에 맞춰 프로그래밍해서 다형성을 활용해야한다는 점이다.
- 디자인 원칙 (p.45, 47)
    1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
    2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다."
2023-04-27 00:14:53,"쏘이쏘이양","3일차
초전설득

설득전 신뢰 형성 중요한데 신뢰라는 이미지와 나를 연상시킬수만 있어도 통함

오프너-프레임, 앵커, 점화, 마인드셋, 첫인상 등의 사전행동 통칭
 
오프너의 역할은 설득 과정을 시작하고, 기존의 장벽을 없애는 역할은 가장 중요함

설득의 성공률을 높이는 공통 심리학 개념: 상호성, 호감, 사회적증거, 권위, 희소성, 잘관성

전달하능 타이밍이 중요하다 - 특권의 순간 활용하기
"
2023-04-27 00:35:07,"박소환","3일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/70

오늘의 2줄 요약
- 마이크로서비스를 하기 위해서 필요한 6가지 (업무기능 중심 팀, 폴리글랏 관리체계, 제품 중심 개발 생명주기, 자동화된 인프라 개발환경, 분권 데이터 저장소, 실패 대응)
- 비즈니스 민첩성을 강화하기 위한 3요소 ( 자동화된 개발환경, 점진 반복 개발 프로세스, 자율적인 업무 기능중심 팀)"
2023-04-27 01:36:26,"김형우","[3일차]
https://engineer-diary.tistory.com/192"
2023-04-27 01:41:15,"김성태","3일차
[헤드 퍼스트 디자인 패턴]

### 요약

- 규격이 계속 바뀐다면 상속이 좋은 방법이 아님
    - 매번 메소드를 살펴보고 override하는 것이 번거롭기 때문
- 소프트웨어 개발 불변의 진리는 ‘변화’이다
- 바뀌는 부분만 따로 뽑아서 캡슐화한다.
    - → 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.
- 바뀐 방법
    - Duck 서브클래스는 인터페이스(FlyBehavior, QuackBehavior)로 표현되는 행동을 사용함

### 발췌

**디자인 원칙**

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

- “인터페이스에 맞춰서 프로그래밍한다”라는 말은 사실 “상위 형식에 맞춰서 프로그래밍한다”라는 말입니다.
- “상위 형식에 맞춰서 프로그래밍하라”는 원칙의 의미
    - 변수를 선언할 때 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있기 때문이다. 그러면 변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다."
2023-04-27 06:43:26,"Bo","3일차
해드퍼스트
### 요약

> 문제의 해결
> 
- FlyBehavior, QuakBehavior 로 인터페이스를 분리한다
- 이를 각 서브클래스에서 구현하게 하면 코드 중복과 유지 보수의 어려움이 있었다
- FlyBehavior, QuakBehavior  를 구현한 각 서브클래스를 만든다
- Duck 이라는 추상클래스에서 FlyBehavior, QuakBehavior  의 인스턴스를 필드로 받게하고 performQuack() 같은 메서드를 실행할경우 QuakBehavior 인스턴스의 quack() 메서드를 실행하도록 하여 나는 것과, 꽥꽥 거리는 행동을 위임한다
- Duck 의 구현 클래스에서는 생성자에서  FlyBehavior, QuakBehavior  의 인스턴스를 생성하여 필드로 선언하게 한다

### 발췌

> 디자인 원칙 2가지
> 
- `애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다`
- `구현보다는 인터페이스에 맞춰서 프로그래밍 한다`"
2023-04-27 07:12:45,"리경","3일차
오브젝트

✨ 요약
- 의존성은 변경에 대한 영향 암시. 
- 목표는 애플리케이션 기능 구현시 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것.
- 결합도가 높다 = 객체간 의존성이 과하다

- 객체 자신이 일을 스스로 처리해야 한다는 우리의 직관을 벗어나면 코드를 이해하기 어려워짐.
- 캡슐화로 객체 내부 접근 제한시 객체와 객체 사이 결합도 낮출 수 있음
- 인터페이스만 의존하고, 내부에 무언가 캡슐화된 건 구현의 영역

- 절차지향과 객체지향 프로그래밍의 근본적 차이는 책임의 이동을 통해 만들어짐
- 절차 지향은 책임이 집중되 있으나 객체 지향은 몰려 있던 책임이 개별 객체로 이동함. 자신을 스스로 책임지고 수행하는 자율적 객체들의 공동체로 구성.

✨ 발췌
- 모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다. 두 번째 목적은 변경을 위해 존재하는 것이다. 대부분 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다. 모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통 할 수 없는 모듈은 개선해야 한다.

✨ 메모
데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치한다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다.

데이터와 데이터를 사용하는 프로세스가 동일한 객체에 위치한다면 객체지향 프로그래밍 방식을 따르고 있을 확률이 높다."
2023-04-27 07:48:16,"강민규","사진"
2023-04-27 07:49:15,"강민규","여러분 오늘은 목요일입니다. 이번 주가 그냥 흘러가지않게 의미있게 보내보아요~"
2023-04-27 07:55:09,"이찬영","3일차
헤드퍼스트 디자인패턴

# 요약

**CHAPTER 01. 디자인 패턴의 세계로 떠나기. (디자인 패턴 소개와 전략 패턴)**

디자인 원칙1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.\

디자인 원칙2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

- 개발자 Joe의 SimUDuck 사례에 적용하기
    - 디자인 원칙1 : Duck 클래스와는 별개로 나는 것과 꽥꽥거리는 것을 분리한다.
    - 디자인 원칙2 : 각 행동은 인터페이스(FlyBehavior, QuackBehavior)로 표현하고 이것을 사용해 행동을 구현한다.

🎈 나는 행동과 꽥꽥 거리는 행동을 Duck 클래스에서 정의한 메소드를 써서 구현하지 않고 타 클래스에 위임한다.

# 발췌

💡 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 ‘캡슐화’ 합니다. 그러면 코드를 변경하는 고정에서 의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상시킬 수 있습니다.


# 메모

디자인 원칙에 대해 알아가면서 중간중간 생각할 타임을 줘서 좋다."
2023-04-27 08:14:27,"김연정","4일차
초전설득
(2장 처음부터 타킷슈팅 전까지)

요약
긍정적 테스트 전략: 사람들은 가능성을 따질 때 일반적으로 틀린 경우보다 맞는 경우를 따진다. 그 생각이 부당한지보다 정당한지를 우선 고려한다.
(손금을 볼 때 대부분 사람들이 맞췄다고 믿는 이유)

메모
추가적으로 찾아본 예시: 당신은 착한 사람인가? 나는 선한 사람인가? 라는 질문을 계속 생각하면 착하게 행동했던 경험만을 떠올리게 되고, 반대로 당신은 나쁜 사람인가? 라는 질문을 생각하게 되면 나쁜 행동을 했던 경험만을 생각하게 돼서 고객에게 질문을 할 경우 거래성사율이 달라짐"
2023-04-27 10:58:27,"송예은","4일차
도메인MSA

# 2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

- 현대 애플리케이션에 대한 기대를 잘 표현한 리액티브 선언문이라는 문서가 있다.
    
    응답성, 탄력성, 유연성, 메시지 기반의 4가지 특성
    
    - 응답성 : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공
    - 탄력성 : 장애에서 빠르게 복구하는 능력
    - 유연성 : 사용량에 변화가 있어도 균일한 응답성을 제공
    - 메시지 기반 : 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신 지향
- 리액티브란 급변하는 상황에 적응할 수 있는 시스템을 요구하는 것이다.
- 리액티브 시스템이 반드시 갖춰야 할 공통적인 특성은 아키텍처 유연성이다.

# 2.2 강결합에서 느슨한 결합의 아키텍처로의 변화

- 예전에는 특정 벤더의 제품에 전적으로 의존해서 강결합된 경우가 많았다.
    
    최근에는 클라우드 환경하에서 오픈소스 기반으로 하여 벤더에 의존할 필요가 적어졌다.
    
- 예전에는 검증된 기술이나 솔루션 기반으로 직접 구현하는 폐쇄적인 방식
    
    최근에는 필요한 영역에 적절한 솔루션을 선택하고 조합하는 개방적인 방식
    

# 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

- 인프라, 플랫폼, 애플리케이션 영역
    
    기반이 되는 하드웨어 인프라, 인프라 위에 애플리케이션 운영 및 구동을 위한 플랫폼이 올라가고, 플랫폼 위에 애플리케이션 서비스가 구동된다.
    
- 외부 아키텍처는 마이크로서비스가 운영되는 환경을 정의한다.
- 내부 아키텍처는 실제로 비즈니스가 실행되는 비즈니스 애플리케이션의 구조를 말한다.

# 2.4 MSA 구성요소 및 MSA 패턴

- MSA 구성요소 및 패턴의 유형
    - 인프라 구성요소
        
        MSA를 지탱하는 하부구조 인프라를 구축하는 데 필요한 구성요소
        
    - 플랫폼 패턴
        
        인프라 위에서 MSA의 운영과 관리를 지원하는 플랫폼 차원의 패턴
        
    - 애플리케이션 패턴
        
        MSA 애플리케이션을 구성하는 데 필요한 패턴
        

## 2.4.1 인프라 구성요소

IT 환경 운영, 관리에 필요한 하드웨어, 소프트웨어, 네트워킹 구성요소, 운영체제, 데이터 스토리지 등을 모두 포괄한다.

### 퍼블릭 클라우드와 베어 메탈, 프라이빗 클라우드 환경

인프라 아키텍트는 퍼블릭 클라우드를 사용할 것인지, 베어 메탈에 프라이빗 클라우드 환경을 사용할 것인지 결정해야 한다. 마이크로서비스는 어떠한 환경에서도 유연하도록 구성돼야 하므로 특정 인프라를 고집하지 않는다. 그러므로 인프라로 어떤 것을 선택해도 상관없다.

### VM과 컨테이너

- 가상 인프라 환경에서는 가상 머신과 컨테이너 중 하나를 선택해야 한다.
- 가상머신은 하이퍼바이저라는 소프트웨어로 하나의 시슽메에서 여러 개의 운영체제를 사용할 수 있다. 컨테이너는 하이퍼바이저 없이 컨테이너 엔진으로 가상된 격리 공간을 생성한다.
- 둘의 차이는 게스트 OS 유무이다. 게스트 OS를 사용하는 가상 머신에서는 운영체제 패치 설치나 관련 라이브러리 설치 같은 오버헤드가 지속적으로 발생한다. 따라서 MSA 같은 작은 서비스를 패키지하고 배포하기에는 컨테이너 환경이 더 적합하다.
- 도커 컨테이너는 레이어 단위의 이미지를 포개는 방식으로 구성되며, 밑에서부터 애플리케이션 구동을 위한 기반 이미지, 운영체제, 런타임, 애플리케이션이 이미지로 정의된다.
- 도커 컨테이너의 이점
    - 이식성 : 어떤 커널이나 플랫폼 버전에 상관없이 도커만 실행할 수 있으면 사용 가능하며 동일하게 동작된다.
    - 신속성 : 크기가 작고 가벼워 빠르게 배포 가능
    - 재사용성 : 동일한 환경 재사용이 쉬워서 개발, 테스트, 스테이징, 프로덕트 환경을 동일한 환경으로 구축 가능"
2023-04-27 17:04:36,"수정","3일차
헤드퍼스트 디자인 패턴

# 요약
Duck클래스의 메소드를 사용할 때, 서브클래스에서 변화가 있을 때마다 오버라이드하면 유지보수가 어렵다.
인터페이스를 사용하면 안에 구현된 코드가 없으므로 코드를 재사용할 수 없다
Duck클래스의 메소드를 사용하지 않고, 행동 인터페이스를 정의해 위임한다
Duck클래스에서는 행동 메소드 안에서 행동 인터페이스 객체의 메서드를 호출한다

# 발췌
- 바뀌는 부분만 캡슐화하면 바뀌지 않는 부분에 영향을 주지 않고 그 부분만 고치거나 확장할 수 있다
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다"
2023-04-27 20:29:27,"강민규","반갑습니다 여러분 잘지내고 계신지요? 벌써 목요일이 끝났습니다. 일주일이 훌쩍 가버렸네요.. 내일 금요일 지나면 다음주는 휴일이 이틀이나 있는 아주 멋진 주네요. 벌써부터 기대가 됩니다~ 

일하고 오면 다들 피곤하고 지칠텐데 이렇게 발전을 위해 노력하시는 모습이 아주 멋집니다! 오늘도 할당된 분량을 읽으시고 좋은 루틴을 만들어가봅시다~ 화이팅!!"
2023-04-27 20:53:22,"호02","4일차 제출

[초전 설득]

1. 요약 
 - 유도된 주의 : 내가 원하는 것에 집중할 수 있도록 상대방의 주의를 유도하는 것
 - 설문 조사를 하기 전에 ""당신은 남을 잘 돕습니까?"" 라는 질문을 먼저 던지면 설문 참여율이 높아진다.
 - 주의에는 대가가 따른다. 사람은 한 번에 하나의 대상에만 의식적으로 생각할 수 있다.
 - 통화를 하면서 다른 일을 하는 게 느껴진다면, 통화 상대에 주의를 기울이지 않는다는 것이고, 우리는 그것을 본능적으로 느낀다.


2. 메모
 - 의도된 질문으로 사람을 유도할 수 있다는 게 좀 무섭다는 생각이 든다. 
 - 나도 이미 누군가에 의해 유도되는 삶을 살고 있는 게 아닐까"
2023-04-27 22:19:07,"뚯뚜오","3일차 
총균쇠 

요약
프란시스코 피사로 휘하에 있던 소수의 정복자 군대가 페루의 도시 카하마르카에서 잉카 최후의 독립적인 황제였던 아타우알파. 어째서 잉카 황제 아타우알파는 스페인의 마드리드로 쳐들어가서 스페인 황제 카를로스 1세를 생포하지 못하고 본인의 영토에서, 그의 군대 전체가 보는 앞에서 생포되게 만들었던 궁극적인 원인들 (프롤로그 끝)

고릴라, 침팬지, 초기 유인원들의 이동경로 및 이동시점 관련 이야기 (1장 문명이 싹트기 직전의 세계 상황)

발췌.
유럽인과 사하라 이남 아프리카 원주민과의 충돌 결과는 아메리카 원주민과의 충돌 결과와 사뭇 달랐다. 유럽인들은 아프리카를 정복한 이후에도 사하라 이북의 아프리카 일부를 제외하면 유럽인 정착촌을 형성하는데 실패했다."
2023-04-27 22:27:10,"김용기","3일차
도메인MSA

# 2.1 리액티브 선언

- 클라우드 인프라를 고려할 때 가장 신경써야하는 요소는 응답성, 탄력성, 유연성, 메시ㅔ지 기반이다. 이 요건을 만족하는 시스템을 리액티브 시스템이라고 한다.
    - 응답성 : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공하는 것
    - 탄력성 : 부분적으로 고장 나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력
    - 유연성 : 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공
    - 메세지 기반 : 비동기 메세지 전달
- 리액티브는 다양한 상황에 따라 빠르고 적절하게 반응하는 시스템이다.
- 리액티브 시스템이 위와같은 특성을 갖추기 위해서는 아키텍처 유연성을 갖추는 것이 필수다.
- 아키텍처 유연성은 시스템을 구성하는 구성요소 간의 관계들이 느슨하게 맺어져 있어 언제든지 대체되거나 추가 확장될 수 있는 특성을 말한다.

# 2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화

- 최근의 아키텍처 설계는 필요한 영역에 적절한 솔류션을 선택하고 조합하는 개방적인 방식으로 바뀌고 있다.
- 아키텍트는 다양한 기술 영역의 변화 흐름을 이해하고 따라가야 하며, 최적의 클라우드 환경을 구성할 적절한 제품 및 솔루션을 선택해서 조합할 필요가 있다.

# 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

- 내부 아키텍처는 마이크로서비스가 제공하는 API, 비즈니스 로직, 이벤트 발행, 데이터 저장 처리 등을 어떻게 구조화해야 하는가에 관한 내용이다.

# 2.4 MSA 구성요소 및 MSA 패턴

## 2.4.1 인프라 구성요소

- 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는 데 필요한 구성요소

### 퍼블릭 클라우드와 베어 메탈, 프라이빗 클라우드 환경

- 인프라 환경으로 퍼블릭 클라우드 환경이든 프라이빗 클라우드 환경이든 어떤 것을 선택하든 다른 아키텍처 요소와 유연하게 결합할 수 있어 크게 신경 쓸 필요가 없다.

### VM과 컨테이너

- 마이크로 서비스 같은 작은 서비스를 패키지하고 배포하기에는 커테이너 환경이 적합하다. 마이크로 서비스의 가변적이고 유연한 속성을 컨테이너가 쉽고 빠르게 지우너할 수 있기 때문이다."
2023-04-27 22:39:05,"최윤지","4일차
[7가지 코드]

https://quiet-jade-e60.notion.site/4-0427-c215f36ba5114e54bf93b7990118a499"
2023-04-27 23:01:42,"박소환","4일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/71"
2023-04-27 23:09:24,"Bo","4일차 
헤드 퍼스트 
### 요약

> 전략패턴
> 
- 동적으로 행동을 지정하기 위해, 인터페이스 필드의 구체 구현 클래스에 대한 setter() 메소드를 만들었다
- 지금껏 해본 것이 전략패턴이다
    - 변하는 부분 ( 어떻게 나는지 등 ) 을 캡슐화해서 ( 별도의 인터페이스와 그것을 구현한 클래스들 ) 알고리즘 군으로 만들고, 각 알고리즘을 클라이언트와 독자적으로 수정할 수 있다
- 패턴을 알고 사용하면 효율적으로 코드를 짤 수 있고 의사소통에도 유리하다

### 발췌

> 디자인 원칙
> 
- `상속보다는 구성을 사용한다`

### 메모

- 전략패턴이 무엇인지 알 것 같다. 클라이언트와 독립되었다는 점이 것이 중요한 것 같다"
2023-04-27 23:17:03,"궈노","4일차 
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_4_56-69.md"
2023-04-27 23:40:31,"김형우","[4일차]
https://engineer-diary.tistory.com/194"
2023-04-27 23:45:13,"이소민","4일차 제출

[헤드퍼스트 디자인패턴]

📍요약
지금까지 배운 전략 패턴은 클라이언트로부터 분리한 알고리즘을 정의하고 캡슐화하기 때문에 독립적으로 코드를 관리할 수 있다.
이처럼 디자인 패턴을 사용하는 것은 관리하기 쉬운 시스템을 구축하기 위한 첫번째 관문이다.

📍발췌
1.디자인 원칙 : 상속보다는 구성을 활용한다.
2.일단 패턴을 완전히 익혀 두면 어떤 코드가 유연성 없이 엉망으 로 꼬여 있는 스파게티 코드라는 사실을 금방 깨달을 수 있 으며 그 코드를 수정할 때 패턴을 적용해서 코드를 개

📍메모
단순히 결과물에만 초점을 맞춘 코드 구현은 안좋은 방법이다. 끊임없는 유지보수를 위해 재사용이 용이하며 독립적으로 관리하기 쉬운 코드를 짜기 위해 디자인 패턴을 잘 활용해보자."
2023-04-27 23:45:25,"뚯뚜오","아 이거 4일차인데 3일차로 제목을 잘못 썼네요. 확인 부탁드립니다."
2023-04-27 23:45:53,"강민규","넵 이미 확인했습니다~"
2023-04-28 00:23:40,"최다봄","4일차

[헤드퍼스트 디자인 패턴]

### 요약

- **객체 지향 기초**
    - 추상화, 캡슐화, 다형성, 상속
- **객체 지향 원칙**
    - 바뀌는 부분은 **캡슐화**
    - 상속보단 **구성**
    - 구현보다는 인터페이스에 맞춰서 프로그래밍 (~~기억하기~~)
- **객체 지향 패턴**
    - 전략 패턴은 알고리즘군을 정의하고, 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있다. 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경가능하다.
    
    *클라이언트 - Duck 클래스
    
    *알고리즘 - “나는 행동(fly)”과 “꽥꽥거리는 행동(quack)”
    

### 발췌

핵심 정리(p.68)

- 객체지향 기초 지식만 가지고는 훌륭한 객체지향 디자이너가 될 수 없다.
- 훌륭한 객체지향 디자인이라면 재사용성, 확장성, 관리의 용이성을 갖출 줄 알아야 한다.
- 패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공한다.
- 패턴은 검증받은 객체지향 경험의 산물이다.
- 패턴이 코드를 바로 제공하는 것은 아니다. 디자인 문제의 보편적인 해법을 제공한다. 특정 애플리케이션에 패턴을 적용하는 일은 우리가 해야 한다.
- 패턴은 발명되는 것이 아니라 발견되는 것이다.
- 대부분의 패턴과 원칙은 소프트웨어의 변경 문제와 연관되어 있다.
- 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공한다.
- 많은 경우 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 한다.
- 패턴은 다른 개발자와의 의사소통을 극대화하는 전문 용어 역할을 한다.

메모

- 기존에 일단 “구현”하려고 한 부분에 있어서 인터페이스에 맞는 프로그래밍을 고민해봐야할 것 같다."
2023-04-28 00:48:18,"이찬영","삭제된 메시지입니다."
2023-04-28 00:48:49,"이찬영","4일차
헤드퍼스트 디자인패턴

# 요약

- 동적으로 행동 지정하기 : 움직이는 오리 만들기
실행 중에 오리의 행동을 바꾸고 싶으면 원하는 행동에 해당하는 Duck의 세터 메소드를 호출합니다.
- 캡슐화된 행동 살펴보기
클래스 다이어그램에 있는 각 화살표와 클래스들이 어떤 관계인지, 직접 연필로 써보는 게 중요하다.
- ""A에는 B가 있다""
각 오리에는 FlyBehavior와 QuackBehavior가 있으며, 각각 나는 행동, 꽦꽥 행동을 위임받는다. -> 이렇게 두 클래스를 합치는 것 : '구성(composition)을 이용한다.' 라고 한다.

디자인 원칙3: 상속보다는 구성을 활용한다.
-> 유연성을 향상시킬 수 있음.

---

첫 번째 디자인 패턴 : 전략패턴
: 알고리즘군을 정의하고 캡술화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다. 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.

---

패턴과 전문 용어

1. 서로 알고 있는 패턴은 막강하다.
2. 패턴을 사용하면 간단한 단어로 많은 얘기를 할 수 있다.
3. 패턴 수준에서 이야기하면 '디자인'에 더 오래 집중할 수 있다.

디자인 패턴 사용법

- 라이브러리나 프레임워크가 도와주지 못하는 부분을 도와주는 것이 바로 디자인 패턴이다.

일단 패턴을 완전히 읽혀두면, 어떤 코드가 유연성 없이 엉망으로 꼬여있는 스파게티 코드라는 사실을 알 수 있다.

---

나의 객체지향 도구상자

1. 객체지향 기초 (추상화 캡슐화 다형성 상속)
2. 객체지향 원칙
3. 객체지향 패턴 - 전략패턴

# 발췌

💡 첫 번째 디자인 패턴 : 전략패턴
: 알고리즘군을 정의하고 캡술화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다. 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다


# 메모

디자인 패턴은 개발자 사이에서 서로 모두 이해할 수 있는 용어를 재공한다. 패턴 수준에서 생각 할 수 있기 때문에 아키텍처를 생각하는 수준도 끌어올려준다."
2023-04-28 01:49:25,"김성태","### 요약

- 클래스 사이의 관계를 다이어그램을 통해 표현할 수 있다
- 두 클래스를 합치는 것을 composition을 이용한다고 한다.
- Strategy Pattern은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

4일차
[헤드 퍼스트 디자인 패턴]

### 발췌

- 실행 중에 오리의 행동을 바꾸고 싶으면 원하는 행동에 해당하는 Duck의 setter 메소드를 호출합니다."
2023-04-28 07:25:36,"다운","4일차
사피엔스

사피엔스는 인지혁명 후 최강의 포식자가 되는데 인지혁명은 우연히 일어난 유전자 돌연변이 이다. 

인지혁명은 최초의 의사소통체계는 아니지만 이로 인해 언어가 유연해졌고 막대한 양의 정보를 받아들이고 저장하게 되었다. 
사회적 동물인 사피엔스는 언어를 통해 무리를 확대하고 또 허구를 말할 수 있는 능력덕분에 집단적상상을 하게 되어 더 많은 숫자가 모여 유연하게 협력하게 되었다.

발췌
뒷담화는 악의적인 능력이지만 많은 숫자가 모여 협동 하려면 사실상 반드시 필요하다.

언론인은 원래 소문을 퍼뜨리는 사람이었고 언론인들은 누가 사기꾼이고 누가 무인승차자인지을 사회에 알려서 사회를 이들로부터 보호한다.
"
2023-04-28 07:43:37,"강민규","사진"
2023-04-28 07:45:03,"강민규","여러분 오늘 날씨 너무 좋네요~ 곧 여름이 올 것 같은  하늘입니다! 오늘도 화이팅입니다!!"
2023-04-28 07:57:16,"리경","4일차
오브젝트

✨ 요약
Ex. 영화 예매 프로그램

- 진정한 객체지향 패러다임으로 전환은 클래스가 아닌 객체에 초점을 맞출 때만 얻을 수 있다.

- 클래스의 구조는 도메인의 구조와 유사해야함.

- 클래스 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것. 클래스 내외부로 구분. 어떤 부분은 공개하고 어떤 부분 감출지.
-> 경계의 명확성이 객체의 자율성 보장, 프로그래머에게 구현의 자유 제공

- 인터페이스와 구현의 분리는 훌륭한 객체지향 프로그램 만들기 위해 따라야하는 핵심 원칙임.
인터페이스 : 외부에서 접근 가능
구현 : 외부에서 접근 불가능, 내부에서만 접근 가능

✨ 발췌
-변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다. 
변경을 수용할 수 있는 설계가 중요한 또 다른 이유는 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다. 

-변경 가능한 코드란 이해하기 쉬운 코드다. 만약 여러분이 어떤 코드를 변경해야 하는데 그 코드를 이해할 수 없다면 어떻겠는가?"
2023-04-28 08:32:47,"쏘이쏘이양","4일차
초전설득

📍발췌
나에게 유리한 순간을 포착하라. 
긍정적 테스트 전략: 사람들은 어떤 가능성이 맞는지 틀린지를 결정할 때 일반적으로 틀린 경우보다는 맞는 경우를 찾는다. 즉 그 생각이 부당한지보다는 정당한지를 우선 고려한다는 것이다. 

📍메모
아직 초반이지만 읽을수록 뻔뻔해져야 한다는 이야기를 하는 것 같다. 인간의 본성을 알고 그것들을 이용하자는 메시지가 마음 속에 무언가 꺼려지는 것이 있는데, 이 책을 다 읽고 나면 해결될 수 있을지 의문이다. 내가 너무 순진한건가 싶기도 하고."
2023-04-28 10:02:44,"Bo","5일차 
헤드퍼스트 
### 요약

> 기상모니터링 애플리케이션 ( 문제 상황 설명 )
> 
- 데이터가 변하면 특정 메소드가 실행되고, 해당 메소드가 실행될 때마다 3가지의 디스플레이의 값을 업데이트 해야 한다
- 디스 플레이는 확장 가능 해야 한다
- 현재는 실행되는 특정 메소드에서 개별 디스플레이를 호출하는 방식을 취하는데, 이는 디스플레이가 추가될 경우 코드를 변경해야 한다 ( 변경에 닫혀 있다 )

> 옵저버 패턴
> 
- subject 와 observer 가 있다.
- observer 는 subject 를 구독하고, subject 는 ( 이벤트가 발생하면 ) observer 들에게 해당 내용을 보낸다
- subject 구독 취소도 가능하고 / observer 추가도 가능하다

### 발췌

> 디자인 원칙
> 
- `상속보다는 구성을 사용한다`"
2023-04-28 10:03:25,"뚯뚜오","4/28(금) - 5일차
총균쇠 

요약
인류의 기원은 700만년 전. 아프리카에서 최초 흔적 발견.
유럽에서 발견된 최초 인류의 흔적은 50만년 전이니, 유럽까지 가는데 650만년 걸린 셈.
하지만 아직까지도 원숭이보다 약간 더 뇌가 큰 대두원숭이 중 하나일 뿐.
약 50,000년 전의 대약진 시기가 되어서 드디어 인간이라 부를 수 있을만한 일들이 발생함.
장식품 등의 인공유물, 표준화된 석기의 대량생산 흔적. 작살, 투창기, 활과 화살 등의 무기도 장착함.
대약진기간의 인류 후두 발전은 유인원의 한 부류에서 시작되어 널리 전파되었을까? 아니면 여러 지역의 여러 유인원들로부터 동시다발적으로 진행된 기후 등의 문제인 것인가?
인류의 호주 진입과 인류의 첫 대형 육식동물 멸종 사건. - 과거의 오스트레일리아에는 거대캥거루, 소, 유사코뿔소, 180kg의 대형타조, 1톤에 육박하는 도마뱀 등이 있었던 흔적이 보이나, 현재 오스트레일리아에는 체중 45키로의 캥거루가 킹애니멀임.
(1장 문명이 싹트기 직전의 세계 상황)

발췌
안전한 거리에서 동물을 죽일 수 있는 효과적인 수단이 생겼으므로 코뿔소나 코끼리 같은 위험한 동물도 사냥할 수 있게 되었고 한편으로는 그물, 낚싯줄, 덫 등을 만들 수 있는 끈이 발명됨에 따라 그들의 식단에는 새로이 사냥된 물고기와 조류가 올려졌다. 집과 꿰매어 만든 의류 등의 유물은 추운 기후에서도 생존할 수 있는 능력이 크게 향상되었음을 입증하고 장신구와 꼼꼼하게 매장된 유골 등으로 미루어 심미적 정신적인 면에서도 가히 혁명적인 발전이 이루어지고 있었음을 짐작할 수 있다.
...
약 4만년 전에 현대적인 골격을 가진 크로마뇽인이 우수한 무기를 비롯한 각종 발달된 문화적 특성들과 함께 유럽에 진입했다. 그때까지 수십만 년 동안 유럽을 독차지하고 진화해 왔던 네안데르탈인은 그로부터 몇천 년 이내에 자취를 감추고 말았다. 이 결과는 현대적인 크로마뇽인이 훨씬 월등한 기술 및 언어 또는 두뇌를 이용하여 네안데르탈인을 감염시키거나 죽이거나 대체했음을 강력히 시사하며, 네안데르탈인과 크로마뇽인 사이의 혼혈 증거는 거의 또는 전혀 남아있지 않다.
...
우리 조상들의 사냥 기술은 처음에는 아주 한심한 수준이었다가 서서히 향상되었으므로 동물들에게는 인간에 대한 공포심을 진화시킬 시간이 넉넉했다. 그러나 도도새, 모아새, 그리고 아마 오스트레일리아 뉴기니의 거대 동물들은 진화의 측면에서 아무런 준비도 갖추지 못한 채 갑자기 잘 발달된 사냥 기술을 지니고 쳐들어온 현생 인류와 맞닥뜨리는 불운을 당했을 것이다.
...
오스트레일리아 뉴기니의 대형 동물이 모두 사라진 것은 그 이후의 인류사에 크나큰 영향을 미쳤다. 멸종으로 인하여 가축화가 될 만한 대형 야생 동물들이 모조리 사라졌고, 결국 오스트레일리아와 뉴기니의 원주민들에게는 토종 가축이 단 한 종도 남아 있지 않게 된 것이다."
2023-04-28 10:08:09,"쏘이쏘이양","5일차
초전설득

📍발췌
다른 사람의 행동을 변화시키려면 그 사람의 기존 성향들을 먼저 바꾸고, 그게 걸맞는 행동을 유발해야 한다. 유도된 주의의 무자비함: 어떤 것에 주의가 쏠리게 되면, 이제 그 주의가 이어지면서 이후의 관련된 사항들에 주목하게 만들 뿐만 아니라 다른 경쟁 정보나 속성들을 억누른다. 그래서 더욱 무서운 것이다. pay attention: 주의에는 대가가 따른다. 어떠한 개념, 사람, 물건 등에 상대방의 주의를 집중시키면 상대방은 곧 그것이 예전에 비해 자신에게 굉장히 중요해졌다고 인식하게 된다.

📍메모
pay attention이 주의에는 대가가 따른다는 뜻에서 생긴거라는 사실이 신선한 충격으로 다가온다. 아무 생각없이 쓰던 말인데 그런 심오한 뜻이.. 재밌는 영어 표현이 많은 것 같다."
2023-04-28 15:23:31,"최희윤","4일차 DDD
https://www.notion.so/04-27-DDD-4-7c031caf42c34b2db9b626eb119802f7?pvs=4

5일차 DDD
https://www.notion.so/04-28-DDD-5-8ab0821f0f5141aea12accdf8e899bd7?pvs=4"
2023-04-28 16:26:03,"다운","5일차

사피엔스

요약: 자연상태에사의 침팬치의 개체수는 20~50마리다. 인지혁명과 뒷담화 이론 덕분에 결속할 수 있는 집단은 약 150명이 되었다. 하지만 호모 사피엔스는 ‘가상의 실재’를 믿게 되며 수억명의 제국을 건설 할 수 있었다.
가상의 실재란 객관적으로 존재하진 않지만 모든 사람들이 믿는 것을 말한다. ‘푸조’ 라는 객관적 실재가 없어도 법적으로 존재하고 영향력 있는걸 의미한다. 

발췌
알파수컷이 그 위치를 차지하는 것은 보통 육체적으로 더 강하기 때문이 아니라 더 크고 안정된 동맹을 이루기 때문이다

뒷담화로 결속할 수 있는 집단의 자연적 규모는 약 150명 이라는 것이 밝혀졌다

효과적인 이야기을 하는 것은 물론 쉽지 않다. 이야기을 하는 게 어려운게 아니아 남들이 그 이야기를 믿게 만드는 게 어렵다"
2023-04-28 17:53:05,"송예은","5일차
DDD, MSA

### 컨테이너 오케스트레이션

- 컨테이너 관리를 위한 기능을 컨테이너 오케스트레이션이라 하고, 쿠버네티스를 많이 사용한다.
- 쿠버네티스의 이점
    - 자동화된 자원 배정
    - 셀프 치유
    - 수평 확장

## 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

인프라 환경 위에서 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법이다. 애플리케이션을 빌드하고 인프라에 배포할 수 있는 환경이 중요하다.

### 개발 지원 환경: 데브옵스 인프라 구성

- 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말한다.
- 자동화된 빌드나 배포 작업을 보통 CI/CD라고 하며, CI는 지속적 통합을 가리킨다.
- CD는 지속적 제공 및 지속적 배포를 의미한다.
- 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동을 CI라고 하고, 실행 환경에 내보내는 활동을 CD라 한다.

### 빌드/배포 파이프라인 설계

- 빌드/배포 파이프라인은 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시작화된 절차로 구축하는 것이다.
- 빌드/배포 파이프라인은 마이크로서비스별로 별도로 설계해야 한다.

### 마이크로서비스 생태계와 운영 관리 요소의 탄생

- 전체 서비스를 여러 개의 서비스로 분산 구성했을 때 한 서비스에서 발생한 장애가 다른 서비스로 전파된다거나 여러 서비스에 분산된 로그를 관리해야 하는 불편함, 서비스 하나가 동작하지 않아 시스템 일부 기능이 동작하지 않아도 알아채지 못하고 장애가 방치되는 문제들이 발생했다.
- 넷플릭스를 주도로 이를 해결할 기술들이 공유되고 자연스럽게 업계가 발전하게 됐다.
- MSA 발전에 따라 도커, 스프링 부트, 쿠버네티스가 등장했다.

### 경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴

- 넷플릭스 oss는 넷플릭스가 마이크로서비스를 개발, 운영하면서 생긴 노하우를 공개한 오픈소스다.
- 스프링 진영에서는 넷플릭스 oss 모듈들을 스프링 프레임워크로 감싸서 스프링 클라우드라는 명칭으로 발표했다.
    
    스프링 클라우드: 스프링 부트 + 넷플릭스 OSS"
2023-04-28 18:09:41,"김용기","5일차
DDD MSA

- 

### 컨테이너 오케스트레이션

- 컨테이너의 자동 배치 및 복제, 장애 복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등의 컨테이너 관리를 위한 기능. 컨테이너 오케스트레이션은 다음과 같은 기능을 지원한다.
    - 자동화된 자원 배정 : 각 컨테이너가 필요로 하는 CPU와 메모리를 노드에 맞춰 자동으로 배치한다.
    - 자가 치유 : 컨테이너의 이상 유무를 점검하여 자동으로 교체하낟.
    - 수평 확장 : 사용량에 따라 자동으로 확장한다.

## 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

- 마이크로서비스를 하나하나 수동으로 빌드하고 배포한다면 비효율적이기 때문에 자동화하는 것이 중요하다.

### 개발 지원 환경 : 데브옵스 인프라 구성

- 여러 개의 마이크로 서비스를 배포해야 하는 환경에서는 배포가 잦을 수 밖에 없기때문에 자동화가 절실하다.
- 빌드를 매일 자동화하여 수행한다면 개발 생산성이나 소스코드 품질이 높아진다.(CI : 지속적 통합)
- CD는 지속적 제공과 지속적 배포를 의미하며, 지속적 제공은 빌드된 소스코드의 실행 파일을 실행 환경에 반영하기 전 단계까지 진행하는 방식이다. 지속적 배포는 소스코드 저장소에서 빌드한 소스코드의 실행 파일을 싱행 환경까지 자동으로 배ㅗ하는 방식을 말한다.

### 빌드/배포 파이프라인 설계

- 빌드/배포되는 과정 동안 수행해야할 태스크가 정의된 것을 빌드/배포 파이프라인이라고 한다.
- 빌드/배포 파이프라인은 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말한다.
- Infrastructure as Code를 이요하면 배포 파이프라인 절차를 완벽하게 자동화할 수 있으며, 대규모 인프라 관리를 수행할 수 있고 코드이기때문에 쉽게 공유 및 재사용이 가능하다.

### 마이크로 서비스 생태계와 운영 관리 요소의 탄생

- 마이크로 서비스에서는 한 서비스에서 발생한 장애가 다른 서비스로 전파되거나, 분산된 로그를 관리해야 하는 불편함, 시스템의 일부 기능이 동작하지 않아도 탐지하지 못한 채로 방치되는 문제가 발생할 수 있다.

### 스프링 클라우드 : 스프링 부트 + 넷플릭스 OSS

- 스프링 클라우드를 기반으로 한 아키텍처 구성
1. 모든 마이크로 서비스는 인프라에 종속되지 않도록 활경 설정 정보를 Config 서비스에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩된다.
2. 로딩과 동시에 서비스 레지스트리에서 자신의 서비스명과 클라우드 인프라부터 할당받은 물리 주소를 매핑해서 등록한다.
3. API 게이트웨이는 라우팅 및 로드 밸런싱을 수행한다. 라우팅을 할 때 서비스 레지스트리에서 서비스의 위치를 가져온다. 또한 인증/인가 처리도 수행한다.
4. 모든 마이크로서비스 간의 호출 흐름은 모니터링 서비스와 추적 서비스에 의해 모니터링되고 추적된다."
2023-04-28 19:58:54,"호02","5일차 제출

[초전 설득]

1. 요약 
 - 관심이 모아질 수록 사람들의 시선이 쏠리고, 시선이 쏠리는 곳에 힘이 실린다.
 - 아젠다 설정 : 언론에서 사용하는 주요 전략, 설득하고자 하는 주제를 다른 주제보다 훨씬 많이 보도함으로써 사람들이 중요하게 여기도록 간접적으로 전달하는 방식
 -  본능적으로 어둠 속에서 들리는 소리에 집중이 잘 되듯이 순간적으로 집중되는 상황을 특별하게 생각하는 건 당연한 현상일지도 모른다.
 

2. 메모
 - 정치인, 연예인들이 무관심보다 악플이 낫다고 하는 게 이런 이유에서인지도 모르겠다.
 - 하지만 악플을 견디려면 뻔뻔함이 같이 공존해야할 거 같다."
2023-04-28 20:29:58,"강민규","여러분 다들 즐거운 금요일 보내고 계신가요? 이번 주도 다들 고생 많으셨습니다~~ 오늘은 5일차입니다!

@Hailey 박정현 @수정 @한종우 님은 4, 5일차 같이 업로드해주세요!!"
2023-04-28 21:29:57,"이소민","5일차 제출

[헤드퍼스트 디자인패턴]

📍요약
옵저버 패턴은 신문 구독 서비스에 비유하여 이해하면 쉽다. 신문사가 있고 구독자가 있을 때, 신문사에서 신문을 찍어낼 때마다 구독자는 그대로 내용을 전달 받는다. 주제가 되는 신문의 내용을 다수의 옵저버(구독자)가 그대로 소식 받게 되는 형식을 말한다.

📍발췌
옵저버 객체들은 주제를 구독하고 있으며 (주제 객체에 등록되어 있으며) 주제 데이터가 바뀌면 갱신 내용을 전달받습니다.

📍메모
옵저버 패턴은 들어보기만 했지 개념을 익히게 된건 처음이다! 책에서 간단 명료하게 소개를 시작해서 앞으로 학습하기에도 쉽게 다가올 것 같다"
2023-04-28 22:23:30,"한종우","4일차

[헤드퍼스트 디자인 패턴]

### 동적으로 행동 지정하기

- 실행중에 어떤 행동을 변경하고 싶다면 원하는 행동에 해당하는 객체의 세터 메서드를 호출하면 된다

### 두 클래스를 합치는 방법

- 두 클래스를 합치는 것을 구성이라고 한다
- 구성을 활용하면 시스템의 유연성을 향상시킬 수 있다
- 변하는 부분을 별도의 클래스 집합으로 캡슐화할 수 있으며 구성 요소를 사용하는 객체에서 올바른 인터페이스를 구현하기만 하면 실행 시에 행동을 바꿀 수도 있다

### 첫번째 디자인 패턴: 전략 패턴

- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다
- 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다

### 디자인 패턴 만나기

- 공통으로 아는 전문 용어를 사용하면 의사소통하기 쉬워지고 불필요한 오해/소통을 줄여 작업을 빠르게 진행할 수 있다

### 디자인 패턴 사용법

- 프레임워크와 라이브러리는 유지보수하기 쉬운 애플리케이션의 구조를 만드는데는 도움을 주지 못한다. 이 부분을 디자인 패턴이 도와줄 수 있다
- 패턴이 코드를 바로 제공하는 것은 아니다. 디자인 문제의 보편적인 해법을 제공하는 것이다. 따라서 특정 애플리케이션에 패턴을 적용하는 일은 내가 해야하는 일이다.
- 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공한다. 많은 경우 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 한다.

## 발췌

- 추상화나 상속, 다형성 같은 개념을 알고 있다고 해서 무조건 훌륭한 객체지향 디자이너가 될 수 있는 건 아니에요. 디자인 전문가라면 관리하기 쉽고 상황에 맞게 변경할 수 있는 유연한 디자인을 만드는 일을 생각해 봐야 하죠"
2023-04-28 22:23:42,"한종우","5일차

[헤드퍼스트 디자인 패턴]

## Chapter 02. 옵저버 패턴

뭔가 중요한 일이 일어났을 때 겍체에게 새 소식을 알려 줄 수 있는 패턴

### 구현 목표

- 소프트웨어 개발에서 바뀌지 않는 단 하나는 변화이다. 확장성있게 개발해야 한다.

### 옵저버 패턴 이해하기

- 옵저버 패턴은 신문이나 잡지를 구독하는 것과 동일하다
- 신문사(주제, Subject) + 구독자(옵저버, observer) = 옵저버 패턴
- 주제에서는 중요한 데이터를 관리한다.
- 주제 데이터가 변경되면 옵저버에게 그 소식을 전한다
- 옵저버 객체들은 주제를 구독하고 있으며 주제 데이터가 변경되면 갱신 내용을 전달 받는다
- 구독을 신청/해지는 주제에게 요청한다"
2023-04-28 22:31:29,"수정","4일차
[헤드퍼스트 디자인 패턴]

# 요약
- **전략패턴** - 알고리즘(행동) 그룹을 정의하고 캡슐화해서, 클라이언트(오리)로 부터 알고리즘(날기, 울기)을 분리해서 변경할 수 있다
- 개발자들끼리 패턴으로 이야기하면, 일상용어로 구구절절 풀어서 설명하지 않아도 되고 오해의 여지가 줄어 더 효율적으로 의사소통이 가능하다

# 발췌
- 바뀌는 부분을 골라내어 캡슐화한다
- 상속보다는 구성(두 클래스를 합치는 것)을 활용하자
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다"
2023-04-28 22:31:58,"수정","5일차
[헤드퍼스트 디자인 패턴]

# 요약
- 기상 관측 어플리케이션 만들기
    - 관측값이 변경될 때마다 3가지 뷰를 업데이트하도록 변경하기
    - 이후에 새로운 뷰가 추가될 가능성을 고려한다(확장성)
- 옵저버 패턴: 주제 - 옵저버(신문사 - 독자)
    - 주제 객체에서 데이터를 관리한다
    - 옵저버는 주제 객체를 구독한다 (주제 객체에 등록되어 있다)
    - 데이터가 변경되면 옵저버에게 알려진다
    - 바뀐 데이터가 옵저버에게 전달된다
    - 옵저버 등록/탈퇴가 가능하다"
2023-04-28 22:48:38,"김연정","5일차
초천설득(~초점화된주의의대가)

요약
바람직한 설문 조사는 “~에 만족합니까 아니면 불만족합니까” 처럼 양방향

특권을 받는 질문: 
설문조사요청할 때 “당신은 남을 잘 돕는 사람인가요?” 로 시작하면 응답률이 높아짐
 “당신은 모험을 즐기고, 도전적인 사람인가요?”라는 오프너로 신제품에 대한 소비자의 개방적인 태도를 이끌어낼 수 있음

메모
내가 원하는 상대방의 상태나 성격을 생각한 뒤, 싱글슈트 질문을 먼저 던지면 협상 전 유리한 포지션을 가질 수 있다.
"
2023-04-28 23:07:17,"강민규","정현님 하고 계시지요? 내일 8시까지입니다~"
2023-04-29 00:37:40,"최다봄","5일차

[헤드퍼스트 디자인 패턴]

### 요약

**CHAPTER 02: 객체들에게 연락 돌리기 - 옵저버 패턴**

**[옵저버 패턴의 작동 원리]**

- **신문사 (주제, subject) + 구독자 (옵저버 observer) = 옵저버 패턴**
    - 주제에서 중요한 데이터를 관리합니다.
    - 주제 데이터가 바뀌면 옵저버에게 그 소식이 전해집니다.
    - 데이터가 바뀌면 새로운 데이터 값이 어떤 방법으로든 옵저버에게 전달됩니다.
    - 옵저버 객체들은 주제를 구독하고 있으며 (주제 객체에 등록되어 있으며) 주제 데이터가 바뀌면 갱신 내용을 전달받습니다.
    - **옵저버**는 구독자이기 때문에 구독하면 들을 수 있고, 해지하면 들을 수 없다.
        
        즉, **주제에게 구독 or 해지 요청할 수 있다.** 
        

### 발췌

(p.77) 미래를 생각해 봅시다. 소프트웨어 개발에서 바뀌지 않는 단 하나를 기억하고 있나요? 맞아요, **변화**입니다. (변화를 대비한 **확장성** 고려)"
2023-04-29 01:34:01,"박소환","삭제된 메시지입니다."
2023-04-29 01:34:19,"박소환","5일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/72"
2023-04-29 01:48:14,"이찬영","5일차

헤드퍼스트 디자인패턴 [금요일] 

70-86pg

# 요약

### **CHAPTER 02. 객체들에게 연락돌리기 (feat. 옵저버 패턴)**

옵저버 패턴 : 뭔가 중요한 일이 일어났을 때 객체에게 새 소식을 알려 줄 수 있는 패턴!

Story…

차세대 인터넷 기반 기상 스테이션 구축 프로젝트

WeatherData 객체를 바탕으로 기상 스테이션을 만들 예정

WeatherData 객체는 현재 기상조건을 추적한다. 

표시할 3개의 항목 : 현재 조건, 기상 통계, 간단한 기상 예보

→ 위 항목 모두 WeatheData에서 최신 측정치를 수집할 때마다 실시간으로 갱신 됨.

타 개발자가 새로운 날씨 디스플레이를 쉽게 추가할 수 있도록 해야함.

[ 기상 모니터 애플리케이션 ] 

1. 기상 스테이션 : 실제 기상정보를 수집하는 물리 장비
2. WeatherData 객체 : 기상 스테이션으로부터 오는 정보를 추적하는 객체
3. 디스플레이 장비 : 사용자에게 현재 기상조건을 보여주는 디스플레이 장비

→ 1,2는 weather-O-Roma에서 제공, 3은 우리가 구현

→ WeatherData객체와 디스플레이를 통합하는 작업도 우리가

---

WeatherData 클래스 살펴보기.

: 기상 스테이션에서 갱신된 정보를 가졍는 일은 weatherData 객체가 알아서 해준다는 점 알기.

: weatherData에서 갱신된 값을 가져올 때마다 measurementsChanged() 메소드가 호출된다는 점 기억하기.

기능을 구현하기 위해 우리가 해야할 목표 정하기

** 소프트웨어 개발에서 바뀌지 않는 단 하나 : 변화!

나중에 기상 스테이션이 더 발전하면 디스플레이가 더 늘어날 수도 있으니 ‘확장 기능’을 추가해보자.

→ 확장성


- 구체적인 구현에 맞춰서 코딩했으므로 디스플레이 항목을 추가하거나 제거할 수 없다.
- update() 메소드를 가지고 있으니 공통 인터페이스를 사용하긴 한다.

---

옵저버 패턴 이해하기 : 신문 구독

신문사 + 구독자 = 옵저버 패턴

신문사는 주제(subject), 구독자는 옵저버(observer)



# 발췌

💡 옵저버 패턴 : 뭔가 중요한 일이 일어났을 때 객체에게 새 소식을 알려 줄 수 있는 패턴!
신문사 + 구독자 = 옵저버 패턴


# 메모

코드를 하나하나 보면서 생각해볼 수 있어서 좋다. 
인터페이스,  캡슐화 등에 대해 했는지 안했는지 체크 할 수 있어서 복습해서 좋다."
2023-04-29 07:39:23,"Hailey 박정현","4,5일차
[데이터 중심 애플리케이션 설계]
https://www.notion.so/haileypark/4-5-c2e44ea56ab6499ca0fb6b013e4c423a?pvs=4"
2023-04-29 07:39:53,"Hailey 박정현","아파서 연차 내고 이틀 내내 계속 잤어요 ㅠ 늦게 제출 죄송합니다"
2023-04-29 07:42:04,"강민규","사진"
2023-04-29 07:43:17,"강민규","여러분 즐거운 주말이네요~ 비도 오고 날씨도 쌀쌀한데 감기걸리지 않게 조심해요 우리~"
2023-04-29 16:38:32,"이찬영","6일차

헤드퍼스트 디자인패턴 [토요일] 

87-101pg

# 요약

### **CHAPTER 02. 객체들에게 연락돌리기 (feat. 옵저버 패턴)**

옵저버 패턴 : 뭔가 중요한 일이 일어났을 때 객체에게 새 소식을 알려 줄 수 있는 패턴!

옵저버 패턴 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.

옵저버 패턴의 구조(옵저버 패턴의 클래스 다이어그램)
- Subject 인터페이스
- ConcreteSubject(구상 클래스)
- Observer 인터페이스
- ConcreteObserver

객체들의 느슨한 결합(Loose Coupling) : 

객체들이 상호작용할 수 있지만, 서로를 잘 모르는 관계. → 유연성이 좋아짐.

옵저버 패턴은 느슨한 결합의 대표 예시.

1. 주제는 옵저버가 특정 인터페이스(observer intrerface)를 구현한다는 사실만 압니다.
2. 옵저버는 언제든지 새로 추가 가능. : 주제는 observer interface를 구현하는 객체의 목록에만 의존하기 때문에.
3. 새로운 형식의 옵저버를 추가해도 주제 변경 할 필요 없음.
4. 주제와 옵저버는 서로 독립적으로 재사용 가능
5. 주제나 옵저버가 달라져도 서로에게 영향 없음.

디자인 원칙 : 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.

---

라이브러리 속 옵저버 패턴 : 스윙 라이브러리에서의 옵저버 패턴 활용

# 발췌

💡 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.


💡 옵저버 패턴의 구조(옵저버 패턴의 클래스 다이어그램)

- Subject 인터페이스 : 주제, 옵저버 등록, 탈퇴 담당
- ConcreteSubject(구상 클래스) : 주제 역할, subject 인터페이스 구현, 옵저버 등록 및 해지, 상태 바뀔 때 마다 옵저버에게 연락
- Observer 인터페이스 : 옵저버가 될 가능성이 있는 객체는 꼭 observer 인터페이스를 구현해야 한다.
- ConcreteObserver : observer 인터페이스만 구현하면 무엇이든 옵저버 클래스가 될 수 있다.


# 메모

코드를 직접 쳐보니까 옵저버 패턴의 구조가 눈에 들어오는 듯 하다."
2023-04-29 18:49:36,"호02","6일차 제출

[초전 설득]

1. 요약 
 - 주의를 전환시키는 방법 중 하는 배경 환경을 이용하라는 것이다.
 - 가구 웹사이트에 구름 배경을 넣었을 때는 고객이 편안한 가구에 더 관심을 가진 반면, 동전 배경을 넣었을 때는 저렴한 가구에 관심을 더 가졌다.
 - 반복적으로 노출되는 온라인 배너 광고는 브랜드에 대한 호감도를 높인다. 왜냐하면 배너 광고를 애초에 관심있게 보지 않기 때문이라고 한다.
 - 온라인 배너 광고가 오히려 제품에 대한 흥미를 떨어뜨린다는 연구 결과와는 정반대의 결과이다. 

2. 메모
 - 나도 모르게 필요하다고 생각한 제품들이 배너에 의한 영향일 수도 있겠다는 생각이 든다."
2023-04-29 19:11:32,"송예은","6일차
ddd, msa

### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

- 서비스 디스커버리 패턴
    
    클라이언트가 여러 개의 마이크로서비스를 호출하기 위해 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드 밸런싱 기능이 제공돼야 한다.
    
    넷플릭스 oss에서 라우팅 기능은 zuul, 로드밸런싱은 ribbon이 담당한다.
    
- 서비스 레지스트리 패턴
    
    라우터는 최적 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다. 이런 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경에서 동적으로 변경되는 유동 IP 정보를 매번 전송받아 변경해야 한다. 백엔드 마이크로서비스 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관할 저장소가 필요하다. 이렇게 분리한 것을 서비스 레지스트리 패턴이라 한다.
    
    넷플릭스 oss의 유레카가 이 기능을 담당한다.
    
- 쿠버네티스의 경우 서비스 레지스트리, 디스커버리 기능을 자체 기능인 쿠버네티스 DNS 및 쿠버네티스 서비스로 제공한다.

### 서비스 단일 진입을 위한 API 게이트웨이 패턴

- 다양한 클라이언트가 다양한 서비스에 접근하기 위해서는 단일 진입점을 만들어 놓으면 여러모로 효율적이다.
    
    다른 유형의 클라이언트에게 서로 다른 API 조합을 제공할 수도 있고, 각 서비스에 접근할 때 필요한 인증/인가 기능을 한 번에 처리할 수도 있다. 서비스 요청에 대한 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경하는 기능이 작동되게 할 수도 있다.
    
- 서비스 라우팅 기능은 L4 같은 하드웨어 장비로 구현할 수도 있지만, 소프트웨어로 구현할 경우 애플리케이션 레벨의 라우팅 기능을 수행한다. 또한 로드 밸런싱이나 필터를 둬서 선행 처리와 후행 처리, 에러 처리 등을 쉽게 구현할 수 있다.
- API 게이트웨이 패턴은 스프링 클라우드의 스프링 API 게이트웨이 서비스로 쉽게 구현할 수 있다.

### BFF 패턴

- BFF 패턴은 API 게이트웨이와 같은 진입점을 하나로 두지 않고 프런트엔드 유형에 따라 각각 두는 패턴이다.
- 웹용 API 게이트웨이, 모바일용 API 게이트웨이 등 클라이언트 종류에 따라 최적화된 처리를 할 수 있게 구성 가능하다.
- 각 프런트엔드에 대한 처리만 수행하는 BFF를 두고 이후에 통합적인 API 게이트웨이를 둠으로써 공통적인 인증/인가, 로깅 등의 처리를 통제하는 구조로 구성할 수도 있다.

### 외부 구성 저장소 패턴

- 컨피그 원칙
    
    애플리케이션이 배포되는 환경이 매번 달라지기 때문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다.
    
    클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안된다.
    
- 분리해야 할 환경 정보로는 DB 연결 정보, 배포 시 변경해야 할 호스트명, 백엔드 서비스 연결을 위한 리소스 정보 등이 있다.
- 스프링 클라우드 컨피그
    
    이런 환경 정보를 코드에서 분리하고 컨피그 서비스를 통해 런타임 시 주입되게 한다. 환경 정보는 git같은 별도 형상관리 리포지토리에 보관하고 컨피그 서비스는 해당 서비스에 특정 환경에 배포될 때 적절한 환경 정보를 형상관리 리포지토리에서 가져와 해당 서비스에 주입한다.
    
- 쿠버네티스에서는 이런 외부 구성 저장소 패턴을 쿠버네티스 컨피그맵으로 제공한다.

### 인증/인가 패턴

- 각 서비스가 모두 인증/인가를 하는 것은 비효율적이다. 마이크로서비스에서 인증/인가를 처리하기 위해서는 다음과 같은 패턴을 사용한다.
    - 중앙 집중식 세션 관리
        
        공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 한다. 이때 세션 저장소로는 보통 레디스나 멤캐시드를 사용한다.
        
    - 클라이언트 토큰
        
        JWT와 같은 클라이언트 토큰을 사용한다.
        
        1. 브라우저가 서버에 사용자명, 패스워드로 인증 요청
        2. 서버는 인증 후 토큰 생성하고 브라우저에 토큰에 인증/인가 정보를 포함하여 전송
        3. 브라우저는 서버에 요청할 때 토큰을 함께 보내어 서버는 토큰 정보를 확인함
    - API 게이트웨이를 사용한 클라이언트 토큰
        
        토큰 인증 프로세스와 유사하지만 API 게이트웨이가 외부 요청의 입구로 추가된다.
        
        인증/인가를 처리하기 위한 별도의 전담 서비스를 만들어서 다른 서비스의 인증/인가 처리를 위임할 수 있다."
2023-04-29 20:58:41,"강민규","여러분~ 좋은 주말 보내고 계신가요? 토요일 분량은 월요일 아침 8시에 체크하니 스케줄에 참조 부탁드립니다~ "
2023-04-29 21:09:02,"김연정","6일차
초전설득(3장전까지)

요약
우리는 한 가지에만 주의를 기울일 수 있다. 상대방의 주의를 무언가에 집중시키면 그것이 중요한 것이라고 생각하게 된다. 
예시: 의사가 큰 소음 아래 환자에게 주의점을 말해서 몸을 기울이게 만들고 주의를 집중시키는 것.

메모
없음"
2023-04-29 21:13:34,"김연정","저랑 내용이 다른 것 같은데 혹시 개정판으로 읽고 계신건가요!!?"
2023-04-29 21:19:46,"호02","삭제된 메시지입니다."
2023-04-29 21:20:04,"호02","아 제가 온라인으로 사서 읽고 있는데, 페이지 수가 좀 다른가보네요(글자수를 조정해서 보든가 해야겠네요) . 최대한 같은 범위의 내용이 제출되도록 해볼게요. "
2023-04-29 21:27:13,"김연정","아 그렇군요! 쏘이님도 이북 읽고 계시다고 하셔서 제가 끝나는 부분 일요일에 공유하겠습니다. "
2023-04-29 21:27:18,"김연정","초전설득 2주차 

7일차  ~주의를 전환 시키는 방법들
8일차 ~한가지에만 집중 시켜 긍정적 평가를 유도하라.
9일차 ~임무를 바꿔라
10일차 ~ 4장전까지
11일차 ~ 4장시작부터 거짓말탐지기대화내용
12일차 ~밀러의이야기"
2023-04-29 21:27:36,"김연정","참고해서 같이 읽으면 좋겠습니다아~"
2023-04-29 21:42:42,"호02","네, 공유 감사합니다아~ "
2023-04-29 22:03:21,"김용기","6일차
ddd, msa 

### 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴

- 클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드 밸런싱 기능을 제공한다.
- 서비스 레지스트리는 백엔드 마이크로서비스의 서비스 명칭과 유동적인 IP 정보를 매핑해서 보관한다.

### 서비스 단일 진입을 위한 API 게이트웨이 패턴

- 다양한 클라이언트가 다양한 서비스에 접근하기 위해서 단일 진입점을 만든 패턴
- 다른 유형의 클라이언트에게 서로 다른 API 조합을 제공할 수 있다.
- 필요한 인증/인가 기능을 한 번에 처리할 수 있다.
- 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경할 수 있다.
- 로드 밸런싱을 수행한다.
- 라우팅 전과 후에 각각 수행되는 선행 처리와 후행 처리, 에러 처리 등을 손쉽게 구현할 수 있다.
- 외부 레거시 시스템과 단일 지저메서 서로 다른 형태의 API를 연계하는 용도로 사용되기도 한다.

### BFF (Backend For Forntend)패턴

- 다양한 클라이언트를 위해 특화된 처리를 위한 API 조합이나 처리
- API 게이트웨이처럼 진입점을 하나로 두지 않고 프론트엔드의 유형에 따라 각각의 진입점을 두는 패턴이다. 클라이언트 종류에 따라 최적화된 처리를 수행할 수 있게 구성할 수 있다.

### 외부 구성 저장소 패턴

- 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 백업 저장소를 두는 패턴
- 컨피그 원칙에 기반한다. (클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안된다는 원칙)

### 인증/인가 패턴

- 중앙 집중식 세션 관리 : 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 한다.
- 클라리언트 토큰 : 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장된다.
- API 게이트웨이를 사용한 클라이언트 토큰 : 사용자 인증 프로세스는 토큰 인증 프로세스와 유사하다. 차이점은 API 게이트웨이가 외부 요청의 입구로 추가된다는 것이다. 인증/인가를 처리하기 위한 별도의 전담 서비스를만들어서 다른 서비스의 인증/인가 처리를 위임할 수 있다."
2023-04-29 22:49:29,"이소민","6일차 제출

[헤드퍼스트 디자인패턴]

📍요약

옵저버 패턴은 일대다 의존성을 가진다. 주제가 되는 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들도 상태가 자동으로 바뀐다. 이때 주제는 옵저버의 구상 클래스가 어떤 것인지 전혀 알 필요가 없는 느슨한 결합 형태를 띈다. 그렇기 때문에 변경에 유연하다는 장점이 있다. 옵저버 패턴은 이미 많은 라이브러리와 프레임워크에서 볼 수 있다.

📍발췌
상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.

📍메모
갱신된 상태를 옵저버에게 전달하는 문제를 해결할 수 있는 방법에는 뭐가 있을까..? 측정치를 계산해주는 함수를 쓰는 방법? 어떤게 더욱 효율적인 방법인지는 좀 더 생각해봐야겠다.."
2023-04-29 23:31:55,"최윤지","5일차
[7가지코드]

https://quiet-jade-e60.notion.site/5-0428-2473afb43b2c42b29deedbb407ab1523"
2023-04-30 06:27:15,"궈노","5일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_5_70-86.md"
2023-04-30 06:27:40,"궈노","6일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_1/day_6_87-101.md"
2023-04-30 09:14:26,"뚯뚜오","6일차
총균쇠

요약
빙하기동안 베링해협을 도보로 건너와 알래스카에서 버티고 살던 인류.
빙하기가 끝나고 캐나다 만년빙이 녹아 미국의 대평원으로 연결되는 기적을 만나게 되어 아메리카대륙에도 인류의 발길이 닿음. 그와 동시에 아메리카대륙에 살던 여러 대형 포유류 동물들이 멸종됨. 기후학자들 중 일부는 빙하기가 끝나는 시점에 환경의 변화로 동물들이 멸종되었다 주장하기도 하나, 어째서 22번의 빙하기 이후를 겪은 동물들이 23번째 빙하기 이후는 버티지 못했는가? 23번째 빙하기의 끝은 공교롭게도 사람의 발길이 닿은 순간과 일치했다.

인류 문명의 발전 과정에 있어 이른 출발이 중요한가? 만약 그렇다면 어째서 인류의 발원지인 아프리카는 지금 뒤쳐지게 되었는가?
(1장 문명이 싹트기 직전의 세계 상황 끝)


같은 부족에서 갈라져 나온 마오리족 모리오리족의 사회실험
(2장 환경 차이가 다양화를 빚어낸 모델 폴리네시아)


발췌

남보다 '먼저 출발' 한다는 것은 어떤 의미를 지닐까?
그렇다면 각 대륙에 인간이 살기 시작한 시기가 제각기 달랐던 것은 그 이후의 역사에서 어떤 의미를 가질까? 어느 고고학자가 타임머신을 타고 B.C. 11,000년 경으로 시간을 거슬러 올라가서 세계 여행을 했다고 가정해보자. 당시 세계 상황을 고려할 때, 과연 그 고고학자는 각 대륙의 인간 사회에서 총기, 병원균, 쇠 등을 발달시키는 순서와 오늘날의 세계적 상황을 예측할 수 있었을까?
...
마오리족과 모리오리족의 충돌을 더욱 소름끼치게 만드는 것은 두 집단이 모두 1,000년 경에 뉴질랜드로 이주했던 폴리네시아 농경민의 후손이라는 점이다. 그로부터 머지않아 마오리족의 한 무리가 다시 채텀 제도로 이주하여 모리오리 족이 되었던 것이다. 두 집단은 헤어진 후 몇 세기에 걸쳐 서로 반대 방향으로 발전했다. 북섬의 마오리족은 점점 더 복잡한 기술과 정치적 조직을 발달시켰고 모리오리족은 오히려 점점 더 단순한 기술과 정치적 조직으로 후퇴했다. 모리오리족이 수렵 채집민으로 되돌아가는 동안 북섬의 마오리족은 더욱 집약적인 농업에 매달렸다. 그와 같은 정반대의 전개 과정이 결국 충돌 결과를 결정했다. 만약 이 두 섬의 사회가 각기 차등적으로 발전한 원인들을 이해할 수만 있다면 우리는 더 폭넓은 문제, 즉 각 대륙의 발전 양상이 서로 달랐던 이유를 이해하기 위한 하나의 모델을 얻게 될 것이다."
2023-04-30 09:48:22,"Bo","6일차
헤드퍼스트 

### 요약

> 옵저버 패턴 정의
> 
- 아래 발췌 참고

> 옵저버 패턴 구현
> 
구현은 여러 방식으로 될 수 있지만, 여기서는 일반적인 주제 인터페이스와 옵저버 인터페이스로 구현하는 방식을 택했다
- Subject 와 Observer 의 인터페이스로 나눠 구현하는 방식
    - Subject 의 구현 클래스 ( WeatherData ) 는 자신을 구독하는 Observer 들을 리스트로 가져 관리 (추가 / 삭제 ) 하고 변경이 있을 때 이를 이용해 노티 를 보낸다
    - Observer 인터페이스를 구현한 어떤 클래스도 Observer 과 되어 Subject 를 구독할 수 있다.
        - Observer 들은 Subject 의 노티를 받을 수 있는 메서드가 있다 ( Observer 인터페이스에 update() 메소드)
        - Display 성질은 Observer 에 녹이지 않고, 다른 인터페이스로 분리 ( DisplyElement )

> 옵저버 패턴과 출판 - 구독 (publish - subscribe ) 패턴
> 
- 두 패턴은 다르다. 출판-구독 패턴에서는 구독자가 서로 다른 여러 개의 메시지에 관심을 가질 수 있고 ( 옵저버 패턴에서 말하는 일대다 의존관계가 아닌 것으로 이해) 출판과 구독자를 더 세세하게 구분할 수 있다

> 느슨한 결합 Loose Coupling
> 
- 의존은 하되 의존하는 객체에 대해 세세하게 몰라도 되는 결합
    - 유연한 시스템 구축 가능 : 세부사항에 의존하지 않기 때문에 세부 사항이 바뀌어도 다른 대상에게 영향을 안 주는 것이라고 이해했다
- 옵저버 패턴은 느슨한 결합의 예
    - 옵저버의 세세한 구상 클래스를 Subject 는 모른다
    - 옵저버 변경 / 추가 / 삭제해도 Subject 의 코드 변경할 필요 없음

### 발췌

> 옵저버 패턴
> 
- 한 객체의 상태가 바뀌면, 그 객체에 의존하는 다른 객체에게 연락이 가고, 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다

### 메모

- 옵저버 패턴과 출판-구독 패턴을 비슷한 것으로 이해하고 있었는데 다르다고 한다."
2023-04-30 13:00:23,"수정","6일차
헤드퍼스트 디자인패턴

# 요약
- 느슨한 결합
    - : 객체들이 상호작용할 수는 있지만 서로 잘 모르는 관계
- 주제는 옵저버 인터페이스를 제외하고는 옵저버에 대해 모른다
- 옵저버 클래스는 같은 옵저버 인터페이스를 사용해 주제에게서 상태를 전달받는 방법을 통일한다
- 옵저버는 주제가 연락을 주기 전까지 변경된 상태를 알 수 없다(옵저버의 의존성)
- 옵저버가 추가되거나 제거되어도 주제에 영향을 미치지 않는다(주제의 독립성)

# 발췌
- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다
- 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다
    - (notifyObservers()안에서 모든 옵저버들의 update()함수 호출)"
2023-04-30 16:44:00,"최다봄","6일차

[헤드퍼스트 디자인 패턴]

### 요약

**CHAPTER 02: 객체들에게 연락 돌리기 - 옵저버 패턴**

**[옵저버 패턴]**

한 객체 상태가 바뀌면 그 객체에 의존하는 다른 객체에 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 가진다.

**[느스한 결합(Loose Coupling)]**

객체들이 상호작용할 수 있지만, 서로를 잘 모르는 관계를 말한다.

- 옵저버의 의존성: 옵저버는 주제가 연락을 주기 전까지 변경된 상태를 알 수 없다.
- 주제의 독립성: 옵저버가 추가되거나 제거되어도 주제에 영향을 미치지 않는다."
2023-04-30 17:13:49,"박소환","6일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/73"
2023-04-30 20:36:24,"강민규","좋은 주말 보내고계신가요? 주말 분량을 안하신 분들이 많네요~ 하루 결석한채로 진행되면 스트레스도 많이 받고 예상치 못한 스케줄 변동에 매우 취약해지니 시간 많을때 빠르게 분량을 다 채워봅시다~

@김성태 @최희윤 @리경 @김형우 
선생님들은 금요일 분량부터 확인이 되지 않네요~ 이틀치 분량으로 제출 바랍니다!"
2023-04-30 21:47:42,"최윤지","6일차
[7가지코드]

https://quiet-jade-e60.notion.site/6-0429-f65151bc5e8f4147a565e715a9198590"
2023-04-30 22:47:36,"Hailey 박정현","저 지금 병행 하고있는 게 너무 많아서 끝까지 계속 할 수 없을 것 같아요 ㅠ 제가 너무 욕심을 부렸나봅니다
다음 기수 모집 때 다시 알림 받을 수 있을까요? 병행하고 있는 일들이 많지 않을 때에 다시 참여해서 그때는 꼭 끝까지 완주하도록 하겠습니다! 
죄송합니다...! 민규님 고생이 많으셔요
다른 분들도 꼭 끝까지 완주하시길 바랄게요! 💪🏽💪🏽💪🏽💪🏽💪🏽"
2023-04-30 23:08:44,"리경","5일차
오브젝트

✨ 요약
#컴파일 시간 의존성과 실행 시간 의존성

코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있음. 즉, 클래스 사이 의존성과 객체 사이 의존성 동일하지 않을 수 있음.
유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체 지향 설계가 그러함.

그러나, 위와 같으면 코드 이해 및 디버깅 어려워짐. 코드 뿐 아니라 객체 생성하고 연결하는 부분 찾아야해서. 이와 같은 의존성의 양면성이 설계가 트레이드 오프의 산물이라는 것

훌륭한 객체 지향 설계자로 성장 위해 유연성과 가독성 사이 항상 고민해야함. 

자식 클래스가 부모 클래스 대신하는 것을 업캐스팅. 

#다형성

동일 메시지를 전송하나 실제로 어떤 메서드 실행될지 메시지 수신하는 객체의 클래스가 무엇이냐에 따라 다른 것이 다형성.

AmountDiscountPolicy와
PercentDiscountPolicy가
다형적 협력에 참여 가능한 건 동일 인터페이스를 물려받아서.

다형성 구현 방법 다양하나 메시지 응답 위한 실행 메서드를 컴파일 시점이 아닌 실행 시점에 결정하는 공통점. = 메시지와 메서드를 실행시점에 바인딩 = 지연 바인딩 = 동적 바인딩
<-> 정적 바인딩 = 컴파일 시점에 실행 함수, 프로시저 결덩


✨ 발췌
상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라. 상속을 통해 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지 수신할 수 있기에 외부 객체는 자식 클래스를 부모 클래스와 동일 타입으로 간주할 수 있다.

✨ 메모
- 다중성 (여러개의 인스턴스 허용 가능)
ex. Arrays.asList(conditions)
<-> = discountPolicy"
2023-04-30 23:29:44,"다운","6일차

사피엔스

요약
다른 사회적 동물들의 행태는 주로 유전자에 의해 결정되지만 사피엔스는 문화에 의해 결정된다. 사피엔스는 픽션을 창작할 능력과 변하는 외부의 도전에 맞게 자신들의 사회적 행태를 바꿔 적응할 수 있다.
인지혁명 이후에 역사가 생물학에서 독립을 선언했다. 사피엔스 행동을 이해하려면 이들이 역사적으로 진화해온 경로를 서술해야 한다.

발췌
가장 대표적인 예는 가톨릭 신부, 불교의 승려, 중국의 환관처럼 아이를 갖지 않는 엘리트라 계속 등장했던 것이다"
2023-05-01 05:41:33,"김형우","삭제된 메시지입니다."
2023-05-01 05:41:45,"김형우","[5일차]
https://engineer-diary.tistory.com/199"
2023-05-01 08:32:26,"Hailey 박정현","Hailey 박정현님이 나갔습니다."
2023-05-01 10:13:21,"강민규","사진"
2023-05-01 10:14:23,"강민규","안녕하세요 선생님들 좋은 휴일 보내고 계신가요? 최고네요.. 2주차가 탈락률이 가장 높은 주입니다! 이번 주만 잘넘기면 거의 그대로 가니까 힘내봐요~"
2023-05-01 12:37:58,"박소환","7일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/74"
2023-05-01 12:53:50,"송예은","7일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발

### 장애 및 실패 처리를 위한 서킷 브레이커 패턴

- 서킷 브레이커 패턴
    
    여러 서비스로 구성된 시스템에서 한 서비스에 장애가 발생했을 때 다른 서비스가 영향을 받지 않도록, 장애가 발생한 서비스를 격리해서 유연하게 처리할 수 있는 방법
    
- 서비스 상태를 실시간으로 관리해서 시각화, 모니터링하고, 특정 서비스에서 장애가 감지되면 장애가 다른 서비스로 전이되지 않게 하는 것을 전기회로 차단기와 비슷하다고 해서 서킷 브레이커 패턴이라고 한다.
- 설명
    
    A서비스가 B서비스를 호출해 서비스를 제공하는데, B서비스에서 장애가 발생하면 동기 요청의 성격상 A는 계속 기다린다. 그러면 A서비스까지 장애가 발생한 것처럼 사용자가 느낀다. 서킷 브레이커 패턴은 이 경우 B서비스 호출에 대한 연속 실패 횟수가 임곗값을 초과하면 회로 차단기가 작동해 이후 서비스를 호출하려는 모든 시도를 즉시 실패하게 만든다. 
    
    그리고 폴백 메서드를 지정해두면 장애가 발생했을 때 폴백 메서드가 자연스럽게 처리한다. 그러면 사용자는 장애가 발생했는지 눈치채치 못하고, 시간이 흘러 장애가 복구됐을 때 다시 호출을 정상화하면 된다.
    

### 모니터링과 추적 패턴

마이크로서비스에서는 실시간으로 장애를 감지하는 모니터링, 추적 패턴이 필요하다.

### 중앙화된 로그 집계 패턴

- 마이크로서비스에서는 사용량에 따라 탄력적으로 변하면서 인스턴스가 생성,삭제되는 과정에서 로컬 로그가 초기화될 수 있다.
- 로그를 이벤트 스트림으로 처리해야 한다. 서비스는 스트림의 전달이나 저장에 절대 관여하지 않아야 한다. → 그래서 필요한 것이 중앙화된 로그 집계 패턴이다.
- 서비스에서 발생한 이벤트 스트림 형태의 로그를 수집하고 살펴볼 도구가 필요한데, 대표적으로 ELK 를 많이 쓴다.
    - 엘라스틱서치 : 분석 엔진 (로그 인덱싱)
    - 로그 스태시 : 로그 집합기
    - 키바나 : 시각적으로 로그 내역을 보여주는 대시보드

### MSA 기술 변화 흐름

- MSA + Neflix oss == 1.0
- MSA + OpenShift  == 1.0, MSA + k8s == 2.0
- MSA + Istio == 3.0

### 서비스 메시 패턴

- 초창기 MSA 기술인 넷플릭스 oss나 스프링 클라우드 기반 서비스 구축 및 운용 시 문제점
    - 운영 관리를 위한 여러 개의 기반 서비스를 별도로 각각 만들어야 하는 번거로움
    - 업무 처리 MSA에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재해야 한다는 점
    - 스프링 클라우드는 자바 기반이므로 자바 외의 언어로 구현된 경우 사용할 수 없음
- 최근에는 MSA 문제 영역 해결을 위한 기능을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 서비스 메시 패턴이 선호되고 있다.
- 이스티오는 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴을 적용해서 서비스 디스커버리, 라우팅, 로드 밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다.
- 사이드카 패턴은 모든 서비스 컨테이너에 추가로 사이드카 컨테이너가 배포되는 패턴이다. 각 서비스를 연계할 때 한 서비스가 다른 서비스를 직접 호출하지 않고 사이드카인 프록시를 통해 연계해서 개발자가 별도의 작업 없이 관리 및 운영에 대한 서비스를 적용할 수 있다.
- 서비스 메시를 적용하는 경우, 마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 담겨있기 때문에 마이크로서비스는 순수 비즈니스 로직에 집중할 수 있다.
- 컨트롤 플레인 기능에 의해 중앙에서 통제되며, 사이드카끼리 통신해서 관련 운영 관리 기능을 제공한다.
- 쿠버네티스의 컨테이너 단위인 파드에 서비스 컨테이너와 사이드카 구현체인 엔보이 컨테이너가 함께 배포된다.
- 넷플릭스 oss나 스프링 클라우드 기반은 비즈니스 로직과 함께 코드로 표현돼야 하지만, 이스티오는 완전히 사이드카로 격리되며 yaml 파일과 같은 설정 파일에 의해 정의된다."
2023-05-01 13:05:53,"김용기","7일차
DDD MSA

### 장애 및 실패 처리를 위한 서킷 브레이커 패턴

- 특정 서비스에 문제가 생겼을 때 자연스럽게 다른 정상적인 서비스로 요청 흐름이 변경되게 한다.
- 서비스 상태를 항상 실시간으로 관리해서 시각화하고 모니터링할 수 있어야 한다.
- 서킷 브레이커 패턴은타 서비스 호출에 대한 연속 실패 횟수가 임곗값을 초과하면 회로 차단기가 작동해서 이후에 서비스를 호출하려는 모든 시도를 즉시 실패하게 만든다.
- 폴백 메서드를 지정하여 장애가 발생했을 때 폴백 메서드가 자연스럽게 처리를 진행하게 한다.

### 모니터링과 추적 패턴

- 모니터링과 함께 각 서비스 트랜잭션의 호출을 추적하면 마이크로 서비스 운영에 매우 적합하다.
- 각 API가 다른 API를 어떻게 호출하는지, 호출 시의 반응 시간이나 지연 구간, API호출 빈도 등을 확인할 수 있다

### 서비스 메시 패턴

- MSA 문제 영역 해결을 위한 기능 (서비스 탐색, 서킷 브레이크, 추적, 로드 밸런싱 등)을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 서비스 메시 패턴이 선호되고 있다.
- 서비스 메시를 적용하면 마이크로 서비스마다 함께 배포되는 사이드카 프록시에 운영 관리를 위한 기능이 별도로 담겨있기 때문에 마이크로 서비스는 순수 비즈니스 로직에 집중할 수 있다."
2023-05-01 14:28:13,"최희윤","6일차 DDD
https://charm-bearberry-5b7.notion.site/04-29-DDD-6-43cb650b119445eab82cb218d5c7383a"
2023-05-01 14:43:36,"최희윤","7일차 DDD
https://www.notion.so/05-01-DDD-7-3d26f166e7ec44d2a3974c66509ff7e9?pvs=4"
2023-05-01 16:52:14,"리경","6일차
오브젝트

✨ 요약
#추상 클래스와 인터페이스 트레이드오프
- 이상적으로는 인터페이스를 사용하도록 변경한 설계가 좋으나 현실적으로는 NoneDiscountPolicy만을 위해 인터페이스를 추가하는 것은 과함.

#코드의 재사용
합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법!
ex. movie가 disountPolicy 코드 재사용 하듯
public class Movie {
      public Money caculateMFee(S S){
           return fee.minus(discountPolicy.calculateDiscountAmount(S);
      }
}

#상속
상속이 캡슐화 위반, 설계를 유연하지 못하게함.
- 부모 클래스 내부 구조 잘 알고 있어야해서 -> 캡슐화 약화 -> 강한 결합 -> 변경 어려움
- 부모, 자식 클래스 관계 컴파일 시점에 결정 -> 실행 시점에 객체 종류 변경 불가 <-> 인스턴스 변수로 관계 연결한 설계가 더 유연(합성)

#협력
메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션. 메시지를 수신한 객체는 메서드 실행해 요청에 응답. 어떻게 처리할지는 수신 객체가 직접 결정하므로 자율적 존재 (=캡슐화) -> 결합도 느슨


✨ 발췌
- 합성은 인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 

- 대부분의 설계에서 상속과 합성 함께 사용해야 한다. 코드를 재사용하는 경우에는 상속보다 합성을 선호함이 옳으나 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수밖에 없다.

✨ 메모
- 추상화를 중심으로 코드와 구조를 설계하는 컨텍스트 독립성(8장)은 유연한 설계가 필수적 분야에서 진가 발휘한다."
2023-05-01 16:54:41,"쏘이쏘이양","6일차
초전설득 (5일차에 이 범위까지 적어버렸었네요ㅜ)

요약
주의의 초점을 바꾸는 데에도 합당한 값을 치러야 한다. 
정보 사이를 왔다갔다 할때마다 우리는 0.5초간 정신적 사각지대에 빠진다. 이를 주의과실이라 부른다. 순간적으로 새롭게 주목되는 정보에 대해 인지하지 못하게 되는 오류가 발생한다. 

메모
일할때도 많은 일들을 동시에 다루려고 하면 각 일 간에 집중하기위해 필요한 시간들이 있어서 너무 많은 일을 동시에 하기에는 낭비되는 시간이 많다고 느꼈었는데, 이런 용어가 따로 있다는 것을 알게되니 새롭다. "
2023-05-01 16:57:54,"한종우","6일차

[헤드퍼스트 디자인 패턴]

### 옵저버 패턴의 정의

- 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다

### 옵저버 패턴의 구조

- 옵저버 패턴은 보통 주제 인터페이스와 옵저버 인터페이스가 들어 있는 클래스 디자인으로 구현한다. 옵저버 패턴에서는 주제가 상태를 저장하고 제어한다. ㄷ따라서 상태가 들어있는 객체는 하나만 있을 수 있다. 그러나 옵저버는 상태를 사용하지만 반드시 소유할 필요가 없어 여러개가 있을 수 있으며 주제에 의존적인 성질을 가진다

### 느슨한 결합의 위력

- 느슨하게 결합하는 디자인을 사용하면 객체 사이의 상호 의존성을 최소화할 수 있기 때문에 변경 사항이 생겨도 유연한 객체지향 시스템을 구축할 수 있다

### 라이브러리 속 옵저버 패턴 알아보기

- JDK의 자바빈, 스윙 라이브러리, 자바스크립트의 이벤트, 스위프트의 기-값 옵저빙 프로토콜 등에서 옵저버 패턴이 사용된다.
- 디자인 패턴을 배우면 라이브러리가 설계된 원리와 동기를 쉽고 빠르게 이해할 수 있다"
2023-05-01 16:58:04,"한종우","7일차

[헤드퍼스트 디자인 패턴]

### Q&A

- 자바의 Observable 클래스도 비슷한 기능을 제공하지 않나요?
    - 자신의 코드에서 기본적인 옵저버 패턴을 지원하는 것이 더 편한 사람, 더 강력한 기능을 스스로 구현하는 것이 낫겠다고 생각하는 사람들이 늘어나면서 자바 9 이후로 쓰이지 않는다
- 주제에서 옵저버로 가는 순서를 정해야 할까?
    - Observer의 알림 순서에 의존하지 말라는 JDK 권고가 있었다

### 풀 방식으로 코드 바꾸기

- 옵저버 방식의 구현 방법에는 주제가 옵저버로 데이터를 보내는 Push 방법과 옵저버가 주제로부터 데이터를 가져오는 Pull 방법이 있다. 시간이 지남에 따라 애플리케이션은 변경되고 더 복잡해지기 때문에 쉽게 확장 가능한 애플리케이션을 구축해야 한다. 일반적으로는 Pull 방식이 더 옳은 방식이라고 한다.
- 주제는 자신의 데이터에 대한 게터 메서드를 가지게 만들고 옵저버가 필요한 데이터를 당겨올때 해당 메소드를 호출하는 방식으로 구현하면 된다

### 옵저버 패턴에서의 디자인 원칙

- 애플리케이션에서 변하는 부분을 찾고, 변하지 않는 부분과 분리하여 캡슐화하자
    - 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식이다. 주제를 바꾸지 않고도 주제의 상태에 객체들을 바꿀 수 있다
- 구현보다는 인터페이스에 맞춰서 프로그래밍하자
    - 주제와 옵저버에서 인터페이스를 사용하고, 인터페이스를 통해 옵저버 등록/탈퇴를 관리하여 느슨한 결합을 만들자
- 상속보다는 구성을 활용하자
    - 주제와 옵저버 사이의 관계를 상속이 아닌 구성으로 구성하자"
2023-05-01 17:04:16,"최윤지","7일차
[7가지코드]

https://quiet-jade-e60.notion.site/7-0501-8ce8b647ee2a4a8cb153f06e34465f39
"
2023-05-01 18:07:51,"호02","7일차 제출

[초전 설득]

1. 요약 
 - 배경이 결과에 영향력을 미치는 사례 중 하나는 소음이다.
 - 보통 시간이 지나면 소음에 대해서 적응하거나 무시할 수 있다고 생각하지만 그렇지 않다.
 - 집중을 위해서는 주변 소음을 줄이는 해결 방안이 필요하다.

2. 메모
 - 백색 소음이 집중에 도움이 된다고 하는데, 그것 또한 거짓일까"
2023-05-01 18:17:08,"이소민","7일차 제출

[헤드퍼스트 디자인패턴]

📍요약

옵저버 패턴 최종 정리!
옵저버 패턴은 객체들 사이에 일대다 관계를 정의하며 이들 사이는 느슨한 결합의 특징을 지닌다. 옵저버 패턴 사용 시 옵저버가 주제로부터 데이터를 가져오는 풀(Full) 방법이 더욱 좋다.

📍발췌
느슨한 결합을 이용하는 디자인이 훨씬 더 유연하고 변화에 강하다는 사실을 꼭 기억해 두세요.

📍메모
책에 나와있는것을 보면 옵저버 패턴은 모델-뷰-컨트롤러 패턴과 아주 밀집한 관계가 있는 것 같다. 실무에서 MVC패턴을 주로 이용하는데 옵저버 패턴을 다시 한번 복습하며 앞으로 배울 MVC패턴과 무슨 관계인지 더 집중적으로 학습해봐야겠다."
2023-05-01 18:54:16,"궈노","7일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_7_102-113.md"
2023-05-01 20:24:26,"강민규","여러분 좋은 휴일 보내고 계신가요~ 오늘 2주차의 시작입니다! 이번 주가 지나면 독서하는 일상이 자연스러워질 것이니 참고 견뎌보아요~ 

@김형우 선생님은 토, 월 분량 제출 바랍니다~

@김성태 성태님은 이틀 연속 결석하셨는데 오늘 열시 전까지 삼일치 다 하기로 약속하고 마지막 기회를 드리기로 했습니다.

다른 분들도 이틀 연속으로 결석하시면 아침에 따로 저와 연락을 하게되고요 계속 하려는 의지가 강하다면 한번은 기회를 드립니다~"
2023-05-01 21:33:46,"김성태","5일차 
[헤드퍼스트 디자인 패턴]

### 요약
Chapter 02: 객체들에게 연락 돌리기 - 옵저버 패턴

- 기상 모니터링 애플리케이션 예시
- WheatherData 객체로 현재 조건, 기상 통계, 기상 예보 3가지 항목을 디스플레이 장비에서 갱신해 가면서 보여줘야 함

- 신문사 + 구독자 = 옵저버 패턴
- 주제에서 중요한 데이터를 관리하고, 데이터가 바뀌면 옵저버에게 소식이 전해짐

### 발췌
- 옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다. 
"
2023-05-01 22:00:54,"강민규","성태님 2일 연속 결석으로 탈락입니다. 다음 번에는 함께 끝까지 할 수 있기를 바랍니다~"
2023-05-01 22:01:00,"강민규","김성태님을 내보냈습니다."
2023-05-02 00:11:37,"김연정","7일차

요약
언론이 특정주제에 대해 설득력있는 증거와 함께 보도하는 것 보다 더 많은 빈도로 보도하는 방법이 그 주제가 더 중요하다고 생각되도록 만드는데 더 효과적이다. 
무언가에 주의를 두었다는 사실만으로 그것이 중요하다는 잘못된 믿음을 흔하게 만들어낼 수 있다. 
연예계에서 무플보다 악플이 낫다고 하는 이유도 여기에 있다.

메모
어떻게든 한 번이라도 더 생각하게 만들만한 구실을 제공하면 그것이 중요하다고 생각하게 만들 수 있다."
2023-05-02 00:34:18,"김형우","[6일차]
https://engineer-diary.tistory.com/200
"
2023-05-02 07:17:51,"다운","7일차

사피엔스

현대인의 사회적 심리적 특성 중 많은 부분이 수렵채집때 형성되었다. 예를 들어 고칼로리를 탐하는 유전자나 일부 다처제 등이 있다. 또한 수렵채집인은 정신적, 감정적 삶의 태반은 인공물의 도움을 받지 않았다.

그렇지만 모든 수렵채집인들이 이러한 특성을 가지고 있는것은 아니고 지역마다 문화마다 차이가 상당했다.

발췌
우리 종은 존속기간의 거의 대부분을 수렵채집인으로 살았다
"
2023-05-02 07:47:30,"강민규","사진"
2023-05-02 07:47:39,"강민규","여러분 오랜만에 평일인데 힘들지는 않으신가요? 화이팅입니다!"
2023-05-02 17:32:01,"김연정","8일차
초전설득

요약
상대방의 주의를 전환시키는 3가지 방법:
1. 배경환경 이용
소파 판매 업체의 웹사이트 랜딩 페이지 배경을 푹신해 보이는 구름 사진으로 변경한 것만으로도 방문자에게 '편안함'으로 주의를 유도하여 가격이 아닌 품질에 더 초점을 맞추도록 함. 반대로 동전 사진의 경구 값싼 제품을 구매하는 경향이 높았음. 방문자들은 이 사실을 모르고 알더라도 인정하지 않음. 

기사 주변에 배너 광고도 과소평가되어있지만 효과가 상당히 높고 반복적일수록 좋음.

집이나 자녀의 학교가 기차,비행기 등으로 지속적인 소음이 일어나는 지역에 있다면 반드시 해결할 것, 기억력과 읽기 시험 점수에 큰 영향을 미침.

메모
기사 배너 광고는 정말 효과가 없어보이고 개인적으로도 기억나거나 눈에 띄었던 적이 없는데 효과가 높다니 놀랍다."
2023-05-02 17:33:11,"송예은","8일차
ddd, msa

## 2.4.3 애플리케이션 패턴

프론트엔드는 어떻게 설계해야할까. 백엔드가 MSA인데 프론트가 모노리스라면 프론트에서도 모노리스의 문제점을 똑같이 가져가게 된다. 구성 패턴을 알아보자.

### UI 컴포지트 패턴 또는 마이크로 프런트엔드

프론트엔드도 백엔드 마이크로서비스처럼 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프론트엔드를 조합해서 동작하게 한다. 이 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 한다.

### 마이크로서비스 통신 패턴

- 동기 통신 방식
    
    클라이언트에서 서버 측에 존재하는 마이크로서비스 REST API를 호출할 때 사용되는 기본 통신 방법이다.
    
    서버 간 호출도 기본적으로 REST API 동기식 호출이 기본이다.
    
    하지만 동기식 호출은 여러 서비스 간 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 장애가 연쇄적으로 발생할 수 있다.
    
- 비동기 통신 방식
    
    카프카 등의 메시지 브로커를 활용해 메시지 기반의 비동기 호출을 할 수 있다.
    
    메시지 브로커에 의해 중계되므로 서로 통신하는 서비스들 사이에 의존성이 없다. 그러므로 마이크로서비스에 효과적인 방법이다.
    
    느슨한 결합으로 확장성, 탄력성 측면에서 이점이 많다.
    

### 저장소 분리 패턴

- 기존 모노리스 시스템의 저장소는 통합 저장소다. 애플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용하는 구조다.
    
    이러한 구조를 데이터 중심 애플리케이션이라 하는데, 성능 문제가 발생하면 스케일 업에 의존할 수밖에 없다.
    
- 저장소 분리 패턴은 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다. 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근할 수 있다.
    
    이런 패턴은 여러 개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것이냐는 문제가 있다."
2023-05-02 20:31:02,"궈노","8일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_8_114_125.md"
2023-05-02 20:46:36,"리경","7일차
오브젝트

✨ 요약
#책임
- 객체의 책임은 객체가 ‘무엇을 알고 있나’, ‘무엇을 할 수 있는가’로 구성됨.

- 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정함
	ex. Movie라는 객체가 calculateMovieFee 메시지를 수신하고 fee, discountPolicy를 속성으로 갖는 이유는 협력 안에서 가격을 계산할 책임을 할당 받았기 때문!

- 객체가 책임을 수행하게 하는 유일한 방법은 메시지 전송하는 것이므로, 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다.
	ex. ———1.예매하라———>

- 이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성함. 

- 책임 주도 설계는 객체 구현 아닌 책임에 집중해 유연하고 견고한 객체지향 설계하게 함. 메시지가 객체를 결정하면 최소한의 인터페이스를 갖고, 충분히 추상적인 인터페이스(무엇을 하는지 표현)를 갖는다.

#역할
- 역할을 구현하는 가장 일반적 방법은 추상 클래스와 인터페이스를 사용하는 것. 추상 클래스는 책임의 일부를 구현해 놓은 것. (공유하는 상태와 행동의 기본 구현 존재하기 때문) 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓은 것. (공통 구현 필요없기 때문)

- 협력을 구성하기 위해 역할에 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현되고 생성됨

✨ 발췌
- 객체지향설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다.

- 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 객체가 가질 수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있다.


 - 역할은 다른 것으로 교체할 수 있는 책임의 집합이다. 여기서 역할이 두 종류의 구체적인 객체를 포괄하는 ‘추상화’라는 점에 주목하라. 따라서 포괄할 수 있는 추상적인 이름을 부여해야 한다. 


✨ 메모
메시지 이름 결정 -> 수신할 객체 선택 (객체의 책임 결정) ->  동일 책임을 감당하는 여러 객체 존재할 때 역할로 추상화
"
2023-05-02 20:53:09,"강민규","여러분 휴일이 오히려 여러분을 더 힘들게 하는 것인가요? 월요일 분량 하지 않으신 분이 굉장히 많군요~ 이제 다시 현실로 돌아와봅시다!

@수정 @이찬영 @Bo @김형우 @뚯뚜오 @쏘이쏘이양 @최다봄 

이틀 연속 결석하시면 아침에 개인적으로 연락드리는데요 여러모로 서로 불편하니 최선을 다해 규칙을 지켜봅시다~"
2023-05-02 20:54:04,"강민규","언급 되신분들은 확인하시면 체크 한번씩 부탁해요, 혹시 못보시는 분이 있으면 밤에라도 개인적으로 연락을 드리기 위함입니다!"
2023-05-02 20:54:49,"최다봄","7일차

[헤드퍼스트 디자인 패턴]

**푸시**: 주제가 옵저버에게 상태를 알리는 방식

**풀**: ****옵저버가 주제로부터 상태를 끌어오는 방식

### 옵저버 패턴

- 객체들 사이에 일대다 관계를 정의한다.
- 주제는 동일한 인터페이스를 써서 옵저버에게 연락한다.
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있다.
- **주제는** 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 **옵저버에 관해 전혀 모른다.** 따라서 이들 사이의 결합은 **느슨한 결합**니다.
- 옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸시 방식) 옵저버가 데이터를 가져올 (풀 방식) 수 있다.
    - 일반적으로 풀 방식이 더 ‘옳은’ 방식이라고 간주
- 옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러(MVC)를 배울 때 다시 만남 !

### 디자인 원칙

- **애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.**
    - 옵저버 패턴에서 변하는 것을 주제의 상태와 옵저버의 갯수, 형식
    - 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있다.
- **구현보다는 인터페이스에 맞춰서 프로그래밍한다.**
    - 주제와 옵저버에서 모두 인터페이스를 사용한다.
    - 주제는 Subject 인터페이스로 Observer 인터페이스를 구현하는 객체들의 등록과 탈퇴를 관리하고, 그런 객체들에게 연락을 돌린다. ⇒ 느슨한 결합
- **상속보다는 구성을 활용한다.**
    - 옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리한다.
    - 주제와 옵저버 사이의 관계는 상속이 아니라 구성으로 이루어지기 때문."
2023-05-02 21:10:06,"이찬영","7일차

헤드퍼스트 디자인패턴 [월요일] 
102-113pg

# 요약

### **CHAPTER 02. 객체들에게 연락돌리기 (feat. 옵저버 패턴)**

[라이브러리 속 옵저버 패턴 : 스윙라이브러리]

swing toolkit의 기본 구성 요소 중 JButton 클래스 : AbstractButton을 찾아보면 리스너를 추가/제거하는 메소드가 많음.

[옵저버가 필요한 데이터를 골라서 가져가도록 해보기 - 풀 방식으로 코드 바꾸기]

주제 → 옵저버로 데이터를 보내는 푸쉬(push)

옵저버 ← 주제로부터 데이터를 당겨우는 풀(pull)

[새로 채운 디자인 도구상자]

- 객체지향 원칙
    - 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다.
- 객체지향 패턴
    - 옵저버 패턴 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
   
   
### **CHAPTER 03. 객체 꾸미기 (feat. 데코레이터 패턴)**

상속을 남용하는 사례 → 객체 작성 : 실행 중에 클래스를 데코레이션하는 방법 배우기  

# 발췌
💡 Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있습니다.
💡 옵저버 패턴을 사용하면, 주제가 데이터를 보내거나(푸시), 옵저버가 데이터를 가져올(풀) 수 있다. 일반적으로는 풀 방식이 더 ‘옳은’ 방식이라고 간주한다.

# 메모
없음"
2023-05-02 21:10:24,"최윤지","8일차
[7가지 코드]

https://quiet-jade-e60.notion.site/8-0502-75d778252dd94750a7a322fb60ea3011"
2023-05-02 21:10:56,"이찬영","8일차

헤드퍼스트 디자인패턴 [화요일] 

114-125pg

# 요약

**CHAPTER 03. 객체 꾸미기 (feat. 데코레이터 패턴)**

상속을 남용하는 사례 → 객체 작성 : 실행 중에 클래스를 데코레이션하는 방법 배우기

[스타바즈]

처음 스타바즈의 코드는 클래스 관련 문제에서

1. 달라지는 부분과, 달라지지 않는 부분 분리하기
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 의 두 가지를 지키고 있지 않다.

상속을 사용한다고 해서 무조건 유연하거나 관리하기 쉬운 디자인이 아니다.

구성과 위임으로 실행 중에 행동을 ‘상속’하는 방법이 있다.

[코드 관리에 구성이 미치는 영향]

객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가 할 수 있다.

[디자인 원칙 : OCP: Open-Closed Principle]

클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

목표: 기존 코드를 건드리지 않고 확장으로 새로운 행동 추가하기

[데코레이터 패턴 살펴보기]

ex) 특정음료에서 시작해서 첨가물로 그 음료를 장식(decorate) 한다.

[주문 시스템에 데코레이터 패턴 적용하기]

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
- 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관 없다.
- 객체는 언제든지 감쌀 수 있다.

[데코레이터 패턴 정의]

객체에 추가 요소를 동적으로 더할 수 있습니다. 

데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수있습니다.

# 발췌
💡 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있습니다.
💡 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있습니다.


# 메모
- 코드는 밤의 연꽃처럼 변경에는 닫혀 있고, 아침의 연꽃처럼 확장에는 활짝 열려 있어야 한다.
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 한다. 무조건 OCP를 적용한다면 괜히 쓸데없는 일을 하며 시간을 낭비할 수 있으며, 필요이상으로 복잡하고 이해하기 힘든 코드를 만들게 되는 부작용이 발생할 수 있다."
2023-05-02 21:20:00,"이소민","8일차 제출

[헤드퍼스트 디자인패턴]

📍요약
상속은 좋은 방법이긴하지만 서브클래스가 무한대로 만들어질 수 있다는 단점이 있다. 데코레이터 패턴은 이런 문제를 해결해 줄 수 있다. 데코레이터 패턴을 사용하면 객체에 추가 요소를 동적으로 더해 서브클래스를 만들때보다 훨씬 유연하게 기능을 확장할 수 있다.


📍발췌
데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있습니디.

📍메모
상속이 강력하기는 하나 상속을 사용한다고 해서 관리하기 용이한 디자인을 만들 수 없다는 걸 다시 한번 깨달았다. 상속을 통한 구현을 하기 전에 먼저 데코레이터 디자인 패턴을 먼저 떠올려 보자."
2023-05-02 22:47:44,"수정","7일차 제출

[헤드퍼스트 디자인 패턴]

# 요약
- 자바의 스윙 라이브러리(GUI 툴킷)에서도 옵저버 패턴을 이용한다
    - 버튼클래스가 옵저버(리스너)를 관리
- 옵저버가 주제로부터 데이터를 가져오는 방식
    - 푸시: 주제가 상태를 알려줌
    - 풀: 옵저버가 상태를 가져옴
    - 둘 중 선택가능하나 확장성을 생각했을 때 대체로 풀이 좋다
        - 주제의 데이터가 변경(추가)되었을 때, update()로 데이터를 푸시받는 모든 옵저버가 함수를 업데이트 해야 함
        - 주제가 상태가 변경되었다는 알림(update)을 주면, 옵저버가 필요한 상태만 골라 가져온다(주제의 게터 메서드 이용)
    - 옵저버에게 알림을 줄 때, 순서에 의존하면 안된다

# 발췌 및 정리
- 옵저버 패턴은 디자인 원칙을 지킨다
    - **달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다** `캡슐화`
        - 주제 클래스는 달라지는 부분(주제의 상태, 옵저버의 종류와 수)에 영향을 받지 않는다.
    - **구현보다는 인터페이스에 맞춰서 프로그래밍한다**
        - 주제와 옵저버라는 두 인터페이스의 관계를 만들고, 옵저버 등록/탈퇴/상태변경시 연락 등의 인터페이스의 메서드들을 통해 원하는 기능을 구현한다
    - **상속보다는 구성을 활용한다**
        - 주제와 옵저버의 인터페이스가 상속이 아닌 구성 관계로 이루어진다"
2023-05-02 22:48:08,"수정","8일차 제출

[헤드퍼스트 디자인 패턴]

# 요약
- 상속 말고 재사용하는 방법
    - 서브클래스를 만드는 방식으로 상속하면
        - 행동이 컴파일때 완전히 결정된다
        - 모든 서브클래스에서 똑같은 행동을 상속받아야 한다
    - 구성으로 객체의 행동을 확장하면
        - 실행 중에 동적으로, 슈퍼클래스 모르게 행동을 설정할 수 있다
- OCP(Open-Closed Principle)
    - 클래스는 변경에는 닫혀 있고 확장에는 열려 있어야 한다
    - 모든 부분에서 준수하기란 불가능하지만 바뀔 가능성이 높은 부분에 중점적으로 적용해야한다
        - 불필요한 부분까지 적용하다보면 코드가 필요 이상으로 복잡해질 수 있음
- 데코레이터 패턴
    - 데코레이터의 슈퍼클래스는 자기가 장식하는 객체의 슈퍼클래스와 같다
    - 데코레이터로 여러 번 감쌀 수 있다
    - 데코레이터는 장식하고있는 객체에게 위임하는 일 말고도 추가 작업을 수행할 수 있다"
2023-05-02 23:10:34,"강민규","@뚯뚜오 @쏘이쏘이양 선생님들 꼭 잊지말고 해주세요"
2023-05-02 23:30:43,"호02","8일차 제출

[초전 설득]

1. 요약 
 - 배경 환경에 영향을 미치는 것은 시각 뿐만 아니라 청각에도 영향이 간다.
 - 교사가 교실에 지도, 미술 작품 등이 과하게 붙어 있다면 아이들의 학습 효과를 떨어뜨린다.
 - 배경 정보를 어떻게 활용하느냐에 따라 집중 또는 분산 시킬 수 있다.

2. 메모
 - 교사는 아이들에게 스스로 질문하면서 배워나가는 학습보다는 양육의 개념이 포함된 교육을 하는 경향이 크다. (적어도 나의 경험상)
 - 아이들이 스스로 집중할 수 있는 환경이 아니기 때문에 주의를 분산시키는 것들의 효과가 더 크게 작용하는 건 아닐까"
2023-05-02 23:43:32,"Bo","7일차 
헤드퍼스트 
### 요약

> 스윙 사용 해보기
> 
- 스윙은 다른 여러 GUI 프레임워크와 마찬가지로 옵저버 패턴을 많이 사용

> 옵저버 패턴 보충
> 
- 주제에서 알림이 가는 순서에 의존하지 않는 것이 좋다
- 자바에서 옵저버 패턴 사용한 예
    - 자바빈은 bean 에서 propertyChangeEvent 로 유형 속성이 바뀌면 PropertyChangListener 에 알림을 보내준다

> 푸시 → 풀
> 
- 주제의 상태가 갱신되면 notify () 메소드에서 observer 들을 돌면서 update ( 데이터1, 데이터2 .. ) 하는 push 방식을 취했다
- 풀 방식
    - update() 에 인자를 전달하지 않음
    - 각 observer 들이 update 구현부에서 자신이 필요한 것을 가져오도록 할 수 있다
- 풀 방식이 더 좋다
    - 데이터가 추가되도 필요한 부분만 고치면 된다 ( 모든 인자를 넘겼다면 모든 부분의 메소드를 수정해야 할 것 )

> 옵저버 패턴 키워드 (내생각)
> 
- 일 대 다
- 느슨한 결합
- 구성을 사용
- 인터페이스 사용

### 발췌

> 핵심 정리 발췌
> 
- 옵저버 패턴
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고, 자동으로 내용이 갱신 되는 방식으로 일대다 의존성을 정의
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여 가능
- 다른 언어 프레임워크에서도 옵저버 패턴 많이 사용"
2023-05-03 01:30:57,"김용기","8일차
DDD MSA

## 2.4.3 애플리케이션 패턴

### UI 컴포지트 패턴 또는 마이크로 프런트엔드

- 프런트엔드도 백엔드 마이크로 서비스처럼 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프런트엔드를 조합해서 동작하게 한다.

### 마이크로 서비스 통신 패턴

- 다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위한 방법으로 중간 API 게이트웨이를 둘 수 있다.
- 여러 서비스 간의 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 이 같은 상황에서 장애가 연쇄적으로 발생할 수 있다.
- 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는 해당 서비스 간의 의존관계가 높다는 것을 의미한다.
- 비동기 방식은 메세지 브로커에 의해 중계되기 때문에 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치할 필요도 없고 서로 프로세스를 공유할 필요도 없으며, 심지어 동일한 시간대에 동시에 동작하지 않아도 된다.
- 클라우드 플랫픔 환경에서 서비스가 다운됐을 때 또는 시스템을 더 확장해야 할 때 사용할 수 있는 매우 효과적인 방법이다.
- 이벤트 기반 아키텍처는 분산 시스템 간에 발신자가 이벤트를 생성 및 발행하고 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 구독하고 있던 수신자가 이벤트를 받아 처리하는 형태의 시스템 아키텍쳐이다.
- 이벤트 기반 아키텍처는 이벤트를 생산하는 모듈과 이벤트에 대응하는 모듈을 분리하고 상호 독립적으로 동작하게 함으로써 병렬  처리를 촉진한다.
- 이벤트 메세지를 사용하면 발시낮와 수신자를 장소와 시간에서 쉽게 분리할 수 있으며, 마이크로서비스가 추구하는 느슨한 결합으로 확장성, 탄력성 측면에서 이점이 많다.

### 저장소 분리 패턴

- 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고 성능 문제가 발생했을 때 SQL 구문 튜닝이나 저장소 증설에 의존할 수 밖에 없다.
- 통합 데이터베이스만 여전히 바쁜 상황이 되어 마이크로 서비스의 자동 확장 기능이 별 소용이 없어질 수 있다.
- 저장소 분리 패턴은 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다.
- 정보 은닉 : 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 정한 API를 통해서만 접근할 수 있다.
- 폴리글랏 저장소 : 각 저장소를 자율적으로 선택할 수 있다.
- 영향도 : 데이터를 통한 변경의 파급효과를 줄여 독립적으로 만든다."
2023-05-03 01:41:06,"박소환","8일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/87"
2023-05-03 03:46:45,"김형우","[7일차]
https://engineer-diary.tistory.com/203"
2023-05-03 04:46:15,"뚯뚜오","7일차 총균쇠

요약

농업을 통해 잉여생산물이 확보되어야 먹고사니즘이 해결되므로 기능전문가집단의 출현이 가능하다. (군인, 정치가 등)

가축과 관개시설의 중요성 (식량자원의 확보 측면)

폴리네시아 여러 민족의 문명 발전 속도의 차이에 대한 6가지 원인 : 기후, 지질유형, 해양자원, 면적, 지형적분열, 고립성

발췌

섬 내부의 통행에 강력한 장애물이 없는 작고 고립된 섬들의 경우에는(가령 160명이 산 아누타 섬과 같이) 섬 전체가 정치적 단위가 되었다. 그보다 큰 섬들은 정치적으로 통일되지 못한 경우가 많았다. 그 이유는 전체 인구가 각각 몇십 명쯤의 수렵 채집민으로 이루어진 여러 무리로 분산되었거나(채텀 제도와 뉴질랜드 남섬의 남부) 농경민들이 넓은 지역에 뿔뿔이 흩어져 있거나(뉴질랜드의 나머지 지역) 농경민들이 밀집해 살지만 기복이 심한 지형 때문에 정치적으로 통일되지 못했기 때문이었다. 예를 들어 마르키즈 제도의 경우 서로 이웃한 계곡에 사는 사람들도 가파른 절벽 때문에 주로 바다를 통해서 왕래를 했다. 

정치적 단위의 인구 규모는 인구 밀도와 더불어 폴리네시아의 기술 및 경제적, 사회적, 정치적 조직에 영향을 미쳤다. 일반적으로 규모가 크고 밀도가 높을수록 기술과 조직은 점점 복잡해진다. 그 이유에 대해 서는 뒤에 나올 여러 장에서 자세히 다룰 것이다. 간략히 설명하자면 인구 밀도가 높으면 전체 인구의 일부만 농경민이 되었지만 그들은 집 약적 식량 생산에 동원되어 비생산자들을 먹여 살릴 잉여 농산물을 수확했다는 것이다.

농경민들을 동원하는 비생산자에는 추장, 사제, 관료, 무사 계급 등 이 있었다. 규모가 큰 정치적 단위들은 많은 노동력을 동원하여 관개 시설이나 양어장 등을 건설함으로써 식량 생산을 더욱 집약화할 수 있었다. 이러한 발전은 통가, 사모아, 소시에테 제도 등에서 특히 두드러졌다. 그 모두가 폴리네시아의 기준에서는 비옥하고 인구가 밀집되고 상당히 넓은 편에 속했다. 이러한 경향은 폴리네시아의 열대 섬 중에서 가장 큰 섬으로 이루어진 하와이 제도에서 절정에 달했다.하와이는 인구 밀도가 높고 면적이 넓어서 추장들이 동원할 수 있는 노동력의 규모도 매우 컸다."
2023-05-03 07:46:51,"강민규","사진"
2023-05-03 07:47:18,"강민규","이틀만 더 일하면 되는군요, 요새 다들 지각도 많고 위태위태하지만 최선을 다하면 못할 것도 없습니다. 응원합니다~"
2023-05-03 07:48:08,"뚯뚜오","8일차 총균쇠

요약
잉여작물, 인구증가에 따른 전문화 및 사회 고도화 
2장 인간 사회의 다양한 운명의 갈림길 끝

유럽이 아메리카대륙을 지배하게 된 첫 번째 계기. 잉카제국의 마지막 황제 아타우알파 포박사건 
3장 유럽이 세계를 정복한 힘의 원천

발췌
사회적 복잡성도 역시 하와이 제도에서 절정에 달했는데, 추장 계급 에 속한 사람들이 모두 여덟 개의 위계 계보로 세분될 정도였다. 추장 계보의 구성원들은 평민과 섞이지 않고 자기들끼리 결혼했으며 때로는 남매나 배다른 남매가 맺어지기도 했다. 평민들은 계층이 높은 추장 앞에서 반드시 엎드려야 했다. 추장 계보, 관료, 일부 기능 전문가 등의 구성원들은 모두 식량 생산을 위한 노동에서 해방되었다.
세습적 추장들의 권력은 다른 지역의 왕에 필적할 정도였고 토지는 평민이 아닌 추장이 통제했다. 추장은 자기가 임명한 관료들을 대리인으로 삼아 평민들로부터 식량을 징발했고 평민들을 징용하여 대규모 건설 공사를 벌였다. 그러한 공사의 형태는 섬마다 달라서 하와이에서는 관개 시설과 양어장, 마르키즈에서는 춤과 축제를 위한 건물, 통 가에서는 추장의 분묘, 그리고 하와이, 소시에 제도, 이스터 섬 등지 에서는 신전을 건설했다.
더구나 폴리네시아는 인류 역사에서 지극히 최근에 이르러 사람이 살기 시작했으므로 폴리네시아에서 가장 오래된 사회도 불과 3200년 동안 발전한 것이 고작이다. 인간이 가장 늦게 살기 시작한 대륙(남북아메리카)에서도 최소한 13000년이 넘었던 것과는 대조적이다. 만약 몇천 년 정도만 더 있었다면 통가와 하와이도 어엿한 제국 수준에 이르러 태평양의 패권을 놓고 싸웠을 것이고 고유의 문자를 만들어 제국을 다스렸을 것이다. 또한 뉴질랜드의 마오리족은 비취를 비롯한 기존의 재료뿐만 아니라 구리와 철로 만든 도구도 사용하게 되었을 것이다.

유럽인과 아메리카 원주민의 관계에서 가장 극적인 순간은 1532년 11월 16일 잉카의 황제 아타 우알파와 스페인의 정복자 프란시스코 피사로가 페루의 고지대 도시인 카하마르카에서 최초로 마주친 사건이었다. 아타우알파는 신세계에서 가장 크고 발전된 국가의 절대 군주였고 피사로는 유럽에서 가장 강력한 국가였던 신성 로마제국의 황제 카를 5세(또는 스페인의 카를로스 1세)를 대신하고 있었다. 168명의 스페인 오합지졸을 거느린 피사로는 낯선 땅에 들어왔다. 그는 그 지역 주민들을 잘 몰랐고 가장 가까운 곳(북쪽으로 1600km나 떨어진 파나마)에 있던 스페인인들과도 연락이 완전히 끊어졌으므로 때 맞춰 원병이 도착할 수도 없는 상황이었다.
반면에 아타우알파는 수백만의 백성이 있는 자기 제국에 버티고 있었으며, 더구나 다른 인디언과의 전쟁에서 막 승리를 거둔 8만 대군이 그를 둘러싼 형국이었다. 그런데도 두 지도자가 얼굴을 맞대고 미처 몇 분이 지나기도 전에 피사로가 대뜸 아타우알파를 사로잡아 버렸던 것이다. 피사로는 그로부터 8개월 동안이나 이 인질을 붙잡아 놓고 나중 에 풀어준다는 약속하에 역사상 가장 많은 몸값을 뜯어냈다. 피사로는 가로 6.7m, 세로 5.2m에 높이 2.4m가 넘는 방을 가득 채울 만큼의 황금을 몸값으로 받은 후에 약속을 저버리고 아타우알파를 처형하고 말았다."
2023-05-03 07:48:43,"다운","8일차 

사피엔스

농경시대 이전의 세상은 가축과 함께 지내는 사회와 달리 무리속의
모두가 인간이였고 그들은 개를 길들였다

사피엔스는 다른 사피엔스들과 우호적 접촉이 간혹 있었지만 대부분의 시간을 소규모 집단에서 보냈다

대부분의 사피엔스 무리는 먹을것과 지식을 찾아 여기저기 떠돌며 길 위에서 살았다.  그 결과 현대인 후손 대부분에 비해 환경에 대해 더 넓고 깊고 다양한 지식을 알고 있었다.

하지만 농업과 산업이 발달하자 별 볼일 없는 유전자를 가진 사람도 살아남을 수 있었다. 

수렵채집인은 후손에 비해 안락하고 보람있는 생활을 살았고 신체도 더욱 건강하며 식량문제도 적었고 전염병 영향도 덜 받았지만 높은 어린이 사망률로 평균수명이 30-40년이었다

하지만 현대의 수렵채집인들은 무리에서 따라오지 못한 노인과 어린아이를 죽이는등의 모습도 보여주는데 성인간의 폭력은 드물었으며 좋은 사회적 상호관계를 중요시 여겼다

발췌
같은 무리 구성원들은 서로를 매우 잘 알았으며 평생을 친구와 친척에 둘러싸인채 살아갔다 고독과 프라이버시는 없었다

삶에서 가장 중요하게 여긴 것은 좋은 사회적 상호관계와 높은 수준의 우정이었다
"
2023-05-03 08:51:09,"김연정","9일차
초전설득

요약
2. 한가지일에만 집중시켜 긍정적 평가 유도
강력한 경쟁자들이 많은 영역에 사용.
경쟁사의 비슷한 장점이 아니라 자사의 뛰어난 장점에 집중하도록 하는 것.
특정 기업이나 서비스, 직원을 평가하는 행위만으로도 유리한 위치에 설 수 있게 해줌(초점을 맞추게 되기 때문)
이때 평가에 참가하는 사람들은 서비스를 위한 것이라고 생각하지만 다른 효과가 더 크다.
반대로, 의사결정권자의 경우 선택지 중 하나를 고를 때 전략 성공 시 얻는 이익에만 초점을 맞추지 말고 계획이 어긋날 수 있는 요인은 없는지 손실에대해서도 고려하면 편향적인 의사결정 요소를 바로 잡을 수 있다.

메모
고객의 목소리가 별로 궁금하지 않은 상황이라도 만족스러워보이면 일단 설문평가에 참여하도록 하는 것이 광고 목적으로 좋겠다."
2023-05-03 11:01:52,"송예은","9일차
ddd,msa

### 분산 트랜잭션 처리 패턴

- 분산 트랜잭션 처리를 위한 전통적인 방법으로 2단계 커밋 같은 기법이 있다. 이는 원자성을 보장하기 위해 분산 트랜잭션에 포함돼있는 모든 노드가 커밋되거나 롤백하는 메커니즘이다.
    
    이 방법은 각 서비스에 잠금이 걸려 발생하는 성능 문제 때문에 효율적인 방법이 아니다. 또한 MongoDB 같은 NoSQL 저장소는 2단계 커밋을 지원하지 않는다.
    
- 마이크로서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴이 사가 패턴이다.
    
    사가 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다. 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춘다. 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 다음, 사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 메시지 또는 이벤트를 게시해서 데이터의 일관성을 맞춘다.
    
- 데이터 일관성에 대한 생각의 전환: 결과적 일관성
    - 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것은 아니다. 실시간으로 맞지 않더라도 어느 일정 시점이 됐을 때 일관성을 만족해도 되는 것이 있다.
    - 결과적 일관성의 개념은 고가용성을 극대화한다.

### 읽기와 쓰기 분리: CQRS 패턴

- 일반적인 애플리케이션에서는 조회가 쓰기보다 많이 쓰인다. 그래서 조회와 쓰기를 분리하는 패턴을 CQRS 패턴이라 한다.
- 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 아예 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있다.
- CQRS 패턴에서 데이터 일관성 유지를 위해 필요한 것이 이벤트 주도 아키텍처다. 명령 서비스는 저장소에 데이터를 쓰면서 저장한 내역이 담긴 이벤트를 발생시켜 메시지 브로커에 전달한다. 조회 서비스는 메시지 브로커의 이벤트를 구독하고 있다가 이벤트 데이터를 가져와 데이터를 최신 상태로 동기화한다. 결과적 일관성이 보장된다.

### API 조합과 CQRS

여러 개의 마이크로 서비스를 연계해서 서비스로 제공하는 경우 사용할 수 있는 방법들

- API 조합
    
    각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있다. 이런 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져온다.
    
- CQRS
    
    조회용 마이크로서비스를 별도로 생성하고 다른 서비스로부터 비동기 이벤트로 일관성을 맞춤으로써 API 조합 방식의 단점인 직접적인 의존성을 줄일 수 있다."
2023-05-03 11:33:58,"이찬영","@강민규  헤드퍼스트 디자인패턴 분량이 잘못 된 것 같은데 확인부탁드려요."
2023-05-03 12:36:52,"강민규","그러네요 126 ~ 139입니다. 데이터가 맛이 갔네요 빠르게 수정해놓겠습니다"
2023-05-03 15:55:37,"쏘이쏘이양","7일차
초전설득

요약
눈에 띄는 것이 무엇이던간에 그것에 과도하게 의미를 두려고 하는 것이 인간의 본능.(초점착시)
이를 활용한 언론의 어젠다 설정은 사람들이 무엇을 생각해야 하는지 전달하는 데에는 실패하지만, 사람들이 무엇에 대해 생각해야하는지 알려주는 데에는 성공적이다. 눈에 띄는 것이 중요하다

메모
눈에 띄는 것들에 대해 실제로 얼마나 중요한지 잘 생각해야 할 필요를 느꼈다. 책을 읽으면서 내가 어떻게 활용할지 보다는 세상에 활용된 것에 속지않고 똑바로 인식하기 위해 얼마나 주의해야할지를 더 생각하게 되는 것 같다. "
2023-05-03 16:30:17,"쏘이쏘이양","8일차
초전설득

요약
그냥 무시할만한 정보를 배경으로 제시하여 구매자의 관심을 이끌고, 다양한 방법으로 강력한 영향력을 행사할 수 있다. 배경정보가 상대방의 주의를 집중시킬수도 분산시킬수도 있다는 점에 주의하여 효과적으로 다룰 줄 알아야 한다. 

메모
배경정보를 최대한 활용하면서도 주의가 너무 분산되지 않도록 적절하게 배치하는 것이 관건이 될것 같다"
2023-05-03 18:44:20,"수정","9일차
헤드퍼스트 디자인 패턴

https://www.notion.so/9-cde95555aa3c4dd9b909fab15ed2b775?pvs=4"
2023-05-03 20:39:07,"강민규","@쏘이쏘이양 선생님 오늘 22시까지 9일차도 마무리해주셔야합니다"
2023-05-03 20:40:39,"최다봄","8일차 제출

[헤드퍼스트 디자인 패턴]

### 요약

- 상속을 사용하여 음료 가격과 첨가물 가격을 합해서 총 가격을 산출하는 방법은 **서브클래스가 끝도 없이 많아지**거나 **일부 서브클래스에 적합하지 않는 기능**을 추가해야하는 **문제**가 발생한다.
- **OCP(Open-Closed Principle)**
    - 클래스는 확장에는 열어 있어햐 하지만 변경에는 닫혀있어야 한다.
        - 2장 옵저버 패턴에서도 옵저버를 새로 추가하면 주제에 코드를 추가하지 않고도 확장가능했던걸 생각해보면 된다.
    - 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 방식의 경우 새로운 기능을 추가할 때 유연하다.
    - 모든 부분에서 OCP를 준수하는 것을 불가능하다.
- 데코레이터 패턴
    - “**일단 특정 음료에서 시작해서 첨가물로 그 음료를 장식(decorate)하는 방법을 생각해보자 !”**
    - 데코레이터의 슈퍼클래스는 자기가 장식하는 객체의 슈퍼클래스와 같다.
    - 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
    - **데코레이터는 장식하고있는 객체에게 위임하는 일 말고도 추가 작업을 수행할 수 있다. (keypoint)**

<aside>
💡 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다. 서브클래스를 만들 때보다 훨씬 유연하게 기능 확장 가능하다.

</aside>"
2023-05-03 21:31:26,"최다봄","9일차 제출

[헤드퍼스트 디자인 패턴]

**CHAPTER 03: 객체 꾸미기 - 데코레이터 패턴 (**“상속맨, 디자인에 눈을 뜨다”**)**

- 상속을 남용하지 않고, 객체 작성이라는 형식으로 실행 중에 클래스를 꾸미는(데코레이션하는)방법
- 기존 클래스 코드를 바꾸지 않고 객체에 새로운 임무를 추가 가능

### 요약

[스타버즈 커피 주문 시스템 (데코레이터 패턴 적용)]

- **추상 구성 요소**: Beverage
    - **데코레이터에 감싸이는 구상 구성 요소**: HouseBlend, Espresso, DarkRoast, Decaf
    - **추상 데코레이터**: CondimentDecorator
        - **구상 데코레이터**: Milk, Mocha, Soy, Whip
- **추상 데코레이터(CondimentDecorator)는 추상 구성 요소(Beverage)에게서 형식을 맞추려고 한 것.** 행동을 상속받으려고 Beverage의 서브클래스를 만드는게 아님 !
- 객체 구성(인스턴스 변수로 다른 객체를 저장하는 방식)을 이용해 유연성을 잃지 않을 수 있다.
    - 상속만 써야했다면 행동이 컴파일 시에 정적으로 결정되어버림.
        - 슈퍼 클래스에서 받은 것과 코드로 오버라이드한 것만 쓸 수 있다.
    - **구성을 활용하면 실행 중에 데코레이터를 마음대로 조합 가능!**
    

[데코레이터가 적용된 예: 자바 I/O (ex.134, 135 그림보고 이해하기)]

- **추상 구성 요소**: InputStream
    - **데코레이터에 감싸이는 구상 구성 요소**: FileInputStream, StringBufferInputStream, ByteArrayInputStream
    - **추상 데코레이터**: FilterInputStream
        - **구상 데코레이터**: PushbackInputStream, BufferedInputStream, DataInputStream, InflatorInputStream
- 데코레이터 패턴을 사용하여 디자인할 경우 클래스가 많아진다.
- 특정 형식에 의존하는 코드에 데코레이터를 적용하면 엉망이 된다.
    - 데코레이터의 가장 큰 장점 중 하나가 클라이언트는 데코레이터를 사용하고 있다는 사실 알 수 없다는 것인데 ..!
- 데코레이터 도입 시, 구성 요소를 초기화하는데 필요한 코드가 복잡해진다.

### 발췌

[객체지향 원칙]

+ **클래스는 확장에는 열러 있어야하지만 변경에는 닫혀있어야 한다. (OCP)**

[데코레이터 패턴]

- 객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터 사용 시 서브 클래스를 만들 때 훨씬 유연하게 기능을 확장할 수 있다."
2023-05-03 21:41:58,"쏘이쏘이양","9일차
초전설득

요약
주의 집중의 효과를 누리려면 하나에만 주의를 집중시켜야 한다. 의사결정권자가 중요한 선택을 할 때 모든 방안을 고려하지는 않으며, 눈에 들어오는 가장 실용적인 후보를 선택함으로써 힘든 선택의 과정을 회피 또는 생략한다(만족화 성향). 지나친 낙관주의를 피하기 위해서는 반대로 생각하기 전략으로 질문을 던져 고민해봐야 한다. 

메모
의사결정자는 조직운영을 원활하게 해야하는 임무가 있다는 말이 크게 다가왔다. 직무 위치에 따라 어떤 것을 우선 순위에 두어야 하는지 입장 차이를 생각해보게 하는 구절이다."
2023-05-03 22:07:42,"강민규","여러분 늦은 밤입니다. 사정이 생기면 늦을 수 있지만 결국 하고 마는 것. 그게 중요한 것 아니겠습니까?

그런 의미에서 @한종우 @최희윤 @김형우 @Bo @리경  선생님들은 화, 수 분량을 오늘 제출해보도록 합시다~"
2023-05-03 22:30:45,"최희윤","8일차 DDD
https://www.notion.so/05-02-DDD-8-b274ec3797744d3b867071354ccdd003?pvs=4"
2023-05-03 22:42:39,"최희윤","9일차 DDD
https://www.notion.so/05-03-DDD-9-69823a81bd354b8b8b4262dee06adf4a?pvs=4"
2023-05-03 23:57:12,"Bo","8일차 
헤드퍼스트
### 요약

> OCP
> 
- 정의는 아래 발췌에
- 옵저버 패턴도 OCP 의 구현 중 하나
- 모든 부분에서 OCP 를 준수하는 것은 어렵다.

> 데코레이터패턴
> 
- 데코레이터 패턴은 데코레이터가 꾸미는 대상을 감싸는 형식으로 진행 된다.
- 데코레이터는 대상과 같은 형식이므로 이를 감싼다 하더라도 외부에서는 같은 형식이므로 사용하는데 문제가 없다
- A 라는 메서드를 호출한다가 그러면, 겹겹히 데코레이터로 감싸져 있다고 하면 자신이 꾸미는 대상의 같은 메소드를 호출해서 결과 값을 얻고, 꾸며서 ( 자신의 로직의 결과를 합산 ), 자신을 꾸미는 데코레이터에게 반환하는 방식으로 진행된다.

### 발췌

> 데코레이터 패턴
> 
- 정의 : 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터 패턴을 사용하면 서브클래스를 만들 때 보다 훨씬 유연하게 기능을 확장할 수 있다
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행 할 수 있다  (포인트)

> OCP
> 
- 클래스 확장에는 열려 있고 변경에는 닫혀 있어야 한다 ( Open - Closed Principle)

### 메모

- 구성을 사용하면 OCP 를 지킨다
- 무조건 OCP 를 지키는 것이 좋지 않음을 알게되었다. ( 과도한 설계, 비용 )"
2023-05-04 00:05:39,"박소환","9일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/90"
2023-05-04 00:44:14,"이찬영","삭제된 메시지입니다."
2023-05-04 00:49:33,"이찬영"," 9일차
헤드퍼스트 디자인패턴 [수요일] 
126-139pg

# 요약
**CHAPTER 03. 객체 꾸미기 (feat. 데코레이터 패턴)**

[ Beverage 클래스 작성하기 ]
어떤 구성 요소를 가지고 데코레이터를 만들 때 새로운 행동을 추가하지. 새로운 행동은 객체를 구성해서 얻는 거잖아. 슈퍼클래스로부터 행동을 상속받아서 얻는 것이 아님.
→ 행동을 상속받으려고 Beverage의 서브클래스를 만든 게 아니라 형식을 맞추려고 한 것.

if 상속만 써야 했다면
행동이 컴파일 시에 정적으로 결정되어 버림. 슈퍼클래스에서 받은 것과 코드로 오버라이드한 것만 쓸 수 있음.

[ 코드구현 ] 
Beverage는 추상 구성요소,
HousBlend는 구상 구성요소
추상데코레이터 (CondimentDecorator)
구상데코레이터 - 모카

모카 인스턴스에 필요한 것.
1) 감싸고자 하는 음료를 저장하는 인스턴스 변수
2) 인스턴스 변수를 감싸고자 하는 객채로 설정하는 생성자

[ 데코레이터 적용 예 : 자바 I/O ]
InputStream : 추상 구성 요소
FileInputStream, StringBufferInputStream, ByteArrayInputStream : 구상 구성요소
PushbackInputStream, BufferedInputStream : 구상 데코레이터

[ 디자인 도구 상자 ] 
객체지향 원칙 : 클래스는 확장에는 열려있어야 하지만 변경에는 닫혀 있어야 한다.(OCP)
객체지향 패턴 : 데코레이터 패턴

# 발췌
💡 주의! 구상 구성 요소로 돌아가는 코드를 만들어야 한다면 데코레이터 패턴 사용을 다시 한번 생각해보자
💡 데코레이터를 도입하면 구성요소를 초기화 하는데 필요한 코드가 훨씬 복잡해진다."
2023-05-04 01:03:54,"리경","8일차
오브젝트

✨ 요약
#역할과 추상화
추상화의 장점은 세부사항에 억눌리지 않고 상위 수준의 정책을 쉽고 간단하게 표현할 수 있고, 설계를 유연하게 만들 수 있다는 것. 역할은 다양한 종류의 객체를 끼워넣을 수 있는 일종의 슬롯.

객체는 다양한 역할 가질 수 있음. 동일 역할 수행하는 객체들은 서로 대체 가능함. 

04. 설계의 품질과 트레이드오프
설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용 발생한다. 훌륭한 설계란 합리적인 비용 안에서 변경 수용하는 구조 만드는 것. 그것은 응집도 높고 느슨하게 결합돼 있는 요소로 구성 -> 객체 상태 아닌 행동에 초점 맞추는 것

객체의 상태는 구현에 속함. 구현은 변하기 쉬움. 중심으로 삼으면 세부사항이 객체의 인터페이스에 스며들어 캡슐화 원칙 무너짐. 

데이터 중심 설계
예시) discountCondition이 Movie 인스턴스 변수로 들어감. 

✨ 발췌
연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 역할을 수행하는 객체라는 관점이 가진 입체적 측면을 훌륭히 담아낸다. 협력은 연극과 동일하고 코드는 극본과 동일하다. 

가끔 좋은 설계보다 나쁜 설계를 살펴보는 과정에서 통찰을 얻기도 한다.

✨ 메모
데이터 중심의 설계는 이 객체가 포함해야하는 데이터는 무엇인가? 라는 질문에 반복적으로 휩쓸림. 객체의 책임을 정하기 전에."
2023-05-04 01:06:35,"한종우","8일차
[헤드퍼스트 디자인 패턴]

## Ch03. 데코레이터 패턴

- 데코레이터 패턴을 통해 기존 클래스 코드를 바꾸지 않고 객체에 새로운 동작을 추가할 수 있다
- 상속을 사용한다고 무조건 유연하고 관리하기 쉬운 디자인이 만들어지지 않는다. 서브클래스를 만드는 방법으로 행동을 상속받으면 그 행동은 컴파일할때 결정되고, 모든 서브 클래스에서 상속받아야 한다
- 구성과 위임으로 실행중에 행동을 상속하는 방법이 있다. 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있다.
- 객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가할 수 있다. 기존 코드를 수정하지 않아 의도치 않은 버그를 차단할 수 있다

### OCP(Open-Closed-Principle)

- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀있어야 유연하고 튼튼한 디자인을 만들 수 있다
- 무조건 OCP를 적용한다고 좋은 것은 아니다. 시간 낭비 및 추상화로 인해 코드가 복잡해질 수 있다
- 여러 디자인을 공부하며 중요한(바뀔 가능성이 높은) 부분에 OCP를 적용하는 것이 좋다

### 데코레이터 패턴

-  데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다.
데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 된다
- 데코레이터는 자신이 장식하고 있는 객체에게 어던 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다"
2023-05-04 01:06:56,"한종우","9일차
[헤드퍼스트 디자인 패턴]

- 상속은 행동이 컴파일 시에 정적으로 결정되어 슈퍼 클래스에서 받은 것과 코드로 오버라이드한 것만 사용할 수 있다. 하지만 구성을 활용하면 실행 중에 데코레이터를 마음대로 조합해서 사용할 수 있다.
- 데코레이터 패턴을 사용하면 관리해야할 객체가 늘어나 실수할 가능성이 높아진다. 하지만 팩토리나 빌더 같은 패턴으로 데코레이터를 만들어서 사용하면 된다
- 데코레이터는 감싸고 있는 객체에 행동을 추가하는 용도로 만들어진다. 만약 데코레이터 중간에 어떤 작업을 해야 한다면 데코레이터 패턴의 의도에 어긋난다
- 구상 구성 요소로 어떤 작업을 처리해야하는 코드에 데코레이터 패턴을 적용하면 코드가 작동하지 않는다. 구상 구성 요소로 돌아가는 코드를 만들어야 한다면 데코레이터 패턴 사용을 다시 생각해봐야 한다
- 자바 I/O는 데코레이터가 적용된 대표적인 예
- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장한다
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없다
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다.

### 데코레이터 패턴의 단점

- 자잘한 클래스가 많이 생겨 이해하기 어려운 디자인이 되기도 한다
- 특정 형식에 의존하는 코드에는 적용하기 어렵다
- 구성 요소 초기화하는 데 필요한 코드가 복잡해진다

### 데코레이터 패턴의 장점

- 객체에 추가 요소를 동적으로 더할 수 있다
- OCP를 만족하여 서브클래스를 만들때 보다 유연하게 기능을 확장할 수 있다"
2023-05-04 01:24:42,"리경","9일차
오브젝트

✨ 요약
#캡슐화
구현 : 변경 가능성 높은 부분
인터페이스 : 상대적으로 안정적인 부분
구현, 인터페이스 분리 후 외부에서 인터페이스에만 의존하도록 관계 조절해야함.

#응집도와 결합도
응집도 : 모듈에 포함된 내부 요소들 연관된 정도. 하나의 목적을 위해 긴밀히 협력하면 높은 응집도.

결합도 : 의존성의 정도, 다른 모듈에 대해 얼마나 많은 지식 갖고 있는지 나타내는 척도 = 한 모듈 병경되기 위해 다른 모듈의 변경을 요구하는 정도.

일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계. 오늘의 기능을 수행하며 내일의 변경을 수용할 수 있는 설계.

응집도가 높은 설계는 하나의 요구사항 변경을 반영 위해 오직 하나의 모듈만 수정. 변경 대상과 범위 명확해서 쉬움. 

#데이터 중심 시스템의 문제점
캡슐화를 위반하고, 객체 내부 구현을 인터페이스의 일부로 만듦.

데이터를 읽거나 수정위해 사용하는 get , set 메서드는 내부에 해당 인스턴스변수가 존재함을 퍼플릭 인터페이스에 드러냄.

이는 클라이언트가 구현에 강한 결합한 것. -> 객체 내부 구현을 변경했음에도 인터페이스에 의존하는 모든 클라이언트 변경해야함


✨ 발췌
설계가 필요한 이유는 요구사항이 변경되기 때문이고 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경사항을 통제할 수 있기 때분이다. 

클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.

캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이 결합도는 낮아진다.

단일 책임 원칙
클래스는 단 한가지의 변경 이유만 가져야 한다는 것이다. 클래스의 응집도를 높일 수 있는 설계 원칙이다. 

✨ 메모
설계시 협력 고민 안하면 캡슐화 위반해 과도한 접근자, 수정자 갖는 경향있음. 개발자는 어떤 상황에도 해당 객체 사용되도록 최대한 많은 접근자 메서드 추가하게 됨.."
2023-05-04 01:28:58,"김용기","9일차
DDD MSA

### 분산 트랜잭션 처리 패턴

- 2단계 커밋은 각 서비스에 잠금이 걸려 발생하는 성능 문제 탓에 효율적인 방법이 아니다.
- 사가 패턴은 마이크로서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴이다. 여러 개의 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춘다.
- 보상 트랜잭션은 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션이다.
- 사가는 각 로컬 트랜잭션으로 분리해서 순차적으로 처리하는 방법이다. 트랜잭션이 실패한 경우 이전 로컬 트랜잭션이 작성한 변경 사항을 취소하는 일련의 보상 트랜잭션을 통해 비즈니스 처리의 일관성을 유지한다.

### 결과적 일관성

- 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것은 아니다. 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 됐을 때 일관성을 만족해도 되는 것이 있다. 이를 결과적 일관성이라고 한다.
- 결과적 일관성의 개념은 고가용성을 극대화한다.
- 이벤트 기반 아키텍처와 메세지 브로커, 사가 패턴으로 비즈니스 정합성을 결과적으로 보장할 수 있고 지드니스 및 시스템 가용성을 극대화할 수 있다.

### 읽기와 쓰기 분리: CQRS 패턴

- 사용자의 비즈니스 요청은 크게 시스템 상태를 변경하는 명령과 시스템의 상태를 조회하는 부분으로 나눌 수 있다.
- 일반적인 비즈니스 모델에서는 입력, 수정, 삭제가 조회보다 적게 쓰이고 조회 요청이 훨씬 많이 사용된다.
- 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 아예 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있다.
- 쓰기 전략과 조회 전략을 각각 분리하면 쓰기 시스템의 부하를 줄이고 조회 대기 시간을 줄이는 등 엄청난 이점을 누릴 수 있다.
- 명령 측면 마이크로서비스는 입력, 수정, 삭제 처리를 수행하고 저장소는 쓰기에 최적화된 관계형 데이터베이스를 사용한다.
- 조회 측면의 마이크로서비스에서는 조회 성능이 높은 몽고디비나 엘라스틱 서치같은 NoSQL 데이터베이스를 저장소로 사용한다.
- 이러한 구조에서는 명령 서비스가 사용됨에 따라 조회 서비스와의 데이터 일관성이 깨지게된다.이때 데이터 일관성 유지를 위해 필요한 것이 이벤트 주도 아키텍처다.
- 명령 서비스는 저장소에 데이터를 쓰면서 저장한 내역이 담긴 이벤트를 발생시켜 메세지 브로커에 전달한다. 조회 서비스는 메세지 브로커의 이벤트를 구독하고 있다가 이벤트 데이터를 가져와 데이터를 최신 상태로 동기화한다.

### API 조합과 CQRS

- API 조합 : 각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있다. 이러한 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져온다.
- CQRS : 원천 정보를 보유한 여러 마이크로서비스는 자신의 서비스의 정보가 변경되는 시점에 변경 내역을 각자의 변경 이벤트로 발행한다. 조회용 마이크로 서비스를 별도로 생성하고 다른 서비스로부터 비동기 이벤트로 일관성을 맞춤으로써 API 조합 방식의 단점인 직접적인 의존성을 줄일 수 있게 된다."
2023-05-04 01:48:33,"호02","9일차 제출

[초전 설득]

1. 요약 
 - 상대방의 주의를 이끌기 위해서는 문제의 중요성을 부각할 수 있지만, 어디까지나 근거가 있는 정보를 토대로 진행되어야 한다.
 - 또한, 제품를 부각하기 위해서는 타사의 제품들과 비교하는 행동은 선호도를 줄이게 만든다.
 - 조직의 의사결정권자는 전략적 판단을 할 때는 계획이 어긋하는 요인과 영향에 대해 고민해야 한다.
 
2. 메모
 - 예전에 팹시와 콜라가 서로를 비교해대면서 광고했던 것이 기억에 남는데, 고객을 설득하는 데 있어서 자사 제품만을 강조하는 방법 이외의 방법도 여러 있을 거 같다."
2023-05-04 06:44:43,"김형우","[8일차]
https://engineer-diary.tistory.com/204"
2023-05-04 07:19:27,"다운","9일차

사피엔스

고대 수렵채집인은 애니미스트 라고 추측된다. 이들 사이엔 엄격한 위계질서가 없다.

수렵채집인의 주요 사망원인은 전쟁이 아니라 굶주림과 추위와 질병이다. 하지만 유골에 폭력의 흔적이 있는 걸 보아 폭력 사용률도 다양했을것이다.

발췌: 수렵채집인들의 종교와 사회구조가 매우 다양했던 것과 마찬가지로, 이들의 폭력 사용률 역시 매우 다양하게 분포했을 가능성이 크다."
2023-05-04 07:36:20,"강민규","사진"
2023-05-04 07:37:18,"강민규","여러분 좋은 아침입니다~ 이번 주 마지막 평일! 좋은 하루되세요 "
2023-05-04 09:35:41,"김연정","10일차
초전설득
요약
3. 임무를 바꾸기

미국 이라크 침공시 종군기자를 군인들에게 대거 배치하여 군인들의 일상, 용맹함과 같은 휴머니즘 기사를 통해 전쟁의 이유보다 다른 것에 사람들의 관심을 돌림, 언론은 인기있는 휴머니즘 기사를 쓸 수 있는 기회를 정부에서 제공해줬기 때문에 정부에 도움이 되는 방향으로 기사를 썼고, 결과적으로 정부에 이익이 되었음. 상대방의 주의를 집중시키면 관심도 따라온다.

메모
없음"
2023-05-04 11:43:30,"쏘이쏘이양","10일차
초전설득

요약
상대방의 주의를 집중시키면 중요성도 함께 따라온다. 사람들의 관심을 특정 주제로 유도하지 못한다면 결국 사람들은 그 주제가 중요하거나 자신과 관련있다고 생각하지 않는다.

메모
미국의 이라크 침공에 대해 나쁜 이미지를 가지고 있지 않았는데, 정부가 초점효과를 활용한 언론 플레이를 한 결과로 나 마저도 그렇게 생각하게 된 것은 아닌지 생각해보게 된다."
2023-05-04 15:47:56,"이소민","9일차 제출

[헤드퍼스트 디자인패턴]

📍요약

데코레이터 패턴은 객체에 추가 요소를 동적으로 더하는 디자인 패턴이다. 그렇기 때문에 서브클래스를 만들어 구현하는 것보다 훨씬 유연한 코드를 짤 수 있다.
또한 데코레이터의 개수에는 제한이 없으며 구성 요소의 클라이언트는 데코레이터의 존재를 알 수가 없다는 특징을 가진다.
그렇다고 해서 데코레이너틑 무분별하게 많이 사용하면 코드가 복잡해지기 때문에 적절하게 사용하는 것이 중요하다.

📍발췌
데코레이터 패턴을 쓰면 관리해야 할 객체가 늘어나니까 코딩할 때 실수할 가능성도 높아지겠죠. 하지만 실제로는 팩토리나 빌더 같은 다른 패턴으로 데코레이터를 만들고 사용합니다. 나중에 그런 패턴을 배우다 보면 데코레이터로 장식된 구상 구성 요소는 캡슐화가 잘 되어 있어서 질문에서 제기한 문제는 별로 걱정하지 않아도 된다는 사실을 알게 됩니다.

📍메모
데코레이터 부분은 이해하기 쉬운 것 같으면서도 어렵다. 이 패턴 또한 단점이 있으니 어떤 방식으로 구현하면 되겠다 라고 아이디어가 들면서도 막상 내가 구상한 것이 맞는지 의구심이 든다.. 추후 배울 팩토리 빌더 패턴을 배우고 나서는 데코레이터 패턴에 대한 이해도가 더 깊어지지 않을지 기대해 본다."
2023-05-04 15:48:54,"송예은","10일차
ddd, msa

### 쓰기 최적화: 이벤트 소싱 패턴

- 사가 패턴 및 CQRS 패턴에서 비즈니스 불일치를 피하기 위해서는 저장소에 저장하는 일과 메시지를 보내는 작업이 언제나 완전하게 진행되어 함께 실행돼야 한다.
- 객체의 상태 변화를 이벤트 메시지로 발행하고 또 객체의 상태 변경에 따라 데이터 모델로 처리되고 최종값을 반영하는 과정은 복잡하고 느릴 수밖에 없다.
- 이를 해결하기 위해, 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장하는 이벤트 소싱 기법을 사용할 수 있다. 이렇게 하면 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있고, 복잡한 과정이 없어 쓰기 속도가 훨씬 빠르다.
- 현재 시점의 상태가 필요하면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산한다.
- 서비스가 이벤트 저장소에 대한 CRUD를 모두 처리할 필요 없이, CR만 처리하면 된다. 변경과 삭제가 없어 명령 측면의 서비스를 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않는다.
    
    한번 발생한 후에 수정되지 않고 업데이트나 삭제 없이 입력만 되므로 동시성이나 정합성 등의 문제에 자유롭다.

# 3.1 비즈니스 로직은 어디에? - 관심사의 분리

- 개발자의 역할은 문제 영역의 비즈니스 로직을 분석 및 이해하고 프로그래밍 언어라는 도구로 잘 표현하는 일이다.
- 관심사의 분리 원칙에 따라 각 영역은 고유 관심사에 의해 분리되고 집중돼야 한다.
- 비즈니스 로직 영역과 기술 문제를 처리하기 위한 기술 영역은 철저히 분리하는 것이 좋다.
    
    이것은 비즈니스 로직이 기술보다는 오랫동안 지속되고 안정적이어야 할 애플리케이션의 핵심 영역이기에 기술에 영향을 적게 받도록 설계하는 것을 강조한 데서 기인한다.
    
- 애플리케이션의 유지보수성이 높다는 의미는 특정 개인에 의존하기보다는 어느 누구라도 손쉽게 애플리케이션을 이해하고 유지보수할 수 있음을 의미한다.

## 3.1.1 데이터베이스 중심 아키텍처의 문제점

- 데이터베이스 중심 아키텍처란 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 다음 이 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식이다.
- 비즈니스 민첩성을 위해서는 유연성과 확장성이 중요한데, 데이터베이스 중심 아키텍처에서는 저장소와 강결합되어있기 때문에 저장소를 변경하려 해도 쉽게 변경할 수 없다.
- 대부분의 성능을 데이터베이스에 의존하게 된다. 그러면 성능을 위해 스케일 업을 선택해야 하는데, 이는 클라우드 인프라의 장점인 자동 스케일 아웃이 의미 없어진다.
- 클라우드의 풍부한 자원 환경에서는 애플리케이션 자체의 성능보다는 애플리케이션의 확장성과 유연함이 더 중요하다. 비즈니스 로직 처리와 데이터 처리를 철저히 분리하는 것이 반드시 필요하다."
2023-05-04 17:19:19,"최윤지","9일차
[7가지코드]

https://quiet-jade-e60.notion.site/9-0503-5e534f9c93744c4cac6a18450c0edf83"
2023-05-04 17:21:23,"최윤지","10일차
[7가지코드]

https://quiet-jade-e60.notion.site/10-0504-1e7181c8b5e94a94b571f7a370dc770b"
2023-05-04 17:43:10,"이소민","10일차 제출

[헤드퍼스트 디자인패턴]

📍요약
간단한 팩토리는 팩토리 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝다.
이는 변화가 자주 일어나야 하는 부분을 따로 클래스로 빼서 '팩토리'를 만드는 것인데,
이때 기존 클래스는 클라이언트가 되고 팩토리는 새로 만들어진 클래스 객체를 일컫는다.
이렇게 캡슐화를 하면 클라이언트가 많아질 때에는 팩토리만 고치면 되기 때문에 수정이 용이하다는 장점이 있다.


📍발췌
간단한 팩토리(Simple Factory)는 디자인 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝습니다.


📍메모
팩토리 패턴 이라는 단어를 많이 들었는데 사실상 '간단한 팩토리' 라는 것은 디자인 패턴보다는 프로그래밍에서 자주 쓰이는 표현일 뿐이라는 사실을 처음알았다. 진짜 팩토리 패턴을 배우기 전에 팩토리라는 개념 자체를 일단 나도 자주 쓰던 프로그래밍 방식이라고 익혀두어 보자."
2023-05-04 18:17:10,"이찬영","10일차

헤드퍼스트 디자인패턴 [목요일] 
140-152pg

# 요약
**CHAPTER 04. 객체지향 빵 굽기 (feat. 팩토리 패턴)**
: 느슨한 결합으로 객체지향 디자인 만들기
: 팩토리 패턴으로 불필요한 의존성을 없애서 결합문제를 해결하자.

❓어떻게 하면 애플리케이션에서 구상 클래스의 인스턴스 생성 부분을 전부 찾아내서 애플리케이션의 나머지 부분으로부터 분리(캡슐화)할 수 있을까요?

[  피자 코드 예시 ]
최첨단 피자가게 에서는 신메뉴가 들어오고 삭제되는 메뉴가 생길 때마다 일일히 코드를 코쳐주어야 하는 단점이 있다.
orderPizza() 메소드에서 가장 문제가 되는 부분 : 인스턴스를 만드는 구상 클래스 선택하는 부분

→ 객체 생성 부분 캡슐화 하기
객체 생성을 처리하는 클래스는 팩토리(Factory) : SimplePizzaFactory

[ 객체 생성 팩토리 만들기 ]
SimplePizzaFactory 클래스에서 createPizza() 메소드 정의하기.

[ 정적 팩토리(static factory) ]
간단한 팩토리를 정적 메소드로 정의하는 기법.
정적 메소드를 쓰면 객체 생성 메소드를 실행하려고 객체의 인스턴스를 만들지 않아도 된다.
BUT, 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경할 수 없다는 단점이 있다.

[ 클라이언트 코드 → 팩토리로 피자 객체 생성하도록 수정하기 ]
PizzaStrore 클래스에 SimplePizzaFactory의 레퍼런스 저장하기.
new 연산자 대신 팩토리 객체에 있는 create 메소드를 사용한다.

[ 간단한 팩토리 란? ]
디자인 패턴보다는 프로그래밍에서 자주 쓰이는 “관용구”에 가깝다."
2023-05-04 19:06:21,"강민규","여러분 다들 퇴근 하셨나요? 내일이 어린이날이니 아마 오늘부터 놀아야할까나요.. 다들 좋은 주말 보내세요

@궈노 @김형우 @뚯뚜오 @Bo 선생님들은 이틀치 분량으로 가봅시다~"
2023-05-04 22:53:19,"김용기","10일차
DDD MSA

### 쓰기 최적화: 이벤트 소싱 패턴

- 이벤트 소싱이란 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장한다.
- 메세지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있다. 복잡한 과정이 없으니 쓰기 속도가 훨씬 빠르다.
- 상태가 필요하면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산한다. 이 같은 방식은 특정 시점의 상태가 필요하면 재현할 수도 있기 때문에 별도의 트랜잭션성 이력 로그 데이터를 기록할 필요도 없다.
- 저장소에서 변경과 삭제가 발생하지 않기 때문에 명령 측면의 서비스를 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않는다.
- 이벤트 소싱은 모든 트랜잭션의 상태를 바로바로 계산하지 않고 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장하는 방식이다.
- 이벤트 저장소는 이벤트 데이터베이스의 역할 뿐 아니라 메세지 브로커처럼 작동한다. 복잡성을 줄이고 쓰기 성능을 최적화한다.
- 개발과 운영을 모두 책임지고 있는 마이크로서비스팀 입장에서는 소프트웨어의 초기 개발 뿐만 아니라 지속적인 비즈니스의 변화에 빠르게 대응할 수 있는 구조가 필요한데, 소프트웨어가 부드럽지 않다면 기민하게 대응하기가 어려울 것이다.

# 3.1 비즈니스 로직은 어디에? - 관심사의 분리

- 비즈니스 로직이란 보통 시스템의 목적인 비즈니스 영역의 업무 규칙, 흐름, 개념을 표현하는 용어이다.
- 비즈니스를 표현하는 비즈니스 로직 영역과 기술 문제를 처리하기 위한 기술 영역은 철저히 분리하는 것이 좋다. 이것은 비즈니스 로직이 기술보다는 오랫동안 지속되고 안정적이어야 할 애플리케이션의 핵심 영역이기에 기술에 영향을 적게 받도록 설계하는 것을 강조한 데서 기인한다.
- 기술과 비즈니스 로직을 분리했을 때 복잡성이 낮아지고 유지보수성도 높아진다.

## 3.1.1 데이터베이스 중심 아키텍처의 문제점

- 데이터베이스 중심 아키텍처란 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 다음 이 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식이다.
- 간단한 처리 로직의 경우에는 편하지만 업무가 복잡해지면 점점 복잡성을 제어할 수 없게 된다는 단점이 있다.
- 데이터베이스의 본질은 데이처 저장 처리이고 여기에 최적화돼 있다.
- 관심사의 분리 원칙에 따라 끈끈하게 결합돼있던 비즈니스 로직 처리와 데이터 처리를 철저히 분리하는 것이 반드시 필요하다."
2023-05-05 00:37:41,"박소환","10일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/91"
2023-05-05 00:53:08,"호02","10일차 제출

[초전 설득]

1. 요약 
 - 부시 행정부가 이라크 전쟁 당시 종군 기자들에게 밀착 취재하도록 함으로써 전쟁의 합당함에 대한 의문점에 대해서는 군중들의 시야를 가려버렸다.
 - 전쟁의 행위에 대해 집중시킴으로써 상대적으로 전쟁의 의미에 대한 중요성이 낮게 인식하는 결과가 나타났다.
 
 
2. 메모
 - 없음"
2023-05-05 01:10:22,"Bo","9일차 
헤드퍼스트 
### 요약

> 데코레이터 패턴
> 
- 직접 데코레이터 패턴으로 스타벅스 예제 코드를 짜봤다
- 데코레이터는 자신이 감싸고 있는 구성 요소와 형식이 똑같다 ( 클라이어트는 데코레이터인지 신경 안쓴다 )
    - 그렇기 때문에 겹겹이 감쌀 수 있는 것 ( 형식이 일관 되고, 그 형식을 내부에 필드로 갖고 있으니까 )
- 결국 데코레이터는 상속을 사용하지 않고 행동을 확장하는 것
    - 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더해서 행동을 확장한다
- OCP 를 잘 지킨다고 볼 수 있다
- 데코레이터 패턴 단점
    - 자잘한 클래스가 많이 생길 수 있고
    - 필요 이상으로 코드가 복잡해질 수 있다 ( 결국 반환 되는 결과를 알려면 데코레이터를 따라 가야 함 )

### 발췌

> 데코레이터 패턴
> 
- 객체에 추가 요소를 ‘동적으로’ 추가할 수 있습니다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 더 유연하게 기능 확장 가능"
2023-05-05 01:29:01,"뚯뚜오","- 9일차 총균쇠
    
    요약
    총과 말(바이오닉탱크)을 처음 접한 충격으로 인해 순간적으로 잉카제국(아메리카 원주민)은 스턴상태에 접어들었고 기독교 중심주의의 최대 피해자 중 하나가 되었다.
    
    발췌
    
    ""그대가 패하여 포로가 된 것을 모욕으로 생각하지 마시오. 여기 있는 이 기독교인들은 비록 그 수는 적지만 나는 이들과 더불어그대와 왕국보다도 큰 왕국들을 정복하고 그대보다도 강력한 군주들을 무찔러 우리의 황제 폐하께 복속시켰소. 폐하는 스페인과 전세계의 왕이시며 나는 폐하의 신하요. 우리는 폐하의 명에 따라 이 나라를 정복하러 왔으며 이는 하느님과 그의 성스러운 가톨릭 신앙을 만민에게 알리기 위함이었소.
    우리의 임무는 선한 것이므로 하늘과 땅과 그 속의 모든 것을 창조하신 하느님께서 이 일을 허락하셨고 이는 그대가 하느님을 알고 지금까지의 야만스럽고 사악한 삶에서 벗어나게 하려 하심이오. 우리가 이토록 수가 적은데도 그 많은 사람들을 이길 수 있었던 것은 바로 그러한 까닭이었소. 그대가 지금까지의 삶에서 잘못을 발견할 때, 우리가 이렇게 스페인의 국왕 전하의 명에 따라 그대의 나라에 들어옴으로써 오히려 그대에게 선행을 베풀었다는 사실을 깨닫게 될 것이오. 하느님도 그대의 자만심을 꺾고 그 어떤 인디언도 기독교인을 거스르지 못하도록 이 일을 허락하셨기 때문이요."
2023-05-05 01:32:19,"최다봄","10일차

[헤드퍼스트 디자인 패턴]

**CHAPTER 04: 객체지향 빵 굽기 - 팩토리 패턴 (느슨한 결합으로 객체지향 디자인 만들기)**

- new 연산자를 사용한다고 해서 새로운 객체가 만들어지지 않는다.
- 객체의 인스턴스를 만드는 작업이 항상 공개되어야 하는 것은 아니다.
- 오히려 모든 것을 공개했다가 결합 문제가 생길 수 있다.
- **팩토리 패턴으로 불필요한 의존성을 없애 결합 문제를 해결해보자.**

### 요약

- [문제 제기]
    - 어떻게 하면 애플리케이션에서 **구상 클래스의 인스턴스 생성 부분을** 전부 찾아내서 **애플리케이션의 나머지 부분으로부터 분리(캡술화)**할 수 있을까??
- [피자 코드 만들기] - **바뀌는 부분**을 찾아보기.
    - orderPizza 메소드 인자로 피자 종류(String type)를 전달
    - **피자 종류를 바탕으로 구상 클래스의 인스턴스를 만들고** pizza 인스턴스 변수에 그 인스턴스 대입
    - 모든 피자 클래스는 Pizza 인터페이스를 구현한다.
- [**피자 코드 추가하기]** - 신메뉴를 추가해야한다.
    - **문제:** 피자 종류가 바뀔 때마다 코드 계속 수정해야함 - **변경에 닫혀있지 않다.**
    - **인스턴스를 만드는 구상 클래스를 선택하는 부분 - 상황이 변하면 코드 변경해야함.**
- **[객체 생성 부분 캡슐화하기]**
    - 객체 생성 코드를 orderPizza 메소드에서 빼내고, 피자를 만드는 일만 처리하는 객체에 넣는다.
    - **객체 생성을 처리하는 클래스 = 팩토리(Factory) ⇒ SimplepizzaFactory**
    - 더이상 orderPizza 메소드에서 “어떤” 피자를 만들지 고민 X
    - 팩토리 클래스를 구현한 후 어떻게 할지 생각해봐야함 !
- **[객체 생성 팩토리 만들기]**
    - **SimplePizzaFactory** **클래스** = 클라이언트가 받을 피자를 만든다. (객체 생성하는 일만함)
        - **createPizza() 메소드**를 정의 = 클라이언트가 새로운 객체 인스턴스 만들 때 호출
- **[클라이언트 코드 수정하기]**
    - PizzaStore에 SimplePizzaFactory의 레퍼런스를 저장한다.
    - **PizzaStore의 생성자에 팩토리 객체가 전달된다.**

### 정리 (다시 살펴보기)

- **PizzaStore**
    - 팩토리를 사용하는 클라이언트.
    - SimplePizzaFactory로부터 피자 인스턴스를 받는다.
- **SimplePizzaFactory**
    - 피자 **객체를 생성**하는 **팩토리**.
    - 이 애플리케이션에서 유일하게 **구상 Pizza 클래스를 직접 참조**하는 부분
- **Pizza**
    - 팩토리에서 만드는 피자
    - Pizza 클래스는 **메소드를 오버라이드해서 쓸 수 있도록 추상 클래스로 정의**
        - CheesePizza, VeggiePizza …
        ⇒ 팩토리에서 생산하는 제품에 해당하는 **구상 클래스**
        - **각 피자는 Pizza 인터페이스를 구현해야하고, 구상 클래스여야한다.**

### 발췌

- **간단한 팩토리(Simple Factory)**는 디자인 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 **관용구**에 가깝습니다.
- 디자인 패턴을 얘기할 때, “인터페이스를 구현한다”라는 표현이 항상 “클래스를 선언하는 부분에서 implements 키워드를 써서 어떤 자바 인터페이스를 구현하는 클래스를 만든다.” 라고 생각하면 안 된다.
- **일반적으로 어떤 상위 형식(클래스와 인터페이스)에 있는 구상 클래스는 그 상위 형식의 ‘인터페이스를 구현하는’ 클래스라고 생각하면 된다.**"
2023-05-05 07:04:49,"김형우","삭제된 메시지입니다."
2023-05-05 07:05:06,"김형우","[9일차]
https://engineer-diary.tistory.com/207"
2023-05-05 08:55:12,"박소환","잉? 9일차인데 112p 인가요??"
2023-05-05 09:08:56,"김형우","헐"
2023-05-05 09:09:23,"김형우","도메인주도 페이지랑 데이터중심 페이지랑 헷갈렸네요...;;;;;;;;;;"
2023-05-05 09:27:49,"강민규","여러분 좋은 휴일입니다! 오늘도 루틴이 망가지지않게 신경써보아요"
2023-05-05 09:28:09,"강민규","사진"
2023-05-05 10:32:50,"김형우","[수정본]
4일차 : https://engineer-diary.tistory.com/194
5일차 : https://engineer-diary.tistory.com/199
6일차 : https://engineer-diary.tistory.com/200
7일차 : https://engineer-diary.tistory.com/203
8일차 : https://engineer-diary.tistory.com/204
9일차 : https://engineer-diary.tistory.com/207
—
[제출본]
10일차 : https://engineer-diary.tistory.com/208
11일차 : https://engineer-diary.tistory.com/209

번거롭게해서 죄송합니다 ㅠㅠ
@박소환 언급 감사합니다!
"
2023-05-05 10:34:11,"박소환","뜻밖의 예습하셨네요 ㅎㅎ"
2023-05-05 13:50:01,"다운","10일차

사피엔스

요약
호주나 아메리카 등의 대형동물 멸종하는데에는 기후변화가 아닌 사피엔스때문이다.

기후변화가 원인이라면 해양동물의 개체수도 함께 타격을 입었을 것이다.
인류가 외부세계의 또 다른 지역으로 정착할 때마다 대량멸종이 일어났고 그 방법 중 원인은 대형동물은 번식속도가 느려 사망률이 급격하게 높아졌고 사피엔스는 화전법에 통달했기 때문이다 

사피엔스가 외부세계로 간 이유는 동물성 단백질이나 전쟁, 자연재해 등이 있다 

발췌

사피엔스가 지나간 자리에는 희생자들의 흔적이 길게 남았다

일부학자들은 우리종에 면죄부를 주고 싶어 한다.


"
2023-05-05 13:55:12,"최희윤","10일차 DDD
https://www.notion.so/05-04-DDD-10-64a64100e20349409b394224563d862f?pvs=4"
2023-05-05 14:08:22,"다운","11일차

사피엔스

요약
농업혁명은 사피엔스가 몇몇 동물과 식물 종의 삶을 조작하는 데 시간을 보내게 된 것을 의미한다

이는 세계 여러 지역에서 함께 생겨났고 인구폭팔과 디스크 탈출증, 관절염 등을 낳았다.

하지만 경작은 단위 토지당 식량생산을 크게 늘렸고 호모사피엔스가 기하급수적으로 늘어났다.

발췌: 어느 종이 성공적으로 진화했느냐의 여부는 굶주림이나 고통의 정도가 아니라 dna 이중나선 복사본의 개수로 결정한다. 
한 회사의 경제적 성공은 직원들의 행복이 아니라 오직 은행잔고의 액수로만 측정된다.

밀이 우리를 길들였다

밀은 인간 사이의 폭력에 대한 안정망을 제공하지도 않았다

오히러 인구폭발과 방자한 엘리트를 낳았다"
2023-05-05 14:09:03,"뚯뚜오","10일차 총균쇠
요약
남아메리카의 잉카제국의 아타우알파 뿐 아닌 중앙아메리카의 아즈텍제국의 몬테수마도 유럽인들의 말, 총, 철제 냉병기, 해양기술, 기만전술, 중앙집권식 정치체제 등에 의해 국력에 비해 어이없고 허무하게 무너짐.
    
그런데 왜 비유럽인들은 이런 장점을 얻지 못했을까?
3장 유럽이 세계를 정복한 힘의 원천 끝
    
비유럽인들이 무너지게 된 궁극적 원인과 선행조건 탐구 (수렵채집민, 목축민, 농경민이 살아가고 발전하는 방식)
4장 식량 생산의 기원
    
발췌    
비록 피사로 자신은 문맹자였지만 그래도 그는 문자 문화권에 속한 사람이었다. 스페인인들은 책을 통하여 유럽에서 멀리 떨어진 동시대의 수많은 문명에 대해 알고 있었으며 유럽의 수천 년 역사를 알고 있었다. 피사로가 아타우알파를 잡으려고 매복한 것은 바로 코르테스가 (아즈텍의 몬테수마에게) 성공을 거두었던 작전을 모방한 것이었다.
    
간단히 말해서 문자 덕분에 스페인인들은 인간의 행동과 역사에 대한 방대한 지식을 갖고 있었다. 그와 대조적으로 아타우알파는 스페인인들에 대해 전혀 몰랐다. 또한 바다 건너에서 쳐들어온 침략자들을 일찍이 경험하지 못했을 뿐만 아니라 다른 곳에서, 다른 사람들에게, 그리고 역사적으로 앞선 다른 시대에 무수히 일어났던 유사한 침략 위협에 대해서도 전혀 듣지도 못했다. 그러한 경험의 격차 때문에 피사로는 함정을 파게 되었고 아타우알파는 그 속으로 걸어 들어갔던 것이다.
    
오늘날에는 지구상 대부분의 사람들이 직접 생산했거나 다른 사람들이 생산해 준 음식을 소비하고 있다. 현재와 같은 변화 속도가 계속된다면 앞으로 10년 이내에 그나마 남아 있던 몇몇 수렵 채집민 무리도 생활 방식을 바꾸거나 와해되거나 다 죽어버릴 것이다. 그리하여 수백 만 년 동안 지속되었던 수렵 채집민의 생활 방식은 종말을 고하게 될 것이다."
2023-05-05 14:23:28,"송예은","11일차
ddd,msa 

# 3.2 헥사고날 아키텍처와 클린 아키텍처

## 3.2.1 레이어드 아키텍처

- 프레젠테이션, 비즈니스 로직, 데이터 액세스의 3계층으로 구분하는 것이 일반적이다.
- 상위 계층은 직접적으로 하위 계층을 호출하지 않고 추상적인 인터페이스에 의존한다. 이 경우 하위 계층에서는 추상적 인터페이스를 만족하는 다양한 방식의 구현체를 선택적으로 적용할 수 있다.
- 애플리케이션에서는 비즈니스 로직이 핵심 영역이다. 비즈니스 로직을 보통 고수준 영역이라고 하고, 프레젠테이션 계층 및 데이터 액세스 계층을 저수준 영역이라고 한다. 고수준 영역은 핵심 영역이므로 보호를 받아야 하고, 따라서 저수준 영역의 변경이나 확장에 영향을 받지 않아야 한다. 그러나 일반적인 레이어트 아키텍처의 규칙만 따르면 고수준 영역이 저수준 영역에 의존하게 되고 영향을 받게 된다.
- 이를 해결하기 위해 의존성 역전 원칙을 적용해야 한다. 인터페이스를 고수준의 비즈니스 로직 계층에서 정의하여 기존의 위에서 아래로 흘렀던 의존 관계를 역전시키고 고수준 영역이 저수준 영역의 변경에 영향을 받지 않게 하는 것이다.

## 3.2.2 헥사고날 아키텍처

- 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 존재한다. 단방향 계층구조에서는 이러한 점을 지원하기 힘들다. 다방면으로 열려있는 헥사고날 아키텍처는 이러한 문제점을 해결할 수 있다.
- 헥사고날 아키텍처에서는 고수준의 비즈니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부 영역으로 나눈다. 내부 영역은 순수 비즈니스 로직을 표현하는 기술 독립적인 영역이다. 그리고 외부 영역과 연계되는 포트를 가지고 있다. 외부 영역은 외부에서 들어오는 요청을 처리하는 인바운드 어댑터와 비즈니스 로직에 의해 호출되어 외부와 연계되는 아웃바운드 어댑터로 구성된다.
- 헥사고날 아키텍처의 가장 큰 특징은 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게 하는 것이다. 이를 가능하게 하는 것이 내부 영역에 구성되는 포트다.
- 인바운드 포트는 내부 영역의 사용을 위해 표출된 API이며, 외부 영역의 인바운드 어댑터가 호출한다. 아웃바운드 포트는 내부 영역이 외부를 호출하는 방법을 정의한다.
    
    아웃바운트 어댑터가 아웃바운드 포트에 의존해서 구현된다.
    
- 인바운드 어댑터로는 REST API를 발행하는 컨트롤러, 이벤트 메시지 구독 핸들러 등이 될 수 있고,
아웃바운드 어댑터로는 데이터 액세스 처리를 담당하는 DAO, 이벤트 메시지를 발행하는 클래스, 외부 서비스를 호출하는 프락시 등이 될 수 있다.

## 3.2.3 클린 아키텍처

- 로버트 C. 마틴이 제안한 아키텍처로, 헥사고날 아키텍처의 아이디어와 유사하다.
- 소프트웨어는 행위 가치와 구조 가치로 나뉘며, 소프트웨어를 부드럽게 만드는 것이 구조 가치이므로 구조 가치가 더 중요하다.
- 소프트웨어를 부드럽게 유지하는 방법은 구조 중에서 선택할 수 있는 것을 가능한 한 오래 열어두는 것이다.
- 구조
    
    여러 겹으로 둘러싸인 구조이며, 중앙부터 소개한다.
    
    - 엔티티
        
        해당 도메인의 업무를 규정하는 핵심 규칙 (비즈니스 업무 규칙)
        
        핵심 규칙은 데이터와 본질적으로 결합돼 있으므로 객체로 쉽게 만들 수 있다.
        
    - 유스케이스
        
        유스케이스는 자동화된 시스템을 사용하는 처리 절차를 기술한다.
        
        유스케이스는 애플리케이션에 특화된 업무 규칙을 표현하며, 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다.
        
        엔티티 같은 고수준 영역은 저수준의 유스케이스 영역을 알게 해서는 안된다.
        
    - 세부사항
        
        유스케이스를 감싸고 있는 나머지 모든 영역.
        
        입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
        
        이렇게 분리하면 테스트 용이성, 개발 독립성, 배포 독립성을 강화할 수 있다."
2023-05-05 14:35:34,"Bo","10일차 
헤드퍼스트 
### 요약

> new 키워드를 조심하자
> 
- 구상에 의존하면 유연성이 떨어진다

> 피자집 상황
> 
- 변하는 부분 ( type (인자로 받은) 에 따라 피자를 생성하는 부분 → 변하는 부분 ( 피자 타입 추가 / 삭제시 변하 )
- 변하지 않는 부분 ; 피자를 준비, 굽기, 자르기 등 일련의 과정
- 변하는 부분을 분리하고, 생성하는 것을 위임해서 팩토리를 만들었다.
- 팩토리도 지역마다 달라 여러가지의 팩토리가 생겼고, store 에서 이 팩토리를 필드로 갖게해서 지점별 store 에서 피자를 만드는 방식으로 구성

> 문제
> 
- 이들을 통합 관리할 수 있는 프레임 워크 필요

### 발췌

> 간단한 팩토리
> 
- Simple Factory 는 디자인 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝다. 패턴은 아니다

> 인터페이스 구현
> 
- 디자인 패턴에서 인터페이스를 구현한다는 표현은 자바 interface 를 implements 키워드 써서 구현한다는 말이 아니다. 어떤 상위 형식에 있는 구상 클래스는 그 상위 형식의 ‘인터페이스를 구현’ 하는 클래스라고 생각하면 된다 ( 추상 클래스 포함 )

### 메모

- 팩토리 메서드를 만들 때 기계적으로 정적 메소드를 썼는데, 그렇게 되면 객체 생성 메소드의 행동을 변경할 없는 단점이 있는 것을 알았다"
2023-05-05 15:03:52,"뚯뚜오","11일차 총균쇠   
    요약
    가축화, 작물화 된 야생동식물을 다루며 얻게 된 직, 간접적 이점 : 먹고사니즘의 해결
    수렵채집사회보다 농경사회가 발전하기 유리한 이유 : 잉여식량으로 가능해진 기능전문가들의 출현
    4장 식량 생산의 기원 끝
    
    농업이 발전하게 된 배경과 몇몇 지역의 농업 발전이 적합한 환경이었음에도 발전되지 않았던 이유 추측
    5장 인류 역사가 갈라놓은 유산자와 무산자 끝
    
    발췌
    가축을 소유한 인간 사회의 경우 가축이 인간에게 먹거리를 제공하는 데는 네 가지 방식이 있다. 고기, 젖, 비료를 주고, 쟁기를 끄는 것이다.
    
    일단 거처가 고정되면 그때부터는 산아 간격을 단축시킬 수 있기 때문에 인구 밀도가 높아진다.
    
    수렵 채집민의 어머니가 야영지를 옮길 때는 몇 가지 소지품과 함께 단 한 명의 아이만을 옮길 수 있을 뿐이다. 그러므로 먼저 태어난 아이가 뒤처지지 않고 부족을 따라갈 수 있을 만큼 걸음이 빨라질 때까지는 다음 아이를 낳을 수 없는 것이다. 실제로 유랑 생활을 하는 수렵 채집민들은 수유기의 무월경, 금욕, 유아 살해, 낙태 등을 통하여 4년 정도의 터울을 유지한다. 그와 대조적으로 (농경이 중심인) 정주형 사회에서는 어린 아이들을 데리고 다니는 문제로 고민할 필요가 없으므로 제대로 먹일 수만 있다면 얼마든지 낳을 수 있다. 농경 민족의 산아 간격은 약 2년으로, 수렵 채집민의 절반에 불과하다. 직접적으로 식량 생산을 하는 농경 민족들은 출산율이 높고 단위 면적당 더 많은 사람들을 먹여 살릴 수 있기 때문에 수렵 채집민보다 인구밀도가 훨씬 더 높아진다.
    
    …저장된 식량이 있으면 정복 전쟁에 종교적 정당성을 부여하는 사제들, 칼이나 총기를 비롯하여 각종 기술을 발전시키는 금속 기술자 등의 숙련공, 그리고 기억력에 의존하는 것보다 훨씬 더 많은 정보를 정확하게 보존시켜 주는 필경사 등도 먹여 살릴 수 있다.
    
    인류 역사는 대부분 유산자와 무산자(농업의 힘을 가진 민족과 못 가진 민족, 또는 각기 다른 시기에 농업의 힘을 갖게 된 민족) 사이의 불평등한 갈등 관계로 이루어져 있다."
2023-05-05 15:08:51,"궈노","9일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_9_126-139.md"
2023-05-05 15:09:09,"궈노","10일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_10_140-152.md"
2023-05-05 15:09:26,"궈노","11일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_11_153-165.md"
2023-05-05 15:17:22,"김연정","11일차
초전설득
요약
우리는 주의를 기울이고 있는 대상에 인과관계를 부여. 
- 새치기 실험: 줄설때 돈주고 양해를 구할 때 금액 높아짐에 따라 허락하는 사람의 비율이 높아졌지만 실제로 받은 사람은 없었음, 돈까지 줄 정도면 정말 중요한 이유가 있나보다 생각하고 양보(사회적책임의규범)
- 타이레놀사건: 누군가 약국의 타이레놀에 청산가리를 주입하여 다수의 피해자가 생긴 사건. 최조로 발견된 약품의 제조번호 2880,1910이 많은 관심을 받아 이 숫자로 복권을 구입하는 자들이 전례없이 많아짐(초점의 대상이 원인이 됨)
- 피터라일리사건: 얼굴이 잘 보이는 쪽의 말이 토론에서 더 많은 영향을 끼침. 여러 변수를 바꿔도 결과는 동일.
- 죄가 없는 용의자에게 허위 자백을 받는 방법: 범죄 상황을 상상하도록 반복적으로 압박하는 것

메모

만약 언젠가 용의자로 지목될 일이 생기면 무죄니까 언젠가 밝혀지겠지라고 증언만 하지 말고 가능하면 변호사 선임을 해야겠다.."
2023-05-05 15:19:21,"이찬영","# 11일차
헤드퍼스트 디자인패턴 [금요일] 
153-165pg

# 요약
**CHAPTER 04. 객체지향 빵 굽기 (feat. 팩토리 패턴)**
[ 다양한 팩토리 만들기 - 피자 프랜차이즈 사업 시작 ]
피자가게 지점내기.
PizzaStrore 코드를 모든 지점에서 활용한다. 
⁉ 문제발생 : 굽는방식이나 자르는 것이 사라지거나 하는 문제 발생
해결 : PizzaStore와 피자 제작코드 전체를 하나로 묶어주는 프레임워크 만들기. + 유연성 잃으면 안됨.

[ 피자가게 프레임워크 만들기 ]
각 지점마다 달라지는 것은 ‘피자 스타일’ 뿐.
달라지는 점을 createPizza()에 넣는다.
Pizza는 추상 클래스라서 orderPizza()는 실제로 어떤 구상 클래스에서 작업이 처리되고 있는지 전혀 알 수 없다.
→ PizzaStore와 Pizza는 서로 완전히 분리되어 있다.
orderPizza() -호출→ createPizza() -받음→ Pizza의 서브클래스

서브클래스에서 피자 종류를 실시간으로 결정하는 것이 아니라, 피자 종류는 어떤 서브클래스를 선택했느냐에 따라 결정된다.

[ 팩토리 메소드 선언하기 ]
1. 팩토리 메소드를 추상 메소드로 선언해서 서브클래스가 객체 생성을 책임지도록 합니다.
2. 팩토리 메소드는 특정 객체를 리턴하며, 그 객체는 보통 슈퍼클래스가 정의한 메소드 내에서 쓰입니다.
3. 팩토리 메소드는 클라이언트(슈퍼클래스에 있는 orderPizza())같은 코드에서 실제로 생성되는 구상 객체가 무엇인지 알 수 없게 만드는 역할도 합니다.

모든 팩토리 패턴은 객체 생성을 캡슐화한다. 

팩토리 메소드 패턴은 서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화한다.
- 생산자(Creator) 클래스
    - PizzaStore, NYPizzaStore, ChicagoPizzaStore
- 제품(Product)  클래스
    - Pizza의 종류 : 뉴욕스타일치즈피자, 시카고 스타일치즈 피자 등등"
2023-05-05 15:52:00,"Bo","# 11일차 
헤드퍼스트 
### 요약

> 피자가게 진화
> 
- 인스턴스 생성을 팩토리로 분리했지만, 다양한 팩토리 ( 지역에 따라 만드는 피자가 다름 ) 가 나오게 되었고, Pizzastore 에서 생성시 인자로 팩토리를 받아서 피자를 생성하는 방식
- 관리가 어렵고, 이를 모두 통합하는 방식이 필요해졌음
- PizzaStore 을 추상 클래스로 만들고 추상 메소드로 createPizza 를 둔다. 이를 구현한 각 지역 PizzaStore 에서 createPizza 를 오버라이딩 하며 각 지역에 맞는 피자를 생성하게 변경했다.

> 팩토리메서드 패턴
> 
- PizzaStore 의 서브클래스에서 어떤 피자를 만들지 결정하게 된다 ( 어떤 서브클래스를 사용하느냐에 따라 피자 종류가 달라진다 )
- 팩토리 메서드는 객체 생성을 이와 같이 서브 클래스에 캡술화 할 수 있다
- 슈퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리할 수 있다

### 발췌

> 팩토리 메소드 패턴
> 
- 모든 팩토리 패턴은 객체 생성은 캡슐화한다
- 팩토리 메소드 패턴은 서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡술화한다"
2023-05-05 16:22:14,"이소민","11일차 제출

[헤드퍼스트 디자인패턴]

📍요약
각기 다른 팩토리들이 있을 때 클라이언트에서 필요할 때마다 팩토리를 골라쓰는 것은 또 다른 문제를 야기한다. 클라이언트가 코드 구현에 적절한 팩토리를 가져다 그대로 구현한다는 보장이 없다는 것이다. 이럴 땐 클라이언트가 아닌 서브클래스에 주도권을 주도록 하면 된다. 팩토리 메소드라는 개념을 이용하면 되는데 이는 객체 생성을 서브클레스에 캡슐화하여 슈퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리할 수 있다.


📍발췌
팩토리 메소드는 객체 생성을 서브클래스에 캡슐화할 수 있습니다. 그러면 슈퍼클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리할 수 있습니다.

📍메모
간단한 팩토리 개념을 이해하자마자 갑자기 조금 어려워진 개념을 마주치게 되었다 팩토리 메소드에 대해 조금만 더 깊게 생각해봐야 할 것 같다"
2023-05-05 16:35:31,"리경","10일차
오브젝트

✨ 요약
#캡슐화를 지켜라
데이터 중심 설계 ex. Rectangle
코드 중복 발생, 변경에 취약. 
접근자와 수정자(get, set)는 내부 구현을 인터페이스릐 일부로 만들기에 외부에 인스턴스 변수 존재를 노출시킴.
—캡슐화 강화로 해결—> 
Class Rectangle {
  public void enlarge(int m) {
   right *= m;
  bottom *= m;
 }
}
변경의 주체를 외부의 객체에서 rectangle로 이동시켜 자신의 크기를 스스로 증가시키게 “책임 이동”함.


#스스로 자신의 데이터를 책임지는 객체
객체 설계시 “이 객체가 어떤 데이터 포함해야 하는가?” 라는 질문 분리해야함.
- 이 객체가 어떤 데이터 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야하는 오퍼레이션 무엇인가?
=> 데이터를 처리하는데 필요한 메서드를 데이터를 가지고 있는 객체 스스로 구현 및 책임지게됨
but) 여전히 캡슐화 위반. 내부 정보 노출함 + 내부 구현의 변경이 외부로 퍼져나가는 파급효과 발생됨.

#높은 결합도
캡슐화 위반으로 내부 구현이 외부로 노출됐기 때문에 결합도는 높을 수밖에 없다. 
유연한 설계를 창조하기 위해서는 캡슐화를 설계의 첫 번째 목표로 삼아야 한다.

#낮은 응집도
캡슐화를 위반했기 때문에 하나의 변경을 수용하기 위해 코드 여러 곳을 동시에 변경해야 한다는 것은 설계의 응집도가 낮다는 증거다.

✨ 발췌
코드 중복은 악의 근원이다. 따라서 코드 중복을 초래할 수 있는 모든 원인을 제거하는 것이 중요하다.

캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다. 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류일 뿐이다. 
"
2023-05-05 17:05:21,"리경","11일차
오브젝트

✨ 요약
#데이터 중심 설계의 문제점
데이터 중심 설계가 변경에 취약한 이유는
- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요
- 협력이라는 문맥 고려 않고 객체 고립시킨 채 오퍼레이션 결정하기 때문이다.

데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다
- 데이터 중심 관점에서 객체는 그저 단순한 데이터의 집합체이기에 데이터와 기능을 분리하는 방식을 따른다. 접근자와 수정자를 추가하고, 이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현하게 된다. 접근자와 수정자는 public 속성과 큰 차이 없기에 캡슐화는 무너질 수 밖에 없다.
- 데이터를 먼저 결정하고 데이터를 처리하는데 필요한 오퍼레이션을 나중에 결정하는 방식 또한 그렇다.

데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다
- 초점이 객체의 외부가 아닌 내부로 향함. 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다.
- 객체의 인터페이스에 구현이 노출돼 협력이 구현 세부사항에 종속돼 잇고, 그에 따라 내부 구현 변경시 협력 객체가 모두 영향 받을 수 밖에.

Chapter5. 책임 할당하기
데이터 중심 설계로 발생하는 문제를 해결할 수 있는 기본적 방법은 책임에 초점 맞추는 것.
- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

#데이터보다 행동을 먼저 결정하라
클라이언트 관점에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미. 데이터는 객체가 책임 수행하는데 필요한 재료 제공할 뿐.

#협력이라는 문맥 안에서 책임을 결정하라
객체 입장에서 책임이 조금 어색해 보여도 협력에 적합하다면 그 책임은 좋은 것.
협력을 시작하는 주체는 메시지 전송자이기에 협력에 적합한 책임이란 전송자에게 적합한 책임을 의미함. 
-> 메시지를 결정한 후 객체를 선택해야함. 

메시지를 수신하기로 결정된 객체는 메시지를 처리할 '책임'을 할당받음.
메시지를 먼저 결정하기 때문에 메시지 전송자 관점에서 메시지 수신자가 깔끔하게 캡슐화됨.

#도메인 개념에서 출발
도메인 개념은 우리에게 필요한 설계 출발점을 제공할 뿐, 정리하는데 많은 시간 들이지 말고 빠르게 설계, 구현 진행하라.


✨ 발췌
- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관
리하는가는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다.

- 책임 중심 설계에서는 ""이 객체가 수행해야할 책임은 무엇인가""를 결정한 후에 ""이 책임을 수행하는데 필요한 데이터는 무엇인가""를 결정한다. 즉, 책임(행동)을 먼저 결정한 후에 객체의 상태를 결정하는 것이다.

- 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 돼야 한다. 이것은 도메인 모델이 구현을 염두에 두고 구조화되는 것이 바람직하다는 것을 의미한다. 반대로 코드의 구조가 도메인을 바라보는 관점을 바꾸기도 한다.

- 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다. 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수 있다."
2023-05-05 18:23:09,"호02","11일차 제출

[초전 설득]

1. 요약 
 - 청산가리를 주입하여 사망자를 발생시킨 타이레놀 사건에서 부각된 제품 번호 2880과 1910이 많은 관심을 받자 해당 번호로 로또를 사는 현상이 발생하였다. 물론 로또 당첨이 될 리는 없었다.
 - 피터 마일리는 엄마를 죽인 용의자로 의심을 한 경찰들은 갖은 심문 방법을 통해 그에게 허위 자백을 받아냈다. 
 
 
2. 메모
 - 제품 번호가 부각되자 로또를 사는 현상이 발생한 건 굉장히 흥미로웠다.
 - 당시 2880 코인이 있었다면 떡상 했을 거 같다."
2023-05-05 21:44:16,"최윤지","11일차
[7가지코드]

https://quiet-jade-e60.notion.site/11-0505-27c2bd601e45401187ca2150e18c600d"
2023-05-05 21:55:46,"박소환","11일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/92"
2023-05-05 22:08:47,"강민규","여러분 휴일 제대로 즐기고 계신가요? 2주차도 끝이 보입니다~ 이주차가 심적으로 가장 힘들 때입니다. 이번주만 잘 넘기시면 통계적으로 약 90프로 완주하니 힘내봅시다!

@수정 @한종우 @김형우 선생님들은 오늘까지 이틀치 분량으로 가봅시다~"
2023-05-06 09:00:48,"강민규","여러분 좋은 아침입니다. 오늘 비가 많이 오네요 집에서 따뜻하게 커피 한잔 하시면서 책 읽어보는건 어떨까요?"
2023-05-06 09:01:07,"강민규","사진"
2023-05-06 09:01:09,"김연정","12일차
초전설득
요약
자백을 받아내기 위한 기술은 범죄 수사관뿐만아니라 중국 문화혁명 당시 반공산주의 스파이를 잡기위한 과정도 아주 유사한 방식으로 이루어짐. 아서 밀러 작가는 책 속의 피터의 사례를 <크루서블> 연극을 통해 나타냄

발췌
자백하면 무죄는 없다
같은 무죄라도 자백하면 더 무거운 처벌을 받는다. 

메모
책에서는 폭력이나 고문없이 허위자백을 받아낼 수 있다고 했지만 몇 일간 잠도 못자게하고 생각을 주입시킨 것도 일종의 고문처럼 보인다."
2023-05-06 09:02:18,"김연정","초전설득 3주차
13일차  ~4장 끝
14일차 ~ 가정용 화재경보기 내용
15일차 ~초점의 대상을 빠르게 바꾸기 전
16일차 ~5장 끝
17일차 ~미스터리를 활용하라 전
18일차 ~PART2(초전설득상황을설계하라)
19일차 ~단어에대한자연스러운노출 전
@쏘이쏘이양 @호02 참고하세욥🤩"
2023-05-06 12:43:08,"호02","@김연정 감사합니다~"
2023-05-06 15:26:56,"송예은","12일차
ddd,msa

# 3.3 마이크로서비스의 내부 구조 정의

## 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스

- 마이크로서비스의 내부 구조를 정의할 때, 마이크로서비스 시스템에서 정의해야 할 마이크로서비스 내부 구조가 다양할 수 있다는 것이다. 마이크로서비스는 폴리글랏한 내부 구조를 가질 수 있기 때문이다.
- 지향하는 원칙들
    - 지향 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮춰야 한다.
    - 비즈니스 로직 영역을 기술 기반 영역으로부터 분리해야 한다.
    - 기술 중심의 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다.
    - 고수준 영역은 저수준 영역에 의존하지 않아야 한다.
    - 저수준 영역은 언제든 교체, 확장 가능해야 하며, 이 변화가 고수준 영역에 영향을 미치면 안된다.
    - 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전 원칙을 적용한다.
    - 인터페이스는 고수준 영역에 존재해야 하며, 저수준 어댑터가 이를 구현한다.

## 3.3.2 내부 영역 - 업무 규칙

- 업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재한다.
- 서비스 인터페이스는 외부 영역이 내부 영역에 대해 많이 알지 못하게 하는 역할을 한다.
- 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스는 의존 관계 역전의 원칙을 지원한다.
- 서비스와 도메인은 클린 아키텍처의 유스케이스와 엔티티의 역할과 같다. 도메인은 비즈니스 개념을 표현하고 서비스는 도메인을 활용해 시스템 흐름 처리를 수행한다.

### 트랜잭션 스크립트 패턴

- 도메인 객체가 행위를 가지고 있지 않고, 모든 비즈니스 행위가 서비스에 있다.
- 도메인 객체는 정보 묶음일 뿐이고, 서비스는 점점 비대해져 유지보수가 어려워진다.
- 절차식 프로그래밍 방식이므로 간단한 비즈니스를 처리할 때 적용하는 것이 좋다.

### 도메인 모델 패턴

- 도메인 객체가 데이터와 비즈니스 행위를 가지므로, 정보 은닉성을 가진다.
- 객체지향적이므로 복잡한 비즈니스 로직을 처리하는 데 유용하므로, 복잡한 비즈니스 로직이 많은 마이크로서비스의 구조로 선택하는 것이 좋다.

### 도메인 주도 설계의 애그리거트 패턴

- 도메인 모델링에서 객체 간의 관계를 참조로 정의할 경우, 일대다 관계로 쉽게 사용할 수 있지만 업무가 복잡해지면 관계가 복잡해지고 무거워진다.
- 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴이다.
- 엔티티와 값 객체가 개념적으로 묶인 모음 전체를 애그리거트라고 한다.
- 애그리거트 패턴 규칙
    - 애그리거트 루트만 참조한다.
    - 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. 수정할 때도 마찬가지다.
    - 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.
    - 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리거트를 함께 수정하는 실수를 방지한다.
    - 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다."
2023-05-06 21:16:39,"뚯뚜오","12일차 총균쇠

    요약
    수렵채집민의 생활 요약 : ‘고달프고 야만스럽고 짧은 삶’
    
    문명의 유혹
    
    대형 포유류의 멸종, 작물화 된 야생식물 범위 확대, 채집 저장 관련기술의 부재, 인구의 증가로 인해 수렵채집민은 농경정주로 서서히 전환하게 됨.
    
    6장 식량 생산민과 수렵 채집민의 경쟁력 차이
    
    발췌    
    지상의 모든 사람들이 수렵 채집민이었을 때가 있었다. 그런데 왜 식량 생산을 시작하게 되었을까?
    
    이웃 민족들이 식량을 생산하는 것을 지켜보면서도 끝까지 그 축복이라는 식량 생산을 받아들이지 않고 수렵 채집민으로 남아 있었던 경우도 많다.
    
    인구 밀도의 상승 때문에 사람들이 식량 생산을 시작할 수밖에 없었을까? 아니면 식량 생산 택에 인구밀도가 상승할 수 있었을까?"
2023-05-06 21:48:04,"이소민","12일차 제출

[헤드퍼스트 디자인패턴]

📍요약
팩토리 메소드 패턴에서는 사용하는 서브클래스에 따라 생산되는 객체 인스턴스가 결정된다. 
그렇기 때문에 객체 인스턴스를 직접 만들지 않아 구상 클래스에 의존해야 하는 부담감을 덜을 수 있다. 이는 의존성 뒤집기 원칙이라고 하는데, 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다는 특징이 있다. 이런 의존성 뒤집기 원칙을 지키는 방법은 첫째, 변수에 구상 클래스의 래퍼런스를 저장하지 않는 것. 둘째, 구상 클래스에서 유도된 클래스를 만들지 않는 것. 셋째, 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 않는 것이 있다.


📍발췌
의존성 디자인 원칙 : 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.


📍메모
내가 헷갈리던 부분이 책 Q&A에 나왔다. 팩토리 메소드와 간단한 팩토리의 차이점은? 간단한 팩토리는 일회용 처방에 불과한 반면, 팩토리 메소드 패턴을 사용하면 여러 번 재사용이 가능한 프레임워크를 만들 수 있다 라는 것이다."
2023-05-06 22:02:50,"최다봄","11일차

[헤드퍼스트 디자인 패턴]

**CHAPTER 04: 객체지향 빵 굽기 - 팩토리 패턴 (느슨한 결합으로 객체지향 디자인 만들기)**

### 요약

- 모든 팩토리 패턴은 객체 생성을 캡슐화한다.
- 팩토리 메소드 패턴은 서브 클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화한다.
- 팩토리 패턴의 클래스
    - **생산자(Creator) 클래스**
        - 추상 생산자 클래스
            - 서브 클래스에서 제품(객체)을 생산하려고 구현하는 팩토리 메소드(추상메소드) 정의
            - 생산자 자체는 어던 구상 제품 클래스가 만들어질지 미리 알 수 없음
        - **구상 생산자(concrete creator) 클래스**
            - 각 서브클래스마다 고유의  제품 만들 수 있다.
    - **제품(product) 클래스**
        - 팩토리는 제품 생산.
        - 구상 클래스."
2023-05-06 23:44:52,"한종우","12일차

[헤드퍼스트 디자인 패턴]

- 각 PizzaStore 에는 팩토리 메소드를 통해 각각의 스타일 피자를 만드는 모든 방법이 캡슐화되어 있다
- 팩토리 메소드 패턴에서는 객체를 생성할 때 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 된다.
- 구상 생산자 클래스가 하나밖에 없더라도 팩토리 메소드 패턴은 제품을 생성하는 부분과 사용하는 부분을 분리할 수 있어 유용하다
- 팩토리 메소드와 생산자 클래스는 꼭 추상으로 선언해야 하는 것은 아니다.
- 매개변수 팩토리 메소드를 사용하면 형식 안정석(type-safety)로 인해 런타임 오류가 발생할 수 있다. 따라서  매개변수 형식을 나타내는 객체들 만들거나, 정적 상수, enum을 사용하여 형식 안정성을 조금 더 잘 보장해 줄 수 있도록 한다
- 팩토리 메소드 패턴과 간단한 팩토리가 비슷하지만 팩토리 메소드 패턴을 사용하면 여러 번 재사용이 가능한 프레임워크를 만들 수 있다. 간단한 팩토리는 객체 생성을 캡슐화하는 방법을 사용하긴 하지만 팩토리 메소드처럼 생성하는 제품을 마음대로 변경할 수 없기 때문에 더 유연하지 않다.
- 팩토리 패턴은 인스턴스를 만드는 행동을 캡슐화해주는 테크닉이다
- 팩토리를 사용하면 객체 생성 코드를 한 객체 또는 메소드에 넣어 코드 중복을 피할 수 있고 한 군데만 관리하면 되어 장점이 있다. 또한 객체 인스턴스를 만들 때 인터페이스를 바탕으로 프로그래밍할 수 있어 유연성과 확장성이 뛰어난 코드를 만들 수 있다
- 의존성 뒤집기 원칙 : 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만드는 것
- 의존성 뒤집기 원칙에 따르면, 구상 클래스처럼 구체적인 것이 아닌 추상 클래스나 인터페이스와 같이 추상적인 것에 의존하는 코드를 만들어야 한다
- 객체 지향 디자인을 할 때 일반적으로 생각하는 방법과 반대로 뒤집어서 생각을 해야 한다. 의존성이 위에서 아래로 내려가기만 했던 것과는 반대로 뒤집어져 있다. 고수준 모듈과 저수준 모듈이 둘 다 하나의 추상 클래스에 의존하게 되는 것이다
- 의존성 뒤집기 원칙을 지키는 방법
    - 변수에 구상 클래스의 레퍼런스를 저장하지 말자
    - 구상 클래스에서 유도된 클래스를 만들지 말자
    - 베이스 클래스에 이미 구현되어 있는 메소드를 오바라이드하지 말자"
2023-05-07 00:58:58,"최희윤","11일 DDD
https://www.notion.so/05-05-DDD-11-a4aa0cdbfb0a49289a20eb8fe4d53807?pvs=4"
2023-05-07 01:01:40,"김용기","12일차
DDD MSA 

# 3.3 마이크로 서비스의 내부 구조 정의

## 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스

- 마이크로서비스의 내부 구조를 정의할 때 반드시 고려해야 할 한 가지는 마이크로서비스 시스템에서 정의해야 할 마이크로서비스의 내부 구조가 다양할 수 있따는 것이다. 각 서비스의 개발 언어와 저장소가 다양하고 아키텍처 구조까지도 다양할 수 있다.
- 마이크로서비스 아키텍처에서 각 서비스는 각기 목표와 활용도에 따라 명확하게 분리돼야 하고, 각 서비스의 목적에 따라 적절한 개발 언어 및 저장소, 내부 아키텍처를 정의하는 것이 바람직하다.
- 응집성을 높이고 의존도를 낮추게 해야한다.
- 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.
- 저수준의 외부 영역과 고수준의 내부 영역으로 구분한다.
- 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.
- 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 고수준 영역에 영향을 줘선 안된다.
- 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전의 원칙을 사용한다.
- 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현한다.

## 3.3.2 내부 영역 - 업무 규칙

- 업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페잇, 도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재한다.
- 서비스와 도메인은 클린 아키텍처의 유스케이스와 엔티티의 역할과 같다. 도메인은 비즈니스 개념을 표현하고 서비스는 도메인을 활용해 시스템 흐름 처리를 수행한다.

### 트랜잭션 스크립트 패턴

- 모든 비즈니스 행위의 책임은 서비스에 있다. 서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행한다.
- 비즈니스가 복잡해질 경우 서비스 코드 양이 점점 증가하는 등 데이터베이스 중심 아키텍처에서 겪었떤 문제점이 발생할 여지가 크다. 따라서 간단한 비즈니스를 처리할 때 적용하는 겂이 좋다.

### 도메인 모델 패턴

- 도메인 객체가 데이터뿐만 아니라 비즈니스 행위를 가지고 있으며, 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다.
- 도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행하고, 서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임해서 처리한다.
- 서비스의 책임들이 도메인으로 적절히 분산되기 때문에 서비스가 비대해지지 않고 서비스 메서드는 단순해진다.

### 도메인 주도 설계의 애그리거트 패턴

- 애그리거트 패턴은 점점 복잡하질 수 있는 객체 모델링의 단점을 보완한 패턴이다.
- 업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고 점점 참조 관계까 복잡해지고 무거워질 수 있다.
- 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴이다.
- 애그리거트 루트만 참조한다.
- 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다.
- 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.
- 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다."
2023-05-07 12:09:06,"다운","12일차

사피엔스

요약
이동하는 사피엔스들은 가끔 먹는 밀알이 화전법이나 기후덕분에 무심코 퍼져나갔고 나중에는 정착마을이 형성됐다.
그들은 곡물을 더 정성스럽게 가공했는데 이에 식량공급이 증가하자 인구가 기하급구적으로 늘게 되었다. 곡물죽으로 모유를 일찍 떼게 되자 전염병이 들끓었고 도둑이 생겼으며 가뭄에 더 취약해 졌지만 인구증가로 다시 수렵채집생활을 할 수 없었다. 

하지만 테페에서 발견된 유적지를 봤을때 밀 경작의 목적은 정상적인 식량공급을 늘리기 위해서가 아닌 사원의 건설과  운영에 필요한 식량을 공급하기 위해서 이다

곡물거래 뿐만 아니라 양,염소, 돼지 등도 진화를 이루었는데 사피엔스가 먹기 쉽게 더 순하고 근육이 연약해 졌다. "
2023-05-07 13:47:58,"최윤지","12일차
[7가지코드]

https://quiet-jade-e60.notion.site/12-0506-68e35fb092354af7a5ed5e9a4a63780b"
2023-05-07 13:54:48,"Bo","12일차 
헤드퍼스트
### 요약

> 팩토리 메소드 패턴
> 
- 팩토리 메소드 패턴은 바뀌는 부분은 캡슐화 하라는 원칙을 적용한 것이다.
- 모든 팩토리 패턴은 객체 생성을 캡슐화 한다. 팩토리 메소드 패턴도 마찬가지.
- 팩토리 메소드 패턴은 서브클래스에서 팩토리 메소드를 오버라이드 하기 때문에, 어떤 서브 클래스를 쓰느냐에 따라 어떤 구상 클래스가 만들어질지 결정 된다
    - 흔히 팩토리 메소드 패턴에서는 어떤 클래스의 인스턴스를 만들지를 서브클래스에서 결정한다는 말이 바로 이 말
    - 제품을 생산하는 클래스는 구상 생산자라고 부른다
- 장점
    - 객체 생성 코드를 한 곳에 몰아 관리가 용이하고, 중복을 제거할 수 있다.
    - 객체 생성시에 이 인터페이스만 사용하면 되니까 유연성, 확장성 ( 지역 피자 추가 가능 ) 이 증가한다.

> 의존성 뒤집기 원칙
> 
- 맨 처음 코드에서는 PizzaStore 가 구체적인 구상 클래스 ( NYStyleCheesePizza ) 에 의존했다면, 팩토리 메소드 패턴을 적용하면서 Pizza 라는 추상화된 것에 의존하게 되었으며, 의존 받던 구상 클래스 ( NYStyleCheesePizza ) 가 추상화된 것에 의존 (Pizza ) 하게 되었다. (의존성 역전)

### 발췌

> 팩토리 메소드 패턴 정의
> 

<aside>
💡 객체를 생성할 때 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정한다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 된다

</aside>

> 의존성 뒤집기 원칙
> 

<aside>
💡 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다

</aside>

> 의존성 뒤집기 원칙을 지키는 방법
> 
- 변수에 구상 클래스의 래퍼런스를 저장하지 말자
- 구상 클래스에서 유도된 클래스를 만들지 말자 ( NYPIzza 를 만들지 말고 Pizza 를 만들자 )
- 베이스 클래스에 이미 구현되어있는 메소드를 오버라이드하지 맙시다
- 이 원칙들을 항상 지켜야 하는 것은 아님

### 메모"
2023-05-07 15:53:09,"박소환","12일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/93"
2023-05-07 22:10:08,"강민규","여러분 즐거운 주말 보내고 계신가요~ 저는 홍콩에서 여러분의 출석 체크를 하고있습니다! 다행히 대부분 여러분들 잘해주고 계시군요

@쏘이쏘이양 선생님께선 내일 아침까지 금요일 분량은 반드시 해주세요~"
2023-05-08 06:40:01,"궈노","12일차
헤드퍼스트 디자인 패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_2/day_12_166-179.md"
2023-05-08 06:51:11,"강민규","사진"
2023-05-08 06:51:20,"강민규","오랜만에 출근... 괜찮으신가요? 새마음으로 월요일을 시작해봅시다~"
2023-05-08 07:00:39,"박소환","13일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/94"
2023-05-08 10:06:19,"Bo","13일차
헤드퍼스트 

### 요약

> 문제상황
> 
- 재료를 팩토리에서 공급된 애들을 쓰며 ( 재료 생성과 사용을 분리 ) 지역 별로 팩토리가 필요하다 ( 원재료 ‘군’을 만든다 )

> 원재료 팩토리 만들기
> 
- 인터페이스로 PizzaIngredientFactory 를 만들고, 각 재료 ( Dough, Sauce 를 필드로 선언한다)
- 구상 팩토리 클래스 ( 뉴욕 원재료 팩토리) 각 메소드를 생성하는 ( createDough) 생성 메소드를 오버라이드를 하여 지역에서 필요로 하는 재료를 생성한다

> 피자 만들기
> 
- 피자에서도 재료들을 필드로 선언한다 ( Dough, Sauce )
- prepare() 에서 재료들을 준비할 수 있게 추상 메소드로 선언한다
- Pizza를 구현하는 구상 클래스를 만든다 CheesePizza. 여기서 PizzaIngredientFactory를 생성시 선언하여, prepare 단계에서, 이 팩토리로 재료들을 만들도록 한다. ( douch = ingredientFactory.createDough())
- 구상 피자 지점 클래스 ( NYPizzaStore) 에서 createPizza 를 할 때, 이제 `NYStyleCheesePizza` 를 생산하지 않고, `CheesePizza` 를 생산하는 대신, 팩토리를 NYIngredientFactory 를 전달한다

> 결과
> 
- 제품(재료)사용하는 코드와 제품을 생산하는 코드를 분리했다.
- 만약 뉴욕 지점에서 시카고와 똑같은 재료를 쓰고 싶다고 하면, 시카고 팩토리로 변경하면 된다.
- 추상 팩토리는 제품 ‘군’을 위한 인터페이스를 제공한다"
2023-05-08 12:37:47,"강민규","쏘이쏘이양님을 내보냈습니다."
2023-05-08 12:42:47,"김연정","13일차
초전설득
요약
거짓 진술을 유도하는 것이 너무 빈번하여 심문 과정을 영상으로 녹화하기 시작하였지만, 특정 인물에 앵글이 고정되면 사람들의 주의가 집중되어 판단이 흐려짐, 이럴 때는 반드시 카메라 앵글을 심사관,용의자가 다 보이게 의자를 조정해서 앉고 자백하지 않는다. 모든 질문에 다 대답하지도 않는다.

커뮤니케이션 전에 우리는 상대방의 초점을 집중켜서 인관관계를 떠올리도록 하여 상당한 수용성을 얻을 수 있다.

메모
피터의 사례야말로 요즘 흔히 말하는 가스라이팅 같다. 카메라 앵글과 관련한 사례가 흥미롭다."
2023-05-08 13:34:23,"이소민","13일차 제출

[헤드퍼스트 디자인패턴]

📍요약
피자 만들기 실습에서, 이제는 피자마다 다르게 쓰이는 원재료의 특징까지도 생각해야 한다. 예를 들어 뉴욕 스타일의 피자에 들어가는 레드 소스와 시카고 스타일 피자에 들어가는 레드 소스가 서로 다르다면, 각기 다른 재료를 적절하게 공급해야 한다. 이는 원재료를 따로 뽑아 팩토리 구현을 하면 된다. 재료마다 클래스를 하나씩 만드는 것 부터 시작하면 된다는 것이다. 이때 원재료 클래스를 추상 팩토리라고 지칭한다. 추상 팩토리로 구현하면 서로 다른 상황에 맞는 코드를 조립하기에 매우 용이하다.


📍발췌
이제 팩토리로 제품을 생산하는 코드를 만듭니다. 다양한 팩토리를 전달할 수 있기에 서로 다른 방식으로 여러 가지 제품을 구현할 수 있습니다. 하지만 클라이언트 코드를 바꿀 필요는 전혀 없습니다.


📍메모
팩토리 구현을 잘 활용하면 클라이언트 코드를 바꿀 필요가 없어지기 때문에 공통적인 부분을 잘 묶어 팩토리를 구현하는 것은 중요하다. 특히 클라이언트 코드는 수정될 일이 없도록, 추상 팩토리를 적절하게 사용해보자. 추상 팩토리를 사용하면 제품군을 위한 인터페이스를 제공하기 때문에 서로 다른 방식의 여러가지 구현 방법을 이끌어 낸다는 특징이 있다. 이는 클라이언트 코드 명령에도 국한되지 않고, 의존적이지 않는 코드 구현을 할 수 있게 만든다."
2023-05-08 18:30:14,"이찬영","12일차
헤드퍼스트 디자인패턴 [토요일] 
166-179pg

# 요약

**CHAPTER 04. 객체지향 빵 굽기 (feat. 팩토리 패턴)**

[ 병렬 클래스 계층구조 알아보기 ]
생산자 클래스와 거기에 대응되는 제품 클래스는 병렬 계층구조로 볼 수 있다.

Pizza(제품 클래스)와 PizzaStore(생산자 클래스) 살펴보기
- 둘 다 추상 클래스로 시작
- 그 클래스를 확장하는 구상 클래스들을 가지고 있다.
- 뉴욕지점, 시카고 지점의 구체적인 구현은 구상 클래스들이 책임지고 있다.

[ 팩토리 메소드 패턴의 정의 ]
팩토리 메소드 패턴에서는 객체를 생성할 때 필요한 인터페이스를 만든다. 
어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.
팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 된다.

추상클래스에서 팩토리 메소드용 인터페이스를 제공한다.
추상클래스에서 구현되어 있는 다른 메소드는 팩토리 메소드에 의해 생산된 제품으로, 필요한 작업을 처리하지만, 실제 팩토리 메소드를 구현하고 제품(객체 인스턴스)을 만드는 일은 서브 클래스만 할 수 있다.
** 사용하는 서브클래스에 따라 생산되는 객체 인스턴스가 결정된다.

[ 간단한 팩토리와 팩토리 메소드 패턴의 차이 ]
간단한 팩토리가 일회용 처방이라면, 팩토리 메소드 패턴은 다회용 처방이다. (여러번 재사용이 가능한 프레임워크 만들기 가능).
간단한 팩토리는 객체 생성을 캡슐화하는 방법을 사용하긴 하지만 생성하는 제품을 마음대로 변경할 수 없기 때문에 팩토리 메소드만큼 유연하지는 않다. 

[ 팩토리의 장점 ]
- 객체 생성 코드를 전부 한 객체 또는 메소드에 넣으면 코드에서 중복되는 내용을 제거 할 수 있다.
- 객체 인스턴스를 만들 때 인터페이스만 있으면 된다.
- 인터페이스를 바탕으로 프로그래밍할 수 있어서 유연성과 확장성이 뛰어난 코드를 만들 수 있다.

[ 객체 의존성 ]
PizzaStore는 모든 피자 객체를 직접 생성해야 하므로, 이 PizzaStore는 모든 피자객체에 직접 의존이다.
피자 구상 클래스가 변경되면 PizzaStore까지도 바꿔야 할 수 있으므로, PizzaStore는 피자 클래스 구현에 의존한다.

[ 의존성 뒤집기 원칙 (Dependency Inversion Principle) ] 
-추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.
-고수준 구성요소(저수준 구성요소에 의해 정의되는 행동이 들어있는 구성요소)가 저수준 구성요소에 의존하면 안되며, 항상 추상화에 의존하게 만들어야 한다.
-구상 클래스처럼 구체적인 것이 아닌 추상 클래스나 인터페이스와 같이 추상적인 것에 의존하는 코드를 만들어야 한다.
-뒤집기 인 이유 : 객체지향 디자인을 할 때 일반적으로 생각하는 방법과는 반대로 뒤집어서 생각해야 하기 때문이다.

- 의존성 뒤집기 원칙을 지키는 법 (다 지킬 순 없지만 생각하면서 코드짜기)
    - 변수에 구상 클래스의 레퍼런스를 저장하지 말자. : 팩토리를 써서 구상 클래스의 레퍼런스를 변수에 저장하는 일을 미리 방지하자.
    - 구상 클래스에서 유도된 클래스를 만들지 말자 : 인터페이스나 추상 클래스처럼 추상화된 것으로부터 클래스를 만들어야 한다.
    - 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 말자 : 베이스 클래스에서 메소드를 정의할 때는 모든 서브클래스에서 공유할 수 있는 것만 정의해야 한다.

[ 생각 뒤집기 ]
피자 가게 → 피자 만들기 → 피자 종류.. 
뒤집으면 Pizza class → 어떤 것을 추상화할 수 있는지 생각한다. → PizzaStore의 디자인

# 발췌
💡 실행 중에 서브클래스에서 어떤 클래스의 인스턴스를 만들지를 결정하는게 아니라, 생산자 클래스가 실제 생산될 제품을 전혀 모르는 상태로 만들어진다.
💡 PizzaStore는 고수준 구성요소, Pizza클래스는 저수준 구성요소"
2023-05-08 20:04:27,"호02","12일차 제출

[초전 설득]

1. 요약 
 - 테일러 박사는 어떻게 초점의 대상이 곧 원인이 되는 현상을 실험하였다.
 - 2명의 조교를 두고 하나는 마주보고, 또 하나는 등을 지게하여 대화를 하였더니 유독 얼굴을 마주한 조교에게 대화의 주도권을 쥐려하는 점을 발견하였다.
 - 가장 잘 보이는 사람이 가장 큰 원인으로 작용하는 사례였다.
 
2. 메모
 - 좋지 않는 감정으로 서로 마주보며 얘기하는 건 오히려 관계를 더 악화시킬 수 있겠다."
2023-05-08 20:08:32,"최다봄","12일차

[헤드퍼스트 디자인 패턴]

**CHAPTER 04: 객체지향 빵 굽기 - 팩토리 패턴 (느슨한 결합으로 객체지향 디자인 만들기)**

### 요약

- **팩토리 메서드 패턴 (Factory Method Pattern)**에서는 객체를 생성할 때 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다. 팩토리 메소드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스에게 맡기게 된다.
- 팩토리의 장점
    - 객체 생성 코드를 전부 한 객체 또는 메소드에 넣어 코드에서 중복되는 내용 제거 가능
    - 관리할 때도 한 군데만 신경씀
    - 객체 인스턴스를 만들 때 인터페이스만 있으면 됨
    - 인터페이스 바탕 프로그래밍 - 유연성과 확장성 good
- 의존성 뒤집기 원칙을 지키는 법
    - 변수에 구상 클래스의 레퍼런스를 저장하지 말자
        - 팩토리를 써서 구상 클래스의 레퍼런스를 변수에 저장하는 일을 미리 방지한다.
    - 구상 클래스에서 유도된 클래스를 만들지 말자
        - 인터페이스나 추상 클래스처럼 추상화된 것으로부터 클래스를 만들어야 한다.
    - 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 말자
        - 베이스 클래스에서 메소드를 정의할 때는 모든 서브클래스에서 공유할 수 있는 것만 정의해야 한다."
2023-05-08 20:13:53,"호02","13일차 제출

[초전 설득]

1. 요약 
 - 강요된 허위 자백을 하여 유죄 판결을 받은 피터 라일리의 사례를 들어가며 초점의 대상이 원인이 되는 현상을 계속 설명한다.
 - 미국의 법관의 말을 빌리면 ""자백은 피난처라 아니라 자살이다.""라고 한다.
 - 즉, 자백을 하게 되면 그 사람에게 초점이 맞춰지고, 용의자로 몰아가기 위한 수법들이 진행된다.
 
2. 메모
 - 이래서 군대에 있을 때 중간만 해라는 말이 나왔을까?"
2023-05-08 20:21:42,"수정","12일차
헤드퍼스트 디자인 패턴
https://bold-manta-a44.notion.site/12-f1eae6ada5474db4883d42dc1c64d33b"
2023-05-08 20:22:11,"이찬영","# 13일차
헤드퍼스트 디자인패턴 [월요일] 
180-189pg

# 요약
**CHAPTER 04. 객체지향 빵 굽기 (feat. 팩토리 패턴)**
[ 원재료 품질 관리하기 ]
모든 피자는 같은 구성 요소지만, 지역마다 구성 요소를 다른 종류로 구현한다.

추상팩토리 : 제품 군을 위한 인터페이스를 제공함.
이 인터페이스로 코드와 제품을 생산하는 팩토리를 분리함.

# 발췌
💡 추상팩토리 : 제품 군을 위한 인터페이스를 제공함.
이 인터페이스로 코드와 제품을 생산하는 팩토리를 분리함."
2023-05-08 20:46:19,"수정","13일차
헤드퍼스트 디자인 패턴

- 원재료 팩토리를 만들면 원재료 관리가 가능
    - 구상 서브클래스는 원재료 팩토리를 전달받아 인스턴스 변수에 저장하고 사용
- 생성자 클래스는 어떤 재료가 들어오던 상관 없음 (의존성X)
- 코드가 실제 제품과 분리되어 있어서 다른 원재료가 필요하다면 원재료 팩토리만

- 팩토리를 사용한 피자 생성 과정
    - 구상 피자가게 클래스 인스턴스 생성 (new NYPizzaStore)
    - 피자 주문
    - 피자가게의 생산 팩토리 메소드 호출 (createPizza)
    - 피자가게에서 선택한 원재료 팩토리 인스턴스가 피자 생성자에 전달됨 (new CheesePizza(nyIngredientFactory))
    - prepare()에서 원재료 팩토리 인스턴스로 원재료 준비 시작"
2023-05-08 21:47:26,"최희윤","삭제된 메시지입니다."
2023-05-08 21:47:47,"최희윤","12일차 DDD
https://www.notion.so/05-06-DDD-12-0bd6c8ae745b4856b034f03cf77a8d20?pvs=4"
2023-05-08 22:03:33,"강민규","여러분 좋은 하루 보내셨나요? 이제 3주차가 되니 다들 잘하시는군요~ 
@리경 @김형우 여러분은 지난 주 분량 오늘 모두 하고 이번 주 깔끔하게 시작해보아요~"
2023-05-08 22:14:18,"최희윤","13일차 DDD
https://www.notion.so/05-08-DDD-13-a56df5f32d534dc0a95e7e69157936d6?pvs=4"
2023-05-08 22:46:19,"김형우","[12일차]
https://engineer-diary.tistory.com/213

[13일차]
https://engineer-diary.tistory.com/214"
2023-05-08 22:52:02,"송예은","13일차
ddd, msa

## 3.3.3 외부 영역 - 세부사항

- 외부 영역 구성
    - 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터
    - 내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터
- 어댑터는 플러그인처럼 교체, 확장에 자유롭다.
    
    내부 영역이 먼저 정의된 후 외부 영역의 세부사항은 늦게 정의돼도 상관없어야 한다.
    

### API 퍼블리싱 어댑터

REST API를 발행하는 인바운드 어댑터.

엔티티를 직접 제공하지 않고 API 필요에 맞는 DTO를 생성해서 엔티티를 변환 및 매핑해서 전달해야 클라이언트로 도메인 규칙이 유출되지 않는다.

### API 프락시 어댑터

다른 서비스의 API를 호출하는 아웃바운드 어댑터.

기술에 맞는 적절한 통신 방법을 구현해야 한다.

### 저장소 처리 어댑터

저장소 처리 어댑터 구현 시, 데이터 처리 메커니즘을 선택해야 한다. (ORM or SQL매핑)

### 도메인 이벤트 발행 어댑터

도메인 이벤트가 생성되는 위치는 내부 영역이며, 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

### 도메인 이벤트 핸들러

외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달하는 일을 수행한다.

4장
애자일에는 빨리, 자주 실패를 경험해 보는 것이 중요하므로 단순한 설계를 통해 우선 MVP를 만들어 자주 배포하는 것이 중요하다. 이를 위해 기민한 반복 주기에 적합한, 군더더기를 제거하고 핵심 활동에 집중할 수 있는 마이크로서비스 설계 및 개발 방법이 필요하다.

# 4.1 도메인 주도 설계와 마이크로서비스

- 마이크로서비스를 도출하고 내부 구조를 설계하는 데 도메인 주도 설계 기법을 활용하는 것이 효과적이다.
- DDD에는 전략적 설계와 전술적 설계가 있다.
    - 전략적 설계
        
        도메인 전문가 및 기술팀이 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고, 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트로 정의하고 경계의 관계를 컨텍스트 맵으로 정의하는 활동
        
    - 전술적 설계
        
        식별된 바운디드 컨텍스트 내의 도메인 개념인 도메인 모델을 구성하는 유용한 모델링 구성요소들을 설명"
2023-05-08 23:02:29,"한종우","13일차

[헤드퍼스트 디자인 패턴]

- 피자 예시 코드에서 팩토리 메소드 패턴을 사용한 코드를 이용하여 구상 클래스를 만들었을때, 두 클래스는 지역별로 다른 재료를 사용한다는 것을 빼면 같은 형식으로 구성되어 있다. 따라서 피자마다 클래스를 별도로 만들 필요가 없다. 지역 별로 다른 점은 원재료 팩토리를 이용하여 변하는 부분을 캡슐화해야 한다
- 이렇게 팩토리로 피자 재료를 만들면 만들어지는 재료는 어떤 팩토리를 쓰느냐에 따라 달라지고, 피자 클래스는 어떤 재료가 배달되는지 신경 쓰지 않아도 된다. 따라서 어떤 지역에서 어떤 팩토리를 사용하든 클래스는 그대로 재사용할 수 있다
- 추상 팩토리로 제품군을 생성하는 인터페이스를 제공할 수 있다. 이 인터페이스를 사용하면 코드와 제품을 생산하는 팩토리를 분리할 수 있다. 이렇게하면 클라이언트의 코드를 변경하지 않고 서로 다른 상황에 맞는 재품을 생산하는 팩토리를 구현할 수 있다"
2023-05-08 23:02:38,"한종우","14일차

[헤드퍼스트 디자인 패턴]

- 추상 팩토리 패턴
    - 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공한다. 구상 클래스는 서브 클래스에서 만든다
- 팩토리 메소드 패턴
    - 객체를 생성할 대 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다. 팩토리 메소드를 사용하면 인스턴스 만드는 일을 서브클래스에 맡길 수 있다
- 팩토리를 쓰면 객체 생성을 캡슐화할 수 있다
- 팩토리 메소드 패턴은 상속을 활용한다. 객체 생성을 서브 클래스에 맡기고 서브 클래스는 팩토리 메소드를 구현해서 객체를 만든다
- 추상 팩토리 패턴은 객체 구성을 활용한다. 팩토리 인터페이스에서 선언한 메소드에서 객체 생성이 구현된다
- 모든 팩토리 패턴은 애플리케이션의 구상 클래스 의존성을 줄여 느슨한 결합을 하게 한다
- 팩토리 메소드 패턴은 특정 클래스에서 인스턴스를 만드는 일을 서브클래스에게 넘긴다
- 추상 팩토리 패턴은 구상 클래스에 직접 의존하지 않고도 서로 관련된 객체를 이루어진 제품군을 만드는 용도로 쓰인다
- 의존성 뒤집기 원칙을 따르면 구상 형식 의존을 피하고 추상화를 지향할 수 있다
- 팩토리는 구상 클래스가 아닌 추상 클래스와 인터페이스에 맞춰서 코딩할 수 있게 해준다"
2023-05-08 23:15:19,"리경","12일차
오브젝트

✨ 요약
창조자 패턴은 객체 생성할 책임을 어떤 객체에 할당할지 지침 제공.

A객체 생성시 객체 생성 책임을 할당해야할 B는
A객체를 포함, 참조하거나
A객체를 기록하거나 긴밀하게 사용하거나
A 객체를 초기화하는데 필요 데이터를 가진다
-> 이미 결합된 객체 관계 이용하기에 낮은 결합도 유지

낮은 응잡도 초래하는 문재 해결 위해 변경 이유 따라 클래스 분리해야함.

그러나 클래스 분리후 전체적인 결합도가 높아졌음..

✨ 발췌
현재의 책임 할당을 검토하고 있거나 여러 설계 대안 중 하나를 선택해야한다면 높은 응집도를 유지할 수 있는 설계를 택하라.


변경에 취약한 클래스란 코드를 수정해야하는 이유를 하나 이상 가진 클래스다.

코드를 통해 변경 이유 파악 방법은 첫 번째, 인스턴스 변수거 초기화되는 시점을 살펴보는 것이다. 응집도가 낮은 클래스는 초기화시 색채 일부만 초기화하고 일부는 남긴다. 함께 초기화되는 속성 기준으로 코드를 분리한다.

두번째 방법은 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것이다.
메서드들이 사용 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다."
2023-05-08 23:33:22,"김용기","13일차
DDD MSA

## 3.3.3 외부 영역 - 세부 사항

- 외부 영역은 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터와 내부 영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터로 구성한다. 어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 한다.

### API 퍼블리싱 어댑터

- 엔티티를 직접 제공하지 않고 API 필요에 맞는 DTO를 생성해서 엔티티를 변환 및 매핑해서 전달하는 것이 바람직하다.

### API 프락시 어댑터

- API 프락시 어댑터는 다른 서비스의를 호출하는 아웃바운드 어댑터이다.

### 저장소 처리 어댑터

- 일반적으로 트랜잭션 스크립트 패턴을 사용할 경우 SQL 맵핑 방식을 사용하고 도메인 모델 패턴을 사용할 경우 OR 매핑 방식을 많이 선택한다.
- OR 매핑 방식은 OR 매퍼가 런타임 시 저장소에 따라 자동으로 질의문을 생성한다.
- SQL 매퍼 방식보다 유연한 메커니즘이다. 질의문을 수동으로 작성할 필요가 줄어들어 OR 매핑 방식에 익숙해지면 균일한 질의문 품질과 생산성 향상을 꾀할 수 있다.
- 아키텍트는 이러한 상황을 고려해서 제공할 비즈니스의 성격 및 팀원의 역량과 개발 효율성을 두루 고려해서 저장 메커니즘을 선택해야 할 것이다.

### 도메인 이벤트 발행 어댑터

- 도메인 이벤트가 생성되는 위치는 내부 영역이며, 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메세지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

### 도메인 이벤트 핸들러

- 도메인 이벤트 핸들러는 외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달하는 일을 수행한다.

4장
- 마이크로서비스를 만들기 위한 가장 효율적인 프로세스는 실제로 동작하는 제품 중심의 반복/점진적 애자일 개발 프로세스다.
- 애자일에서는 빨리, 그리고 자주 실패를 경험해 보는 것이 중요하여 단순한 설계를 통해 우선 최소한의 실제로 동작하는 제품 (MVP) 을 만들어 자주 배포하는 것이 중요하다.

# 4.1 도메인 주도 설계와 마이크로서비스

- 마이크로서비스의 애플리케이션 개발 측면, 응집성이 있는 도메인 중심의 마이크로서비스를 도출하는 지침 및 마이크로 서비스 내부의 비즈니스 로직 설계의 주요한 가이드로 사용되고 있다.
- 마이크로 서비스를 도출하고 내부 구조를 설계하는 데 도메인 주도 설계 기법을 활용하는 것이 효과적이다.
- 전략적 설계는 도메인 전문가 및 기술팀이 함께 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트로 정의하고 경계의 관계를 컨텍스트 맵으로 정의하는 활동이다.
- 전술적 설계는 식별된 바운디드 컨텍스트 내의 도메인 개념인 도메인 모델을 구성하는 유용한 모델링 구성요소들을 설명한다."
2023-05-09 09:07:01,"강민규","사진"
2023-05-09 09:07:27,"강민규","여러분 좋은 아침입니다 오늘 14일차입니다~ 오늘도 화이팅~"
2023-05-09 09:38:39,"다운","13일차

사피엔스

요약

농업혁명은 자연과 긴밀항 공생을 내던지고 탐욕과 소외를 향해 달려갔다. 인공적으로 환경을 조성한 탓에 내집에 대한 집착과 이웃으로 부터 분리되 훨씬 더 자기중심적이 되었다

수렵채집인들은 소유물 저장이 어려워 미래를 걱정하지 않았지만 농경시대는
생산의 계절적 사이클과 병충해 덕에 그 반대가 되었다.

농부들이 생성한 잉여생산물 덕에 왕궁과 산업망이 건설되었고 그 과정에서 신화가 중요한 역할을 했다

그 과정에서 이상적으로 여겨지는 사회질서 함무라이 법전이 완성됐다 하지만 이는 객관적 타당이 없다 미국 독립선언문도 마찬가지이다.

이 상상의 질서는 많은 사람들이 효과적으로 협력할 수 있는 유일한 방법이다

발췌

생물학에 따르면 인간은 창조되지
않았다. 진화했다

협력이란 말은 매우 이타적으로 들리겠지만 항상 자발적인 것은 아니엇으며 평등주의적인 경우는 드물었다 대부붕 압제와 착취에 적합하도록 맞춰져 있었다.

역사상의 전쟁과 혁명 대부분은 식량부족때문에 일어닌 것이 아니었다.

역사란 다른 모든 사람이 땅을 갈고 물을 운방하는 동안 극소수의 사람이 해온 무엇이다
"
2023-05-09 18:04:49,"다운","14일차

사피엔스

요약
붕괴의 위험이 있는 상상의 질서는 폭력적인 방법으로 믿게 할 수는 있지만  지속적으로 믿는 사람이 필요하다. 
상상의 질서를 믿게 하기 위해 그것을 객관적 실재라고 주장해야 하며 사람들를 지속적으로 교육 시켜야 한다.
또한 이를 물질세계에 결합해야 하며 그것은 우리의 욕망의 형태를 결정한다. 또한 그것은 상호주관적이다. 이를 변화하려면 수백만명의 낯선 사람들에게 나와 협력하도록 설득해야한다.

발췌
상상의 질서를 빠져나갈 방법이 없다. 우리가 감옥 벽을 부수고 자유를 향해 달려간다해도, 실상의 더 큰 감옥의 더 넓은 운동장을 향해 달려가는 것 뿐이다.

개인적 욕멍이라고 여기는 것들조차 상상의 질서에 의해 프로그램된 것이다.

낭만주의는 우리에게 인간으로서 잠재력을 최대한 활용하려면 최대한 다양한 경험을 해야 한다고 속삭인다.

첫째, 그 질서가 상상의 산물이라는 것을 결코 인정하지 않아야 한다."
2023-05-09 18:49:39,"최윤지","13일차
[7가지코드]

https://quiet-jade-e60.notion.site/13-0508-28f71e8abaf24e16ac510b65342b578b"
2023-05-09 19:13:34,"최윤지","14일차
[7가지 코드]

https://quiet-jade-e60.notion.site/14-0509-5d6ed6cbe93b49ed8ae50340983d9de6"
2023-05-09 20:13:34,"호02","14일차 제출

[초전 설득]

1. 요약 
 - 주의를 이끌어내는 강력한 몇몇 신호는 성적인 것과 폭력적인 것이다.
 - 그렇다고 무작정 상황과 관련없이 유도하는 것은 효과적이지 못하다.
 - 성적인 목적으로 하는 화장품, 향수 등의 광고에서는 성적인 상상을 유도하도록 하는 게 유효하지만 세탁 세제, 주방 용품 등에서는 그렇지 못하다.
 - 이성을 바라볼 때도 연애를 하고픈 사람이 매력적인 이성에게 시선을 뺏기는 시간이 더 많고, 이성 친구가 주변에 많다면 헤어질 확률에 영향을 준다.
 
2. 메모
 - 메뉴판을 쳐다보는 것조차 다이어트에 방해가 될 수 있다고 하는데, 이 말대로라면 먹방은 그야말고 다이어트에 최대의 적이다..."
2023-05-09 21:10:40,"수정","14일차
헤드퍼스트 디자인 패턴

https://bold-manta-a44.notion.site/14-57e9781ce3fc45c08cba6cc80d0fef2d"
2023-05-09 21:23:26,"최다봄","13일차 (p. 180 ~ 189)

[헤드퍼스트 디자인 패턴]

**CHAPTER 04: 객체지향 빵 굽기 - 팩토리 패턴 (느슨한 결합으로 객체지향 디자인 만들기)**

- **추상 팩토리 패턴(Abstract Factory Patter)**은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공한다.
- 구상 클래스는 서브클래스에서 만든다.
- 추상 팩토리는 제품군을 위한 인터페이스를 제공한다.
    - 군(family) ?
        - 피자를 만들 때 필요한 모든 재료(반죽, 소스, 치즈, 고기, 야채)를 의미
    - 추상 팩토리를 바탕으로 똑같은 제품을 다른 방식으로 구현하는 구상 팩토리를 만들 수 있다.
    - 팩토리로 제품을 생산하는 코드를 만든다.
    - 다양한 팩토리를 전달할 수 있기에 서로 다른 방식으로 여러 가지 제품을 구현할 수 있다. 클라이언트 코드를 바꿀 필요는 전혀 없다."
2023-05-09 21:23:36,"최다봄","14일차 (p. 190 ~ 204)

[헤드퍼스트 디자인 패턴]

**CHAPTER 04: 객체지향 빵 굽기 - 팩토리 패턴 (느슨한 결합으로 객체지향 디자인 만들기)**

### 발췌

[객체지향 원칙]

**+ 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.** 

**[추상 팩토리 패턴]**

- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공한다. 구상 클래스는 서브클래스에서 만든다.

**[팩토리 메소드 패턴]**

- 객체를 생성할 때는 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.
- 팩토리 메소드를 사용하면 인스턴스 만드는 일을 서브클래스에 맡길 수 있다.

**새로 배운 2가지 패턴은 객체 생성을 캡슐화하는 패턴으로,** 

**클라이언트와 구상 클래스가 서로 분리된 디자인을 구현할 수 있게 도와준다.** 

**CHAPTER 05: 하나뿐인 특별한 객체 만들기 - 싱글턴 패턴 (인스턴스가 하나뿐인 특별한 객체)**

- 싱글턴 패턴은 클래스 다이어그램에 클래스가 하나뿐이다. **(유일무이한 객체)**
- 단순하지만 구현하기에 까다롭다 !

### 요약

- **only one 객체 :** ex) 스레드 풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정을 처리하는 객체, 로그 기록용 객체, 디바이스 드라이버
    - 위 객체 사용 시 인스턴스가 2개 이상일 때 생길 수 있는 **문제**
        - 프로그램 이상하게 작동
        - 불필요한 자원 사용
        - 일관성 없는 결과
- **싱글턴 패턴: 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴**
    - 싱글턴 패턴 장점
        - **전역 변수처럼 객체 인스턴스 어디든지 액세스 가능**
        - 전역 변수 쓸 때처럼 여러 단점 감수 x
- 전역 변수 단점 ?
    - 전역 변수 객체 대입 시, 애플리케이션 작동의 경우 객체가 생성됨.
    - 해당 객체가 자원을 많이 잡아먹는데 객체를 한 번도 안 쓰면 자원 낭비
- 싱글턴 패턴 사용을 위한
    - 정적 클래스 변수와 메소드
    - 접근 변경자(access modifier)

**[질문] “어떻게 하면 한 클래스의 인스턴스를 2개 이상 만들지 않게 하지?”**"
2023-05-09 21:32:32,"강민규","여러분 퇴근은 다들 하셨나요? 밤이되면 쉬고싶은 마음이 굴뚝같겠지만 시간을 내서 공부하지않으면 아무것도 더 나아지지 않는답니다~ 오늘도 화이팅이에요

@리경 @김형우 @궈노 @뚯뚜오 선생님들은 미루지마시고 이틀분량 빠르게 해보세요~ 얼마 안걸립니다"
2023-05-09 21:40:18,"김형우","여기 13일차까지 작성했습니다!"
2023-05-09 21:40:48,"강민규","아 그러네요~"
2023-05-09 22:19:12,"이소민","14일차 제출

[헤드퍼스트 디자인패턴]

📍요약
. 간단한 팩토리 : 디자인 패턴이 아닌, 클라이언트와 구상 클래스를 분리하는 간단한 기법
. 팩토리 메소드 패턴 : 상속을 활용하여 객체 생성을 서브 클래스에 맡기는 것
. 추상 팩토리 패턴 : 구상 클래스에 의존하지 않고 서로 연관된 제품군을 생성하는 인터페이스


📍발췌
추상 팩토리 패턴을 꼭 기억해 주세요. 클라이언트에서 서로 연관된 일련의 제품을 만들어야
할 때, 즉 제품군을 만들어야 할 때는 언제든지 저를 활용해 주세요.
클라이언트 코드와 인스턴스를 만들어야 할 구상 클래스를 분리시켜야 할 때는 언제든지 팩토리 메소드
패턴을 활용해 주세요. 어떤 구상 클래스가 필요할지 미리 알 수 없을 때에도 정말 유용합니다. 저를 쓸 때 는 서브클래스를 만들고 팩토리 메소드를 구현하기만 하면 됩니다.

📍메모
추상 팩토리 패턴과 팩토라 메소드 패턴의 공통점은 캡슐화를 통해 클라이언트와 구상 클래스를 서로 분리시킨다는 것이고, 차이점은 추상 팩토리는 객체를 만들고 팩토리 메소드는 상속으로 객체를 만든다는 점이다"
2023-05-10 00:24:20,"송예은","14일차
ddd, msa

# 4.2 기민한 설계/개발 프로세스

## 4.2.1 점진/반복적인 스크럼 생명주기

- 기본 생명주기는 스크럼의 스프린트를 활용한다. 보통 1~4주다.
- 백로그라는 일감 목록을 기반으로 각 스프린트에 일감이 배분되어 진행된다.
- 스프린트를 진행하다 보면 일정 내에 완료해야 할 일의 우선순위를 결정하는 것이 매우 중요해지고, 우선순위가 높은 핵심 기능에 집중할 수 있게 해준다.

## 4.2.2 아키텍처 정의와 마이크로서비스 도출

- 아키텍처 정의
    - 기술 세부사항은 늦게 결정할 수 있어야 한다.
    - 순수 비즈니스 로직이 존재하는 내부 영역과 기술 영역을 표현하는 외부 영역으로 구분해보면, 외부 영역은 언제든 교체딜 수 있으므로 내부 영역에 집중하고, 외부 영역은 천천히 결정해도 된다는 말이다.
- 마이크로서비스 도출
    
    전략적 설계 기법으로 마이크로서비스를 도출하고 우선순위에 근거해 스프린트를 진행한다.
    

## 4.2.3 스프린트 내 개발 공정

### 백엔드 설계 및 개발

- 백엔드 설계의 시작은 API 설계다.
- 그 다음 설계는 정의된 마이크로서비스 내부 구조에 따라 도메인 모델과 데이터 모델을 설계하는 것이다.

### 프런트엔드 영역 설계와 개발

- 프런트엔드 영역 설계는 UI 레이아웃을 정의하고 API를 호출해서 API 데이터 기반으로 UI를 어떻게 표현할지 정의하는 활동이다.

### 빌드 및 배포

기민한 개발을 위해 개발 과정에서 지속적으로 빌드되고 자동으로 배포되도록 빌드 및 배포 환경을 자동화해야 한다.

5장
모듈화는 중요하다. 모듈화의 근본적인 가치는 각 모듈을 기능적으로 응집성 높게 만들고, 기능이 다른 타 모듈 간의 의존도를 낮추는 것이다. 마이크로서비스 설계에서도 똑같다.

# 5.1 마이크로서비스를 도출하는 방법

각 마이크로서비스가 다른 서비스와 의존하지 않게 도출해야 하므로, 어떤 비즈니스 기능들을 묶어서 독립적인 마이크로서비스로 도출할 것인가가 매우 중요하다.

## 5.1.1 비즈니스 능력에 근거한 도출

- 회사에서 부서가 나뉘어진 방식대로 도출하는 방식이다.
- 장점 : 쉽고 직관적으로 도출할 수 있다.
- 단점 : 전체적인 비즈니스 이해에는 유용하지만, 서비스간 관계를 파악하기에는 미흡하다."
2023-05-10 00:28:18,"김용기","14일차
DDD MSA

# 4.2 기민한 설계/개발 프로세스

## 4.2.1 점진/반복적인 스크럼 생명주기

- 스크럼 팀 : 다기능 팀으로서 프런트 개발자, 백엔드 개발자, 설계자, 테스터, 비즈니스 전문가, 디자이너 등이 한 팀을 구성한다. 여러 직능을 가진 전문가들이 같은 팀에 모여있으므로 의사결정이 빠르고 협업이 가능하다.
- 팀의 속도에 맞춰 스프린트를 진행하다 보면 일정 내에 완료해야 할 일의 우선순위를 정하는 것이 매우 중요해지고 이는 가장 우선순위가 높은 시스템의 핵심 기능에 집중할 수 있게 해준다.

## 4.2.2 아키텍처 정의와 마이크로서비스 도출

- 외부 영역은 언제든지 교체될 수 있으므로 애플리케이션의 핵심인 내부 영역에 집중하고, 외부영역, 즉 아키텍처의 결정사항들으 ㄴ천천히 결정해도 된다.
- 이 활동을 통해 초기에 정의되는 결과물은 정의된 내부/외부 아키텍처 및 개발 환경이다. 변화를 염두에 둔 유연한 구조를 초기에 정의해야 한다..

## 4.2.3 스프린트 내 개발 공정

### 백엔드 영역 설계와 개발

- DDD를 적용하면 별도의 정형화된 모델을 만들지 않고, 간략히 도메인 모델 등을 화이트보드나 포스트잇 등의 단순한 도구로 작성해서 공부한 후 곧바로 소스코드로 도메인 모델을 개발한다는 것이다.
- DDD의 모델링은 코드 자체가 모델의 기본 표현 형식을 그대로 반영해서 코드로 표현된다.

### 프런트엔드 영역 설계와 개발

- UI 흐름 정의 : 비즈니스 흐름에 따른 UI 흐름을 정의한다.
- UI 레이아웃 정의 : 사용자 접점인 사용자 인터페이스를 정의하는 활동이다.
- UI 이벤트 및 액션 정의 : 행위를 했을 때 발생하는 이벤트 및 액션을 정의하는 활동이다.
- UI 개발 ;: UI 레이아웃 및
- 이벤트의 의도에 맞춰 프런트엔드 애플리케이션을 개발하는 활동이다.

### 빌드 및 배포

- 기민한 개발을 위해서는 백엔드와 프런트엔드 개발이 진행되는 과정에서 지속적으로 빌드되고 자동으로 배포되도록 빌드 및 배포 환경을 자동화해야 한다.

- 마이크로서비스 설계에서의 가장 중요한 관심사도 어떻게 기능적으로 응집성 있는 마이크로서비스를 도출하고 타 서비스 간의 의존도는 낮출 것인가다. 또한 마이크로서비스의 내부 구조를 구성하는 각 요소들도 역할별로 모듈화되어야 한다.
- 마이크로서비스를 구성하는 각 요소들이 모두 소프트, 즉 유연해야 한다는 말과 같다.

# 5.1 마이크로 서비스를 도출하는 방법

## 5.1.1 비즈니스 능력에 근거한 도출

- 마이크로서비스를 식별하는 가장 쉬운 방법은 경험적인 원칙을 적용하는 것이다.
- 업무기능 분해는 업무 흐름에 따라 업무를 최상위에서 하위까지 대, 중, 소의 크기로 분리하고 수행하는 일들을 체계적으로 정렬한다. 그 결과, 특정 부서가 처리하는 업무 역할과 비슷해진다.
- 서비스 간의 관계를 파악하거나 서비스의 구체 기능과 연관된 서비스가 관리할 독립적인 데이터를 식별하기에는 미흡하다."
2023-05-10 00:30:56,"리경","13일차
오브젝트

✨ 요약
#다형성을 통해 분리해보기
역할은 협력안에서 대체 가능성 의미하므로 역할 개념 적용시 구체적 클래스 알지 못한 채 오직 역할에 대해서만 결합되도록 의존성 제한 할 수 있음.

자바는 역할 구현 위해 추상클래스, 인터페이스 사용함. 역할 대체할 클래스들 사이에 구현 공유해야하면 추상 클래스. 구현 공유 필요없이 책임만 정의하고 싶으면 인터페이스.

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고, 변화하는 행동을 각 타입의 책임으로 할당하라. 이는 다형성 패턴이다.

#변경으로부터 보호하기
변경 보호 패턴은 설계에서 변하는 것을 고려하고 변하는 개념을 캡슐화한다.

#변경과 유연성
설계 주도하는 건 변경. 개발자가 변경 대비하는 방법
1. 코드 이해하고 수정 쉽게 단순하게 설계.
2. 변경 수행하게 코드 유연하게 만들기

상속 대신 합성. 새로운 할인 정책 추가되도 정책 변경시 필요한 추가 코드 작성할 필요없음.

04. 책임 주도 설계의 대안
긴메서드는 응집도 낮고, 어렵고 재사용 어려우며 변경 어렵다. 이해 시간 걸리고, 일부 재사용 불가, 일부 사용해도 나머지 부분 버그 발생 확률 높음


✨ 발췌
객체 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당하는가? 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.

if~else 조건에 따른 변화는 수정하기 어렵고 변경에 취약하게 만든다.

클래스는 작고 오직 한 가지 일만 수행한다. 책임은 적절하게 분배돼 있다. 책임을 중심으로 협력을 설계할 때 얻을 수 있는 혜택이다.

아무것도 없는 상태에서 책임과 협력에 관해 고민하기 보다는 일단 실행되는 코드를 얻고 난 후 코드상에 명확하게 드러나는 책임들을 올바른 위치로 이동시키는 것이다. = 리팩터링 

주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라.

고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 할 수 있다.

✨ 메모
Ex) movie와 discountCondition 사이 협력은 다형적. 
discountCondition : 역할 구현
sequenceCondition / periodCondition 대체 가능"
2023-05-10 00:35:28,"Bo","14일차 
헤드퍼스트 

### 요약

> 추상 팩토리 패턴 vs 팩토리 메소드 패턴
> 
- 둘 다 클라이언트로부터 제품 생산을 분리한다.
    - 예제에서는 둘다 추상화된 제품을 반환하도록 만들어, 클라이언트는 구체 제품을 몰라도 되게 했다.
- 팩토리 메소드 패턴으로는 Pizza ( 추상화된 제품 ) 을 만들어 사용했다면, 추상 팩토리 패턴에서는 dough, cheese 처럼 일련의 제품군을 생산하게 해준다.
- 팩토리 메소드 패턴은 상속을 사용하고, 추상 팩토리 패턴에서는 객체 구성을 활용한다
    - 추상 팩토리 패턴에서는 추상화된 팩토리를 필드로 선언해서, 추상화된 팩토리가 생산을 담당하지만, 실제 구체 구상 팩토리가 생성을 담당

### 발췌

> 추상 팩토리 패턴
> 

💡 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이러우진 제품군을 생산하는 인터페이스를 제공합니다. 구상 클래스는 서브 클래스에서 만듭니다.


> 팩토리 메소드 패턴
> 


💡 객체를 생성할 때 필요한 인터페이스를 만듭니다. 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정합니다. 팩토리 메소드를 사용하면 인스턴스 만드는 일을 서브 클래스에 맡길 수 있습니다.

"
2023-05-10 00:47:59,"박소환","14일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/95"
2023-05-10 00:52:33,"리경","14일차
오브젝트

✨ 요약
#객체를 자율적으로 만들자
자기가 소유한 데이터를 자기스스로 처리하도록 만드는게 자율적 객체를 만드는 지름길.

메서드를 다른 클래스로 이동시킬때는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적.

06. 메시지와 인터페이스
메시지 수신시 실행되는 함수를 메서드.
객체는 메시지와 메서드 2 개념을 실행시점에 연결해야해 컴파일 시점과 실행 시점의 의미 다를 수 있음.

객체가 의사소통 위해 외부공개 메시지 집합 = 퍼블릭 인터페이스.
 퍼블릭 인터페이스에 포함된 메시지 = 오퍼레이션. = 수행 가능한 어떤 행동에 대한 추상화

오퍼레이션의 이름과 파라미터 목록= 시그니처

#인터페이스와 설계품질
디미터 법칙
묻지 말고 시켜라
의도를 드러내는 인터페아스
명령-쿼리 분리

#디미터 법칙(캡슐화)
객체 내부 구조에 강하게 결합 안되도록 협력 경로 제한하라는 것. 
클래스 내부가 아래 조건 만족하는 인스턴스에만 메세지 전송하도록 프로그래밍
- This 객체
- 메서드의 매개변수
- this 속성
- this 속성인 컬랙션의 요소
- 메서드 내 생성된 지역 객채


✨ 발췌
캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용하기 위해 노력한다면 책임 주도 설계 방법을 단계적으로 따르지 않더라도 유연 깔끔한 코드를 얻을 수 있을 것이다.

객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다.

메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.

✨ 메모
메시지 = 수신자/오퍼레이션명/인자
       conditions.isSatisfiedBy(screening)"
2023-05-10 03:51:32,"궈노","13일차 
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_13_180-189.md"
2023-05-10 03:51:47,"궈노","14일차 
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_14_190-204.md"
2023-05-10 06:27:34,"뚯뚜오","- 13일차 총균쇠
    요약
    농경민에게 대체되는 수렵채집민들. 대체되는 또는 생활 방식을 변화하는 주된 4가지 이유
    비교적 최근까지 수렵채집을 유지한 사람들은 수렵채집민의 인구가 농경정주민보다 많았거나, 수렵할 수 있는 천연자원이 풍부했거나, 식량생산자들이 정주하기 어려운 지리적, 생태적 여건을 가진 곳들. (주변이 사막이거나, 남극이거나, 알래스카거나, 북극이거나)
    6장 식량 생산민과 수렵 채집민의 경쟁력 차이 끝
    
    인류 선조들의 야생 식물 무의식적, 의식적 작물화 과정
    7장 야생 먹거리의 작물화
    
    발췌    
    그러나 그들도 결국은 20세기가 다 지나가기 전에 문명의 유혹에 굴복하거나, 관료 또는 선교사들의 압력에 못이겨 정착하거나, 아니면 병원균 때문에 죽고 말 것이다.
    모든 농작물은 야생 식물종에서 생겨났다. 그렇다면 야생 식물들은 어떻게 농작물이 되었을까? 이 문제가 특히 알쏭달쏭해지는것은, 많은 농작물이 그렇듯 야생 조상이 아몬드처럼 치명적이거나 맛이 안 좋은 경우, 또는 옥수수처럼 농작물과 야생 조상의 생김새가 서로 판이하게 다른 경우다. 도대체 어느 혈거인이 식물의 ‘작물화’를 생각을 다 했으며 그 일은 어떻게 이루어졌을까?"
2023-05-10 09:12:18,"강민규","사진"
2023-05-10 09:12:34,"강민규","여러분 오늘은 15일차입니다! 오늘도 좋은하루 보내세요"
2023-05-10 09:13:09,"뚯뚜오","- 14일차 총균쇠
    요약
    식물들의 입장에서 바라본 작물화 과정 (거대화, 종자의 쓴맛)
    씨가 없거나, 기름이 많은 식물들의 작물화 과정
    돌연변이 종자가 자연 선택되는 과정 (종자분산의 특수기법을 갖추지 못했거나 / 발아 억제물이 없거나 등등)
    
    발췌
    물론 딸기가 자기 종자를 퍼뜨릴 준비가 되었을 때에만 새들을 유인하겠다는 의식적인 계획을 가지고 있는 것은 아니다. 그리고 개똥지빠귀에게도 딸기를 작물화하겠다는 의도는 없다. 딸기는 자연선택을 통해 진화했던 것이다. 설익은 딸기가 파랗고 실수록 종자가 익기도 전에 새들이 딸기를 먹어서 종자를 망쳐버리는 일도 적어졌고, 잘 익은 딸기가 빨갛고 달수록 다 여문 종자를 멀리 퍼뜨려주는 새의 숫자도 많아졌다.
    그리하여 농경민들은 자연선택의 방향을 180도 돌려 놓았다. 종전에는 성공적이었던 유전자가 갑자기 치명적이 되었고, 반대로 치명적이었던 돌연변이가 성공적으로 바뀌었던 것이다.
    농경민이 채소밭에 조밀하게 종자를 뿌린다고 했을 떄 종자 사이에서는 치열한 경쟁이 벌어진다. 건조하고 척박한 산비탈에서는 종자가 많지 않아 경쟁도 덜하므로 작은 종자들이 유리했지만 채소밭에서는 좋은 조건을 이용하여 재빨리 성장할 수 있는 큰 종자들이 더 유리해진다."
2023-05-10 09:13:32,"박소환","15일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/96"
2023-05-10 09:35:14,"뚯뚜오","- 15일차 총균쇠
    요약
    접목법의 발달 및 중요성
    떡갈나무의 도토리처럼 작물화하지 못한 사례 (휴면기, 성장속도, 경쟁자, 유전적 특질)
    보호망과 온실이 불러온 딸기의 개량
    찰스 다윈 <종의 기원> 에서 표현된 작물화 사례
    7장 야생 먹거리의 작물화 끝
    
    발췌
    접목법의 발명은 어떤 유랑민이 잠시 배설을 하고 지나갔다가 나중에 다시 와서 맛 좋은 과일들이 주렁주렁 열려 있는 것을 보고 놀라면서도 즐거워하는, 그런 간단한 일이 아니었다.
    떡갈나무의 느린 성장 속도는 농경민들의 인내력을 소모시키기에 충분했다. 도토리를 심어서 소출이 나오기 까지는 10년 이상이 걸린다. 
    설령 어느 농경민이 도토리를 재배하겠다고 나서서 다람쥐를 물리치고 끈기 있게 버티었더라도 이 문제에만 부딪치면 그만 열정이 식어버리고 말았을 것이다."
2023-05-10 14:50:51,"최희윤","14일차 DDD
https://www.notion.so/05-09-DDD-14-fc707706d46443f5adbfa2ac6c14d7d0?pvs=4"
2023-05-10 15:08:37,"최희윤","15일차 DDD
https://www.notion.so/05-10-DDD-15-ceaba486dacb49179d6837d6be5a53b4?pvs=4"
2023-05-10 21:29:41,"최윤지","15일차
[7가지코드]

https://quiet-jade-e60.notion.site/15-0510-a6b8074d07f547419d103b4f8e4e7f41"
2023-05-10 21:44:58,"김연정","14일차
초전설득
요약
우리의 관심을 끄는 몇몇 신호
1. 성적인 것 
성적인 요소를 활용해 판매를 늘리는 전략은 성적인 목적의 제품에만 유효하다.(화장품이나 향수, 옷 등) 뛰어난 외모만으로는 행동에 영향을 미치기 부족하다. 사전에 오프너가 필요하다.
흥미로운 실험 결과: 사전에 마틴길이 아닌 발렌타인길이 어디에 있냐고 질문받은 남성이 위험에 처한 여성을 도와줄 확률이 더 높았음.
2. 폭력적인 것
드레드리스크: 끔찍한 위험을 피하기위해 작은 위험을 선택하지만 결과적으로 더 큰 위험에 노출됨, 예시: 911테러 사건 이후 육로를 이용한 사람이 많아졌는데 결과적으로 사망률이 더 높았음, 영국에서 지하철 사고 이후 자전거 이용률이 많아졌지만 훨씬 더 위험한 선택이었음

메모
광고 100위중 8개만이 성적인 광고였다. 범용 상품은 사전에 오프너가 필요하다."
2023-05-10 21:46:48,"강민규","여러분들 벌써 한주가 꺾였네요~ 이번 주도 후회없이 살아가고있나요? 아직 절반이 남았으니 아쉬움이 남는다면 지금도 늦지 않았습니다!

@김형우 @이찬영 여러분 14일차 분량은 오늘 꼭 제출 바랍니다~"
2023-05-10 22:00:29,"김연정","15일차
초전설득
요약
인간은 상반되는 두 가지동기, 어울리고 싶은 욕구와 멀어지고 싶은 욕구 모두를 가지고 있다. 폭력적인 영화 등으로 청중이 두려움에 노출됐을 때는 대세를 따르라는 메세지가 효과적이고, 로맨틱한 영화를 보는 시청자에게는 반대로 집단으로 부터 어느 정도 떨어지기를 원하기 때문에 특별한 사람이 되라는 메시지가 효과적이다. (성적으로 호기심을 느끼게 하면 튀고 싶은 욕구가 강해짐)
tv 프로그램을 오프너로 활용하여 광고를 배치하면 효과가 더 높다.
좋은 예: 로멘틱 영화 뒤에 나오는 자동차 광고 ""눈에띌준비를하세요""
나쁜 예: 범죄 영화 뒤에 나오는 자동차 광고""눈에띌준비를하세요""
메모
업음"
2023-05-10 22:02:21,"이찬영","14일차

헤드퍼스트 디자인패턴 [화요일] 
190-204pg

# 요약
**CHAPTER 04. 객체지향 빵 굽기 (feat. 팩토리 패턴)**

[ 추상 팩토리 패턴(Abstract Factory Pattern) ]
구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공한다.
구상 클래스는 서브 클래스에서 만든다.

[ 팩토리 메소드 패턴 =/= 추상 팩토리 패턴 ]
- 팩토리 메소드 패턴
    - 상속으로 객체를 만든다.
    - 객체 생성 방법 : 클래스를 확장하고, 팩토리 메소드를 오버라이드 한다.
    - 클라이언트와 구상 형식을 분리하는 역할
- 추상 팩토리 패턴
    - 제품군을 만드는 추상 형식을 제공한다.
    - 제품이 생산되는 방법은 이 형식의 서브클래스에서 정의한다.
    - 클라이언트와 실제 구상 제품이 분리되는 것
    - 많은 제품군을 생성하는 데에 적합
    - 구상 팩토리를 구현할 때 팩토리 메소드로 제품을 생산하기도 함.

[ 객체 지향 원칙 추가++ ]
- 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.
- 가능하면 모든 것을 추상화 하라.

[ 패턴 추가++ ]
- 추상 팩토리 패턴과 팩토리 메소드 패턴은 객체 생성을 캡슐화하는 패턴
- 클라이언트와 구상 클래스가 서로 분리된 유연한 디자인을 구현할 수 있게 한다.

**CHAPTER 05. 하나뿐인 특별한 객체 만들기 (feat. 싱글턴 패턴)**
- 싱글턴 패턴 : 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해 주는 패턴.
- 전역 변수를 사용할 때 처럼, 객체 인스턴스를 어디서든지 액세스 할 수 있게 만들고, 전역 변수를 쓸 때의 단점도 없다.

# 발췌
💡 팩도리 메소드 패턴 : 상속으로 객체를 만든다.
추상 팩토리 패턴 : 객체 구성(composition)으로 만든다.
💡 제품군을 만들어야 할 때는 추상 팩토리 패턴, 클라이언트 코드와 인스턴스를 만들어야 할 구상 클래스를 분리시켜야 할 때는 팩토리 메소드 패턴"
2023-05-10 22:16:20,"호02","15일차 제출

[초전 설득]

1. 요약 
 - 드레드 리스크 : 끔찍한 위협을 느끼면 그보다 좀 더 작은 위험으로 옮기려는 경향
 - 911 테러 사건 이후 항공편 대신 육로를 선택하는 비중이 높아졌다.
 - 우리는 어울리고 싶은 욕구와 멀이지고 싶은 욕구, 상반되는 두가지를 가지고 있다.
 - 광고에서는 어울리고 싶은 욕구를 부추길 때는 두려움의 메시지를, 멀어지고 싶은 욕구에는 낭만의 메시지를 던진다.
 
 
2. 메모
 - 읽을 수록 인간의 본능에 대해 깊이 이해하는 게 설득의 기본 바탕이 되는 것 같다."
2023-05-10 22:58:30,"이찬영","삭제된 메시지입니다."
2023-05-10 22:58:54,"이찬영","15일차

헤드퍼스트 디자인패턴 [3주차_수요일] 
205-216pg

# 요약
**CHAPTER 05. 하나뿐인 특별한 객체 만들기 (feat. 싱글턴 패턴)**
- 게으른 인스턴스 생성 (lazyinstantiation) : 인스턴스가 필요한 상황이 오기 전까지 아예 인스턴스를 생성하지 않도록 하는 방법.
- 싱글톤 패턴의 생성자는 private으로 저장되어 있다. public으로 지정된 생성자는 없음
- 싱클톤 객체가 필요할 때는 인스턴스를 달라고 요청한다. → getInstance()

[ 초콜릿 보일러 ]
- 보일러가 가득 차 있을 때와 비어있을 때를 분리해서 코딩

[ 싱글톤 패턴 (Singleton Pattern) ]
클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.
- 이 패턴을 실제 적용할 때는 클래스에서 하나뿐인 인스턴스를 관리하도록 만든다.
- 다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하게 한다,
→ 인스턴스가 필요하다면 반드시 클래스 자신을 거치도록
- 어디서든 인스턴스에 접근 가능하도록 전역접근 지점을 제공한다.
- 자원을 많이 잡아먹는 인스턴스일 경우, 게으른 인스턴스 생성 방식이 유용하다.

[ 멀티 스레딩 문제 ]
초콜릿 보일러에서 문제가 발생했다.
getInstance()를 동기화하면 멀티스레딩과 관련된 문제가 간단하게 해결된다,
→ 한 스레드가 메소드 사용을 끝내기 전까지 다른 스레드는 기다려야 한다.
하지만 동기화는 불필요한 오버헤드만 증가시킨다.
→ uniqueInstance 변수에 Singleton 인스턴스를 대입하면 동기화 상태로 유지하지 않아도 됨.

[ 멀티 스레딩에서도 싱글톤이 돌아가도록 ]
방법1. 정적초기화 부분에서 싱글톤의 인스턴스를 생성한다.
방법2. DCL(Double-Checked Locking)을 써서 getInstance()에서 동기화되는 부분을 줄인다. : 인스턴스가 생성되어 있는지 확인하고, 생성이 되어있지 않았을 때만 동기화 한다.

# 발췌
💡 volatile : 멀티스레딩을 쓰더라도 uniqueInstance 변수가 Singleton 인스턴스로 초기화되는 과정이 올바르게 진행된다."
2023-05-10 23:26:53,"송예은","15일차
ddd, msa

## 5.1.2 DDD의 바운디드 컨텍스트 기반 도출

- 마이크로서비스를 도출할 때 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요하다.
- DDD에서는 데이터를 기능과 분리해서 식별하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다.
- 마이크로서비스의 크기는 코드의 크기처럼 양적으로 판단하는 것이 아니라, 전체 업무 맥락에서 질적으로 판단해야 한다.

# 5.2 DDD에서의 설계

- DDD의 전략적 설계에서는 비즈니스 응집성이 있는 컨텍스트를 구분하고, 이를 바운디드 컨텍스트라 하는데, 이 단위가 마이크로서비스를 식별하기 위한 훌륭한 단위가 될 수 있다.
- 마이크로서비스 내부 구조를 정의하고 상세히 설계하기 위해 DDD의 객체 설계 기법인 전술적 설계를 사용할 수 있다.

# 5.3 DDD의 전략적 설계

## 5.3.1 도메인과 서브도메인

- 많은 개념들이 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리해야 한다. 이렇게 분리된 하위 도메인을 서브도메인이라고 한다.
- 서브도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반 서브도메인로 나뉜다.
    - 핵심 서브도메인
        
        경쟁자와 차별화를 만들 비즈니스 영역이므로 가장 중요하고, 소프트웨어 개발에서 전략적으로 가장 큰 투자가 필요한 영역이다.
        
    - 지원 서브도메인
        
        비즈니스에 필수적이지만 핵심은 아닌 부분이다. 핵심 도메인을 성공시키기 위해 반드시 필요한 영역이다.
        
    - 일반 서브도메인
        
        비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에 필요한 부분으로, 기존 제품을 구매해서 대체 가능하다.
        
- 전략적 설계를 수행하기 위해 중요한 개념
    - 도메인의 주요 개념을 정의하고 도메인 간의 경계를 식별하는 바운디드 컨텍스트
    - 도메인의 모든 구성원이 공통으로 사용하는 유비쿼터스 언어

## 5.3.2 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트

- DDD에서는 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 유비쿼터스 언어라고 한다.
- 특정 도메인의 업무 개념을 표현하는 언어다. 결제 도메인에서의 고객과 배송 도메인에서의 고객은 의미가 다르다.
- 도메인 모델은 특정 비즈니스 맥락에서 통용되는 개념들의 관계를 잘 정의한 모형이다.
- 이곳에서 사용하는 언어와 저곳에서 사용하는 언어와 개념이 상이한 경계가 바로 도메인의 경계인 바운디드 컨텍스트다.
- 유비쿼터스 언어는 코드에서도 살아 숨 쉬어야 한다.

## 5.3.3 컨텍스트 매핑

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 생긴다. 이런 컨텍스트 간의 의존 관계를 DDD에서는 컨텍스트 매핑이라 한다.
- 컨텍스트 간의 매핑 관계를 표시한 다이어그램을 컨텍스트 맵이라 한다.

### 주요 컨텍스트 매핑 관계

- 공유 커널
    
    바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계다.
    
- 소비자와 공급자
    
    공급하는 컨텍스트는 upstream, 소비하는 컨텍스트는 downstream으로 표시한다. 공급자의 변화를 소비자는 따라야 한다. 공급자는 소비자가 원하는 기능을 제공해야 한다.
    
- 준수자
    
    소비자와 공급자 관계와 유사하지만 upstream이 downstream의 요구를 지원하지 못하는 경우 사용한다. 이 경우 downstream은 upstream에서 제공하는 모델을 그대로 사용한다.
    
- 충돌 방지 계층 (ACL; anti-corruption layer)
    
    downstream이 upstream 모델에 영향을 받을 때 downstream 고유 모델을 지키기 위한 번역 계층을 만드는 것이다.
    
    클라우드 기반 마이크로서비스 아키텍처를 적용하는 새로운 시스템을 레거시 시스템과 통합하기 위해 주로 사용한다."
2023-05-11 00:29:45,"김용기","15일차
DDD MSA

## 5.1.2 DDD 바운디드 컨텍스트 기반 도출

- 마이크로서비스를 도출할 대 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요하다.
- DDD에서는 이처럼 데이터를 기능과 분리해서 식별하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다. 도메인 모델은 각 업무에 특화된 유비쿼터스 언어로 정의되고 그 업무에 특화된 개념으로 구성된다.

# 5.2 DDD 에서의 설계

- DDD 전략적 설계에서는 비즈니스 응집성이 있는 컨텍스트를 구분하고 이를 바운디드 컨텍스트라 하는데 이 단위가 마이크로서비스를 식별하기 위한 훌륭한 단위가 될 수 있다.
- DDD의 전술적 설계가 이러한 기술 변화에 유연한 구조의 애플리케이션을 설계하도록 도와주는 기법들을 제공한다.

# 5.3 DDD의 전략적 설계

## 5.3.1 도메인과 서브도메인

- DDD에서는 하나의 큰 도메인을 전략적으로 중요한 것들을 찾아 중요도에 따라 도메인을 나누고 각 도메인을 각각 하나씩 해결하는 방법을 기본으로 삼는다.
- 많은 개념들이 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리해야 한다는 뜻으로 이렇게 분리된 하위 도메인을 서브도메인이라고 한다. 서브도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반서브도메인 세 가지 유형으로 나뉜다.
- 핵심 서브도메인은 다른 경쟁자와 차별화를 만들 비즈니스 영역이기 때문에 기업의 프로젝트 목록에서 높은 우선순위를 갖는 영역이자 소프트웨어 개발에서 전략적으로 가장 큰 투자가 필요한 영역을 말한다.
- 지원 서브도메인은 비즈니스에 필수적이지만 핵심은 아닌 부분으로 불 서 있다.
- 일반 서브도메인은 비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에는 필요한 부분으로 기존 제품을 구매해서 대체할 수 있다.
- 전략적 설계를 수행하기 위해 알아야할 중요한 개념 두 가지가 있다.
    - 도메인의 주요 개념을 정의하고 도메인 간의 경계를 식별하는 바운디드 컨텍스트
    - 도메인의 모든 구성원이 공통으로 사용하는 유비쿼터스 언어

## 5.3.2 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트

- 이처럼 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 유비쿼터스 언어라고 한다.
- 유비쿼터스 언어를 정의해서 이해관계자가 모두 공통의 언어를 사용하면 고객, 설계자, 개발자까지 용어에 따른 오해를 없앨 수 있게 된다.
- 즉, 유비쿼터스 언어는 특정 도메인의 업무 개념을 표현하느 ㄴ언어다.
- 사용하는 언어와 저곳에서 사용하는 언어와 개념이 상이한 이 경계가 바로 도메인의 경계, 바운디드 컨텍스트다.
- 하나의 도메인에서 사용되는 유비쿼터스 언어는 팀의 의사소토 및 실제로 동작하는 코드에서도 살아 숨 쉬어야 한다.

## 5.3.3 컨텍스트 매핑

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 발생한다. 이러한 컨텍스트 간의 의존 관계를 DDD에서는 컨텍스트 매핑이라 한다.

### 주요 컨텍스트 매핑 관계

- 공유 커널 : 공유 커널은 바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계다.
- 소비자와 공급자 : 공급하는 컨텍스트는 상류로, 소비하는 컨텍스트는 하류로 표시한다. 상류에서 변화가 있으면 하류에서 변화를 따라야 한다.
- 준수자 : 준수자는 소비자와 공급자와 유사하지만 상류 팀이 하류 팀의 요구를 지원하지 않거나 못하는 경우 사용한다.
- 충돌 방지 계층 : 하류 팀이 상류 팀의 모델에 영향을 받을 때 하류 팀의 고유 모델을 지키기 위한 번역 계층을 만드는 것이다.
- 이러한 매핑 유형은 클라우드 기반의 마이크로서비스 아키텍처를 적용하는 새로운 시스템을 레거시 시스템과 통합하기 위해 주로 사용한다.
- 공개 호스트 서비스 : 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다.
- 발행된 언어: 발행된 언어는 하류의 컨텍스트가 상류 컨텍스트가 제공하는 기능을 사용하게 하기 위한 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어다."
2023-05-11 01:17:43,"김형우","[14일차]
https://engineer-diary.tistory.com/217"
2023-05-11 08:33:33,"강민규","사진"
2023-05-11 08:34:53,"강민규","16일차입니다! 오늘도 좋은 하루 보내세요"
2023-05-11 09:42:55,"송예은","16일차
ddd, msa

- 공개 호스트 서비스 (OHS; Open Host Service)
    
    공개 호스트 서비스는 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다. 보통 다른 컨텍스트에서 사용할 수 있는 공유된 API가 여기에 해당한다.
    
- 발행된 언어 (PL; Published Language)
    
    downstream 컨텍스트가 upstream 컨텍스트가 제공하는 기능을 사용하게 하기 위해 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어다. XML이나 JSON 스키마로 표현될 수 있다. 주로 공개 호스트 서비스와 짝을 이루어 사용한다.
    

### 컨텍스트 맵

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하고 이들 간의 관계를 표현한 그림을 컨텍스트 맵이라 한다.
- 각 서브도메인 간의 관계는 일반 서브도메인이 핵심 서브도메인, 지원 서브도메인과 공급자/소비자 관계를 맺고 있으며, 일반 서브도메인이 공개 호스트 서비스로 일반 서브도메인을 사용할 수 있도록 프로토콜/인터페이스를 제공하면서 발행된 언어를 다른 컨텍스트에 제공한다.
    
    핵심 서브도메인에 포함되는 컨텍스트는 일반 서브도메인과 지원 서브도메인에 속하는 컨텍스트를 사용하고 지원 서브도메인에 포함된 컨텍스트는 일반 서브도메인의 컨텍스트들을 사용한다.
    

# 5.4 이벤트 스토밍을 통한 마이크로서비스 도출

시스템의 액터는 원하는 바를 얻기 위해 시스템을 조작하고, 이 조작은 시스템을 동작하게 한다. 이 동작을 통해 사용자의 요청에 해당하는 데이터를 만들고 이 정보는 간단한 스케치 형태의 UI 형태로 액터에서 제공된다.

## 5.4.1 이벤트 스토밍 워크숍 준비

포스트잇을 벽에 붙여가며 설계한다.

### 스티커 유형별 의미

- 도메인 이벤트 - 오렌지색
    
    발생한 사건. 과거시제동사로 표현
    
- 커맨드 - 파란색
    
    도메인 이벤트를 트리거하는 명령
    
- 외부 시스템 - 핑크색
    
    도메인 이벤트가 호출하거나 관계가 있는 레거시 또는 외부 시스템
    
- 액터 - 작은 노란색
    
    개인 또는 조직의 역할
    
- 애그리거트 - 노란색
    
    도메인 이벤트와 커맨드가 처리하는 데이터 상태가 변경되는 데이터
    
- 정책 - 라일락색
    
    이벤트 조건에 따라 진행되는 결정
    
- 읽기 모델 - 초록색
    
    도메인 이벤트 액터에게 제공되는 데이터
    
- 사용자 인터페이스 - 흰색
    
    스케치 형태의 레이아웃
    
- 핫스폿 - 자주색
    
    의문, 질문, 미결정 사항"
2023-05-11 17:31:45,"이찬영","16일차

헤드퍼스트 디자인패턴 [3주차_목요일] 
217-226pg

# 요약
**CHAPTER 05. 하나뿐인 특별한 객체 만들기 (feat. 싱글턴 패턴)**
[ 초콜릿 보일러 문제 해결하기 ]
방법1. getnstance() 메소드 동기화 하기 : 항상 올바른 결과가 나옴. 초콜릿 보일러의 속도문제는 중요히자 않으니 이 방법 괜찮음.
방법2. 인스턴스를 시작하자마자 만들기 : 초콜릿 보일러의 인스턴스는 항상 필요하기 때문에 정적으로 초기화 하는 것도 괜찮은 방법. 하지만 방법1과 큰 차이가 없다.
방법3. DCL 사용하기 : 속도 문제가 중요하지 않기 때문에 DCL까지 쓸 필요 없음. 

- 클래스 로더가 2개 이상이라면 같은 클래스를 여러 번 로딩할 수도 있으니, 클래스 로더가 여러 개라면 싱글턴을 조심해서 사용해야 합니다.
- 리플렉션, 직렬화, 역직렬화도 싱글턴에서 문제가 될 수 있다.
- 싱글턴은 느슨한 결합 원칙에 위배된다.
- 싱글턴은 라이브러리에 넣을 수 있는 형태의 해법이 아니며, 싱글턴 코드는 간단하기 때문에 기존 클래스에 있던 코드를 싱글턴 클래스에 넣기 쉽다.
- 싱글턴은 특수한 상황에서 제한된 용도로 사용하려고 만들어진 것이기 때문에 애플리케이션을 만들 때 싱글턴을 많이 사용했다면 다시 한번 생각해볼 필요가 있다.
⇒ 동기화문제, 클래스로딩문제, 리플렉션, 직렬화, 역직렬화 문제는 enum으로 해결할 수 있다.

[ 객체지향 패턴 추가++ ]
- 싱글톤 패턴 : 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.
- 애플리케이션에서 특정 클래스의 인스턴스가 하나만 있어야 한다면 그 클래스를 싱글톤으로 만들면 된다.

**CHAPTER 06. 호출 캡슐화하기 (feat. 커맨드 패턴)**
메소드 호출을 캡슐화 한다. 

[ 확장형 기상스테이션 ]
- 홈오토메이션 리모컨 API 디자인 의뢰

# 발췌
💡 자바의 enum을 쓰면 간단하게 싱글톤을 구현할 수 있다.
"
2023-05-11 17:40:21,"이소민","이소민님이 나갔습니다."
2023-05-11 21:37:16,"수정","15일차
헤드퍼스트 디자인패턴

#요약
- 고전적인 싱글턴 패턴 구현법
    - 생성자를 private로 선언해 Singleton에서만 클래스의 인스턴스를 만들 수 있다
    - `public static <클래스이름> getInstance()`메소드로 클래스의 인스턴스를 만들어서 리턴한다
        - `<클래스이름>.getInstance()`
        - 정적 메소드를 지칭할 때는 클래스 이름을 써야 한다
    - 인스턴스가 필요한 상황이 되었을 때 비로소 생성하기: lazyinstantiation (게으른 인스턴스 생성)
- 싱글턴 패턴의 특징
    - 유일함: 한 앱의 어떤 객체에서도 같은 자원을 활용할 수 있다는 장점
    - 공개된 생성자가 없고 인스턴스 호출을 받으면 클래스 안에서 만들어서(이미 한 번 만들어서 있으면 그걸) 건네줌
- 멀티스레딩 이슈
    - 1안) getInstance 동기화: getInstance를 동기적으로 실행해서 getInstance실행이 끝나기 전까지 다른 곳에서 또 호출하지 못하도록 함
        - 단점 ⇒ 너무 느리다. 그리고 처음 인스턴스를 만들고 나면 동기화가 필요없는데 계속 해서 낭비
    - 2안) 처음부터 인스턴스를 만들어둔다.(게으르지 않게)
    - 3안) DCL(Double-Checked Locking)
        - 인스턴스가 없을 때만 동기화한다. 동기화 안의 블록에서도 인스턴스가 없는지 다시 확인하고 인스턴스를 생성한다(더블체크)"
2023-05-11 21:58:57,"다운","15일차

사피엔스

요약
동물 종의 대규모 사회는 dna에 의해 프로그래밍 되어 있지만 사피엔스는 가상의 질서에 의해 사회가 움직인다

인간의 뇌는 용량부족, 죽음의 한계, 특정 정보만 저장 이라는 이유로 엄청난 양의 정보를 저장하기 쉽지 않은데 농업혁명이후잉여생산물을 계산하기 위해 숫자가 등장했다.  

그 이후로 메소토피아인들이 쐐기문자를 만들었고 시나 역사책등을 쓰기 시작했다. 점토판 기록에 한계를 느낀 이들은 다른 기록방법을 찾기 시작했다. 
문자체계는 인간이 세계를 생각하는 방법을 다르게 점차 바뀌었다.

발췌
세계 모든 강아지들이 벌이는 개싸움의 규칙은 그들 유전자에 각인되어있다
"
2023-05-11 22:03:08,"강민규","삭제된 메시지입니다."
2023-05-11 22:04:59,"강민규","여러분 퇴근은 하셨나요? 내일 즐거운 불금을 보내기 위해 오늘은 결석 없이 다 해보도록 해요!!

@한종우  @최다봄  @김형우 @리경 @Bo @궈노 선생님들은 15일차부터 다 해봐요~"
2023-05-11 22:09:20,"수정","16일차
헤드퍼스트 디자인패턴

- 싱글턴 패턴의 문제점
    - 클래스 로더
    - 리플렉션, 직렬화, 역직렬화
    - 느슨한 결합 원칙에 위배
    - “한 클래스가 한 가지만 책임지기” 위배
        - 자신의 인스턴스 관리 + 원래 그 인스턴스를 사용하고자하는 목적에 부합하는 작업
            => 2가지 책임짐
    - 싱글턴의 서브클래스 만들기?
        - 100%안되는 건 아니지만 매우 복잡하고, 확장의 목적이 매우 뚜렷한 게 아니라면 하지말자
        - 앱 안에 싱글턴을 많이 사용했다면 설계를 의심해야
    - 싱글턴 대신 전역변수의 단점?
        - 게으른 인스턴스 못함
        - 간단한 객체의 전역 레퍼런스가 많이 생겨서 네임스페이스가 지저분해진다
- 싱글턴 대신 enum을 사용하면 된다❗️"
2023-05-11 22:28:30,"최다봄","15일차 (p. 205 ~ 216)

[헤드퍼스트 디자인 패턴]

**CHAPTER 05: 하나뿐인 특별한 객체 만들기 - 싱글턴 패턴 (인스턴스가 하나뿐인 특별한 객체)**

- 싱글턴 패턴은 클래스 다이어그램에 클래스가 하나뿐이다. **(유일무이한 객체)**
- 단순하지만 구현하기에 까다롭다 !

### 요약

**[고전적인 싱글턴 패턴 구현법]**

`public Class Singleton {`

- `private static Singleton uniqueInstance` : Singleton 클래스의 하나뿐인 인스턴스를 저장하는 **정적 변수**
- `private Singleton(){}` : 생성자를 pricate으로 선언했으므로 Singleton에서만 클래스의 인스턴스를 만들 수 있다.
- `public static Singleton getInstance(){}` : getInstance() 메소드는 클래스의 인스턴스를 만들어서 리턴한다.
    - `if (uniqueInstance == null){ uniqueInstance = new Singleton()} return uniqueInstance;` :
    - `uniqueInstance` 에 하나뿐인 인스턴스가 저장됨 (정적변수)
    - null 이면 인스턴스 생성 안 된 것/null이 아니면 객체 생성된 것
- 정리하자면, public이 아닌 private으로 생성자가 지정되었으며, 객체가 필요할 경우 인스턴스를 요청하기 위해 getInstance()라는 정적 메소드를 사용한다.

**[싱글턴 패턴]**

- 클래스 인스턴스를 하나만 만든다.
- 다른 어떤 클래스에서도 자신의 인스턴스를 만들지 못하게 한다.
- 어디서든 그 인스턴스에 접근할 수 있도록 전역 접근 지점을 제공한다.
- 1 요청, 1인스턴스 ⇒ 자원 많이 잡아먹는 인스턴스에 유용

**[초콜릿 보일러 코드 ]**

- 초콜릿이 가득 차 있는 경우와 비었을 경우를 고려하여 보일러가 작동하도록 구현 **⇒ 만약 한 어플리케이션에서 ChocolateBolier 인스턴스가 2개 이상 만들어지면 어떤 문제가 발생할 수 있을까?**

**[멀티스레딩 문제 해결법]**

1. `public static **synchronized** Singleton getInstance(){}` : getInstance()에 synchronized 추가시 한 스레드에서 다른 스레드 기다림. 
    - but, 동기화 시 속도 문제 발생/속도 상관없을 경우 그냥 둠.(성능 100배 차이가 난다..)
2. `private static Singleton uniqueInstance = new Singleton()` : 처음부터 인스턴스를 생성해둠.
3. **DCL(Double-Checked Locking)** 사용: 인스턴스가 생성되어 있는지 확인한 다음 생성되어 있지 않았을 때만 동기화할 수 있도록. `synchronized (Singleton.class){ ~(기존 getInstance() 메소드 내 코드) }`"
2023-05-11 22:28:39,"최다봄","16일차 (p. 217 ~ 226)

[헤드퍼스트 디자인 패턴]

**CHAPTER 05: 하나뿐인 특별한 객체 만들기 - 싱글턴 패턴 (인스턴스가 하나뿐인 특별한 객체**

### 요약

- 멀티스레딩 문제 해결법 [초콸릿 보일러 코드 상황시]
    1. getInstance() 메소드를 동기화하는 방법
        - 항상 올바른 결과가 나옴
        - 초콜릿 보일러의 경우에 속도 문제가 중요치 않으니 ok
    2. 인스턴스를 시작하자마자 만드는 방법
        - 어차피 초콜릿 보일러의 인스턴스는 항상 필요하기에 정적으로 초기화해도 괜찮은 방법
        - 표준적인 패턴에 익숙한 개발자에겐 이상해보일 수 있지만 동기화 방법과 별반 차이 x
    3. DCL**(Double-Checked Locking)**를 쓰는 방법
        - 속도 문제가 그리 중요하지 않기에 굳이 DCL까지 불필요
- 싱글턴 패턴의 문제점
    - 동기화 문제, 클래스 로딩 문제, 리플렉션, 직렬화, 역직렬화
    - 의 **해결법 ⇒ enum 사용**
    - `public enum Singleton { UNIQUE_INSTANCE; }`
    - `Singleton singleton = Singleton.UNIQUE_INSTANCE`"
2023-05-11 22:38:49,"최윤지","16일차
[7가지 코드]

https://quiet-jade-e60.notion.site/16-0511-c9f937d201c14990b88f03a45d3749ab"
2023-05-11 22:53:51,"박소환","@강민규  
도메인주도 설계로 시작하는 마이크로서비스 책을 읽고 있는데요,
페이지가 129 ~ 133pg 로 되어있는데 이게 맞을까요?
4페이지밖에 안돼서요..
내일꺼는 또 12페이지이고.. 불균형한 이유가 있을까요?"
2023-05-11 22:59:27,"한종우","15일차

[헤드퍼스트 디자인 패턴]

### 싱글턴 패턴

- 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공하는 디자인 패턴
- 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴으로 전역 변수를 사용할 때와 마찬가지로 객체 인스턴스를 어디서든지 접근할 수 있게 해준다.
- 필요할 때만 객체를 만들 수 있어 쓸데없는 자원을 잡아먹지 않도록 할 수 있다
- 싱글턴 패턴은 인스턴스가 하나 뿐이므로 한 어플리케이션에 들어있는 어떤 객체에서도 같은 자원을 활용할 수 있다. 연결 풀이나 스레드 풀과 같은 자원풀을 관리하는데도 자주 사용된다
- public 생성자가 없고 `get` 정적 메서드를 통해 인스턴스를 생성하도록 구현하는 것이 특징이다.
- 실제 적용할 때는 클래스에 하나뿐인 인스턴스를 관리하도록 만들고 다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하게 해야 한다. 인스턴스가 필요하다면 클래스 자신을 거치도록 한다.
- 어디서든 인스턴에서 접근할 수 있도록 전역 접근 지점을 제공한다. 클래스 메서드를 통해 lazy loading 방식으로 객체를 생성하여 자원 낭비를 줄일 수 있다
- 멀티스레딩 환경에서 동기화 문제가 생길 수 있다,
- 멀티스레딩 문제 해결을 위한 방법 3가지
    1. 속도가 중요하지 않다면 그대로 유지
        - 다만 속도는 100배 정도 저하된다.
    2. 처음부터 클래스가 로딩될때 인스턴스를 생성하여 다른 어떤 스레드도 접근하지 못하게 한다.
    3. DCL(Double-Checked Locking)을 써서 동기화되는 부분을 줄인다
        - DCL을 통해 생성되어 있는지 확인 후 생성되어 있지 않을 때만 동기화한다."
2023-05-11 23:00:51,"한종우","민규님 2박3일 예비군 훈련을 다녀와서 
16일, 17일치는 내일 같이 올리겠습니다."
2023-05-11 23:06:01,"강민규","불균형한 이유는 왠만하면 끊기 좋게 나누려고 하는데 책이 제 마음만큼 딱딱 맞게 안되어있어서 그렇습니다!"
2023-05-11 23:06:26,"강민규","넵"
2023-05-11 23:13:03,"박소환","넵!"
2023-05-11 23:13:24,"박소환","16일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/97"
2023-05-11 23:50:55,"김용기","16일차
DDD MSA

## 5.3.3 컨텍스트 매핑

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 발생한다. 이러한 컨텍스트 간의 의존 관계를 DDD에서는 컨텍스트 매핑이라 한다.

### 주요 컨텍스트 매핑 관계

- 공유 커널 : 공유 커널은 바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계다.
- 소비자와 공급자 : 공급하는 컨텍스트는 상류로, 소비하는 컨텍스트는 하류로 표시한다. 상류에서 변화가 있으면 하류에서 변화를 따라야 한다.
- 준수자 : 준수자는 소비자와 공급자와 유사하지만 상류 팀이 하류 팀의 요구를 지원하지 않거나 못하는 경우 사용한다.
- 충돌 방지 계층 : 하류 팀이 상류 팀의 모델에 영향을 받을 때 하류 팀의 고유 모델을 지키기 위한 번역 계층을 만드는 것이다.
- 이러한 매핑 유형은 클라우드 기반의 마이크로서비스 아키텍처를 적용하는 새로운 시스템을 레거시 시스템과 통합하기 위해 주로 사용한다.
- 공개 호스트 서비스 : 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다.
- 발행된 언어: 발행된 언어는 하류의 컨텍스트가 상류 컨텍스트가 제공하는 기능을 사용하게 하기 위한 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어다.

### 컨텍스트 맵

- 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하고 이들 간의 관계를 표현한 그림을 컨텍스트 맵이라 한다.
- 핵심 서브도메인에 포함되는 컨텍스트는 일반 서브도메인과 지원 서브도메인에 속하는 컨텍스트를 사용하고, 지원 서브도메인에 포함된 컨텍스트는 일반 서브도메인의 컨텍스트들을 사용한다.

# 5.4 이벤트 스토밍을 통한 마이크로서비스 도출

- 시스템의 액터(사용자 또는 역할자)는 원하는 바를 얻기 위해 시스템을 조작(커맨드)한다.
- 이 조작은 시스템을 동작(도메인 이벤트)하게 ㄷ한다.
- 이 동작을 통해 사용자의 요청에 해당하는 데이터 (읽기 모델)를 만들고, 이 정보는 간단한 스케치 형태의 UI(사용자 인터페이스) 형태로 액터에서 제공된다.
- 액터는 이 정보를 바탕으로 다시 시스템을 조작하고, 또 시스템이 동작하는 절차를 반복하게 된다.

## 5.4.1 이벤트 스토밍 워크숍 준비

### 스티커 유형별 의미

- 이벤트 스토밍은 현실 세계의 도메인을 다양한 의미의 스티커로 표현한다."
2023-05-12 00:21:55,"김용기","때마침 오늘 회사에서 워크샵으로 이벤트 스토밍을 했습니다. 워크샵 진행자분이 몇가지 팁을 알려주셔서 공유해봅니다. (진행하면서 참고했던 유튜브입니다. 이 영상에 나오시는 분이 오늘 워크샵을 진행해주셨습니다. [https://youtu.be/hUcpv5fdCIk](https://youtu.be/hUcpv5fdCIk))

1. 이벤트 스토밍은 개발자보다는 기획자가 주도하는 것이 좋다. 개발자가 주도하거나 개발자만 있는 경우는 코딩 용어나 로직으로 얘기하게되는데, 이벤트 스토밍은 설계 및 코딩에 들어가기 전에 하는 작업이므로 적절하지 않다. 또한, 정책은 기획자가 결정하는 것이기 때문에 개발자만 있을 때는 핫스팟이 제대로 도출되지 않을 가능성이 크다.
2. 만약 기획서가 나오지 않은 상태라면 이벤트 스토밍을 하기에 적절하지 못하다. 
3. 같은 팀원들 내에서도 생각보다 같은 도메인에 대해 다른 뜻으로 생각하고 있는 것이 다른 경우가 많다. 이 부분은 핫스팟으로 관리하여 제대로 짚고 넘어가야 한다.
4. Create도 사람에 따라서 ‘등록’, ‘생성’ 처럼 다른 용어를 사용할 수 있다. 이음동의어일 수도 있지만, 정책상 다른 의미를 가질 때도 있다. 그래서 한가지 용어로 통일할 수 있도록 해야한다. 또한, 영어로도 표현을 한가지로 정해놓으면 개발 단계에서 변수나 메서드명을 쉽게 정할 수 있고 코드 리딩도 쉬어진다.
5. 도메인 이벤트를 작성한 뒤에 도메인 이벤트 포스트잇을 재정렬할 때 모두가 하기보다는 ‘드라이버’ 한 명을 선정하여 전담하도록 하고 나머지는 ‘네비게이터’가 되어 드라이버에게 조언을 하자. 드라이버가 여러 명일 경우에는 쉽게 산만해지고 팀의 주의력이 분산될 수 있다.
6. 드라이버가 포스트잇을 재정렬하는 과정에서 컨텍스트 별로 적극적으로 참여하는 사람들이 다르다면 그것은 조직이 분리되어야하는 신호가 될 수 있다. 조직이 분리된다는 것은 컨텍스트들이 MSA로 분리될 수 있다는 신호가 될 수 있다."
2023-05-12 00:51:50,"호02","16일차 제출

[초전 설득]

1. 요약 
 - 초점의 대상을 빠르게 바꾸기의 한 예시로 파블로프의 개를 든다.
 - 해당 실험을 한 이반 파블로프는 성과를 보여주기 위해 외부인을 초대하여 실험을 진행하였지만, 번번히 실패하였다.
 - 이유는 새로운 외부 요인으로 인해 집중이 분산되어 개가 반응하지 않았던 것.
 - 주의를 돌리면서도 집중을 하게 하려면 분산시키는 요인들을 제거해야 한다. 너무 자주 초점이 바뀌는 것도 조심해야 한다.
 
2. 메모
 - 없음"
2023-05-12 01:18:13,"Bo","15일차 
헤드퍼스트 
### 요약

> 싱글톤 패턴
> 
- 생성자를 private 으로 만들고, 필드에 인스턴스를 등록하는 ( 초기값은 null, 최초 호출시 인스턴스 생성) 방 + 조회시 정적 메소드 이용하는 방식이 있다
- 이 코드는 그러나 멀티스레드 구조에서 스레드 세이프하지 않아, 인스턴스가 2개 생성될 수도 있다
- synchronized 키워드로 해결 하기 → 객체 생성 후에도 synchronized 를 계속 쓰게되어 자원 낭비
- → 클래스 로딩할 때 아예 객체를 생성해 버리기
- → DCL 을 써서 인스턴스가 생성 되지 않았을 때만 동기화 ( volatile 키워드 )

### 발췌

> 싱글턴 패턴의 정의
> 

<aside>
💡 싱글턴 패턴은 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.

</aside>"
2023-05-12 05:39:43,"리경","15일차
오브젝트

✨ 요약
#묻지 말고 시켜라
메시지 전송자는 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안됨. 캡슐화 위반.

#의도를 드러내는 인터페이스
어떻게 하느냐가 아닌 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴 : 의도를 드러내는 선택자

디미터 법칙 위반 -> 기차 충돌 : 내부에 포함된 객체에도 직접 접근 -> 인터페이스와 구현 분리 원칙 위반

디미터 법칙은 결합도와 관련되 객체의 내부구조가 외부로 노출되는 경우로 한정됨.


✨ 발췌
- 설계는 트레이드오프의 산물이다. 초보자는 원칙을 맹목적으로 추종한다. 심지어 적용하려는 원칙들이 서로 충돌하는 경우에도 원칙에 정당성을 부여하고 억지로 끼워 맞추려고 노력한다. 결과적으로 설꼐는 일관성을 잃어버리고 코드는 무질서 속에 파묻히며 개발자는 길을 잃은 채방황하게 된다. 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.

"
2023-05-12 06:18:29,"리경","16일차
오브젝트

✨ 요약
#결합도와 응집도의 충돌
위임 메서드를 통해 객체의 내부 구조 감추는 것은 협력에 참여하는 객체들의 결합도를 낮추는 동시 객체의 응집도를 높이는 효과적인 방법.

클래스는 하나의 변경 원인만 가져야함. 묻지말고 시켜라를 무작정 따르면 애플리케이션은 응집도 낮은 객체로 넘쳐날 것.

#명령-쿼리 분리 원칙
명령: 객체의 상태를 수정하는 오퍼레이션
쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션
오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 함.
즉, 객체 상태 변경하는 명령은 반환값 가질 수 없음 + 객체 정보 반환하는 쿼리는 상태 변경할 수 없음.

‘질문은 답변을 수정해서는 안된다’

#명렁-쿼리 분리와 참조 투명성
명령과 쿼리 분리함으로 명령형 언어의 틀 안에서 참조 투명성의 장점 제한적으로 누릴 수 있음.

객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가까움.
그러나 명령-쿼리 분리 원칙 사용시 균열을 조금 줄일 수 있음.

✨ 발췌
디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다. 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료구조라면 당연히 내부를 노출해야 하므로 디미터 법칙 적용할 필요 없다.

✨메모
함수형 프로그래밍은 부수효과가 존재하지 않는 수학적 함수에 기반한다.
참조 투명성의 장점 극대화 및 병렬 처리로 인기 상승.
<-> 명령형 프로그래밍은 대부분의 객체 지향 프로그래밍 언어로 메시지에 의한 객체의 상태 변경에 집중
"
2023-05-12 07:22:32,"김형우","[15일차]
https://engineer-diary.tistory.com/219"
2023-05-12 08:15:20,"박소환","17일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/98"
2023-05-12 08:46:29,"강민규","사진"
2023-05-12 08:47:05,"강민규","여러분 좋은 아침입니다. 2기는 이제 내일이 마지막 날이에요. 여러분도 하다보면 결국 끝이 올겁니다 화이팅"
2023-05-12 11:17:49,"궈노","15일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_15_205-216.md"
2023-05-12 11:18:04,"궈노","16일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_16_217-226.md"
2023-05-12 13:12:32,"송예은","17일차
ddd, msa

## 5.4.2 이벤트 스토밍 워크숍 진행

다음과 같은 순서로 진행한다.

도메인 이벤트 찾기 → 외부 시스템/외부 프로세스 찾기 → 커맨드 찾기 → 핫스폿 찾기 → 액터 찾기 → 애그리거트 정의하기 → 바운디드 컨텍스트 정의하기 → 컨텍스트 매핑하기

1. 도메인 이벤트 찾기
    
    데이터나 데이터 구조가 아닌 비즈니스 흐름에서 발생한 이벤트에 초점을 두어야 한다. 시스템의 화면을 연상하지 말고 비즈니스가 흘러감에 따라 비즈니스를 구성하는 요소들의 상태가 어떻게 변경되는지 생각한다.
    
2. 외부 시스템 도출
    
    이벤트를 도출하면서 레거시 시스템이나 외부 시스템과의 연계를 통해 업무 흐름이 진행될 때는 이벤트의 오른쪽 상단에 붙이고 화살표로 이 외부 시스템을 호출한다는 것을 표시한다.
    
3. 커맨드 도출
    
    도메인 이벤트를 찾은 후에 이 이벤트를 동작하게 하는 커맨드를 찾는다.
    
4. 핫스폿 도출
    
    워크숍 중에 해결할 수 없는 사항들을 기록해둔다.
    
5. 액터 도출
    
    액터는 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 도출한다.
    
    액터를 도출하면서 문장을 만들어 식별한 커맨드와 이벤트를 검토해보자.
    
6. 애그리거트 정의
    
    애그리거트는 커맨드와 도메인 이벤트가 영향을 주는 데이터로, 도메인의 실체 개념을 표현하는 객체인 엔티티가 된다.
    
7. 바운디드 컨텍스트 정의하기
    
    이름이 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 그린다. 기능을 제공할 책임들을 응집성 있도록 동일한 애그리거트 중심으로 모듈화해야 한다.
    
    정책을 도출하면서 연관관계를 생각해본다. 정책은 도메인 이벤트와 커맨드 사이에 존재한다.
    
8. 컨텍스트 매핑하기
    
    호출 관계의 방향, 호출 방식에 대해 생각해야 한다.
    
    호출 방식은 데이터의 일관성 측면과 컨텍스트의 가용성 측면을 고려해서 선택한다. 항상 일관된 데이터가 필요한 관계는 동기 호출로 표현하고, 결과적 일관성으로 충분하면 비동기 방식 호출로 표현한다.
    
    동기 방식은 두 컨텍스트 간의 의존도가 높아지고, 비동기 방식은 의존도를 낮출 수 있다. 즉, 반드시 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋다.
    
    이렇게 도출된 바운디드 컨텍스트는 마이크로서비스 후보가 된다."
2023-05-12 13:20:30,"다운","16일차

사피엔스

요약

자료처리 관료주의적 방식은 인간의 자연스러운 사고와는 멀어졌지만 아라비아 숫자가 등장함으로서 데이터를 엄청난 속도와 효율로 저장할수 있게 되어  더욱 중요해졌다. 

인간은 상상의 질서와 숫자로 대규모 협력 할 수 있었다. 상상의 질서는 허구에 근원두고 있지만 역사는 이를 자연적이고 필연적이라고 한다. 
상상의 질서로 차별이 만들어지는데 타고난 능력차이도 한몫하지만 대부분 태어난 배경때문이다.
힌두고는 청결과 불결로 계급을 나누는 기준이 되는데 이건 생물학적으로 질병을 가진 존재를 혐오하는 것과 관련있다. 

발췌

수가 적었던 침략자들은 특권적 지위와 고유의 정체성을 잃을까 두려웠다.

경제라는 게임은 법적인 제약과 비공식적인 유리천장으로 조작되게 마련이다.

대부분의 재능에는 육성과 개발이 필요하다는 것이다. 누군가가 재능을 타고났더라고 그것을 키우고 갈고 닦고 훈련할 환경이 되지 않으면 재능은 잠드는 것이 일반적이다. 

대부분 부자가 부유한 이유는 그저 부잣집에 태어났기 때문이고 대부분의 가난한 사람이 평생 가난한 덧은 그저 가난란 집에서 태어났기 때문이라는 것은 이미 증명된 사실이다. 

상상의 질서는 중립적이지도 공정하지도 않았다"
2023-05-12 16:55:11,"최희윤","16일차 DDD
https://www.notion.so/05-11-DDD-16-0e0ec53187504e38942c0903242a6a35?pvs=4"
2023-05-12 17:36:33,"최희윤","17일차 DDD
https://www.notion.so/05-12-DDD-17-6ef86fdfcef94ed4b5820000c7bdbbc1?pvs=4"
2023-05-12 17:40:18,"김연정","16일차
초전설득
초점의대상을빠르게바꾸기

우리는 변화에 시선을 집중시킨다. ’파블로프의 개’라는 이름으로 유명한 실험도 추가적인 참관자가 생겼을 경우에는 결과가 달랐음.(정향반사)

상대방에게 차별적인 무언가(낯설고 독창적인것)로 시선을 유도할 수 있다. 

메모
A와 B 상품 중 고르게 하는 것 보다 B와 유사한 상품 3가지를 선택지에 추가하면 A를 선택하도록 할 수 있다."
2023-05-12 17:49:20,"최희윤","18일차 DDD
https://www.notion.so/05-13-DDD-18-41eb6ab93f9041daa71c049619c70837?pvs=4

토요일 일정이 있어서 하루 미리 제출합니다"
2023-05-12 18:55:17,"김연정","17일차
초전설득
요약
어떻게 주의를 유지할 것인가?
1. 자기관련성: ‘당신’ 대명사 이용, 전하는 메세지가 설득력있을 경우에 사용, 자기관련성을 역이용해서 회의실에수 설득해야하는 사람의 바로 앞이나 뒷 순서에 발언하지 마라. 본인순서와 가까우면 제대로 듣지 않기 때문에, 먼 순서에 발언권을 가지고 옆에 앉는게 아닌 맞은편에 앉는다.
2. 끝내지 않는 것: 완수하지 못한 과제는 더 잘 기억에 남는다. (인지적 종결 욕구) 끝까지 보지 못한 광고가 더 기억에 남음. 최대 2주까지도 기억. 
3. 적용: 꼭 써야하는 글이 있다면 마지막 문장이나 단락을 끝내지 않으면 다음에 바로 쓸 수 있음. 강의를 할 때 끝나지 않는 미스테리 스토리를 활용.

메모
글쓸일 있을 때 써먹어봐야겠다."
2023-05-12 21:16:09,"뚯뚜오","- 16일차 총균쇠
    
    요약
    8장 작물화하는데 적합한 식물의 식별과 성패의 원인
    농업이 먼저 시작된 지역의 배경 : 원주민들이 문제였던가? 토착 작물들의 문제였던가? (참고로 가축의 후보인 야생 대형 포유류는 148종인데, 작물의 후보는 자그마치 20만종.)
    동일한 야생작물이 있었음에도 불구하고 작물화 한 지역과 작물화하지 못한 지역, 일찍 작물화 한 지역과 늦게 작물화 한 지역의 비교. (주로 비옥한 초승달지대-페르시아 지역, 미국 동부, 뉴기니 섬)
    비옥한 초승달지대의 특징 : 인구가 조밀함. 밀집지형에 고저차가 큼. 지중해성 기후이나 일교차 및 계절차가 심함. 야생 대형 포유류들이 근처에 있어 가축화 해 노동력을 벌충하기 유리했으리라고 추정. 그리고 창시작물 종자들이 좋았음.
    
    발췌
    총 20만 종의 야생 식물 중에서 인간이 먹을 수 있는 것은 수천 종에 불과하다. 그중에서 다소나마 현재까지 작물화된 것은 고작 수백 종에 지나지 않는다. 더구나 그 몇백 가지 농작물도 대부분은 우리의 식단을 약간 보완하는 정도일 뿐 그것만으로 문명의 발생을 뒷받침하기에는 부족했다.
    현대 세계에서 모든 농작물을 통틀어 연평균 총생산량의 80%를 책임지고 있는 농작물은 겨우 12종에 불과하다. ~~ 현대에 와서도 새로 작물화된 주요 식량 식물은 단 하나도 없다는 사실만 보아도 유용한 야생 식물은 이미 고대인들이 거의 빠짐없이 살펴보았고 그중에서 그럴 만한 가치가 있는 것들은 모조리 작물화했다는 것을 짐작할 수 있다.
    한 지역의 전체 식물군에서 작물화의 가능성은 어떻게 평가해야 할까? 예를 들어 아메리카 원주민들이 북아메리카의 사과를 작물화하지 못했던 진짜 문제는 인디언들이었을까, 사과였을까?"
2023-05-12 22:03:58,"김용기","17일차
DDD MSA 

## 5.4.2 이벤트 스토밍 워크숍 진행

### 1. 도메인 이벤트 찾기

- 시간의 흐름에 따라 시스템의 동작을 의미하는 도메인 이벤트를 도출한다.
- 데이터나 데이터의 구조가 아닌 비즈니스 흐름에서 발생한 이벤트에 초점을 두는 것이 중요하다.
- 도메인 이벤트는 비즈니스의 어떤 상태를 생성, 변경, 삭제하는 요소다.

### 2. 외부 시스템 도출

- 시스템 구현 범위에 있는 기능이 아니더라도 시스템의 기능 구현을 위해 연계가 필요한 시스템들은 모두 도출한다.

### 3. 커맨드 도출

- 도메인 이벤트를 찾은 후에 이 이벤트를 동작하게 하는 커맨드를 찾는다.

### 4. 핫스팟 도출

- 워크샵을 진행하는 과정에서 의문 사항이 생기거나 참여하는 사람들이 결정하기 힘든 사항, 다른 부서나 외부에 문의할 필요가 있는 사항과 같이 워크샵 중에 해결하거나 정의할 수 없는 것들이 파악될 수 있다. 이를 핫스팟이라고 한다.

### 5. 액터 도출

- 커맨드를 실행하는 액터를 도출하는데, 액터는 사용자 또는 조직, 역할자를 의미한다.
- 액터는 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 도출한다.
- 도메인 이벤트, 외부 시스템, 커맨드, 액터를 찾아봄으로써 전체 시스템의 큰 그림을 조망할 수 있다.
- 액터를 식별함으로써 주요 사용자나 역할자의 주요 프로세스도 그려볼 수 있다.

### 6. 애그리거트 정의

- 애그리거트는 커맨드와 도메인 이벤트가 영향을 주는 데이터 요소로 도메인의 실체 개념을 표현하는 객체인 엔티티가 된다.
- 애그리거트를 구체적으로 식별할수록 컨텍스트의 경계를 식별하는 데 유용하기 때문이다.

### 7. 바운디드 컨텍스트 그리기

- 도출했던 도메인 이벤트, 커맨드, 액터, 애그리거트를 모두 고려하여 경계를 식별한다. 이 경계를 바운디드 컨텍스트라고 한다.
- 애그리거트가 식별된 결과를 보면 동일한 이름의 애그리거트가 서로 다른 공간에 떨어져 있는 것을 발견할 수도 있는데 이것은 기능을 제공할 책임들을 응집성 있도록 동일한 애그리거트를 중심으로 모듈화해야 한다는 것을 의미한다.

### 정책을 도출하면서 연관관계 생각하기

- 정책은 이벤트 뒤에 따라오는 반응적인 비즈니스 로직으로 어딘가에 존재하는 커맨드를 동작하게 한다. 따라서 정책은 도메인 이벤트와 커맨드 사이에 존재한다.

### 컨텍스트 매핑

- 컨텍스트 관계를 작성할 때는 호출 관계의 방향을 고려해야 한다.
- 호출 방식은 데이터의 일관성 측면과 컨텍스트의 가용성 측면을 고려해서 서낵한다.
- 반드시 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋다. 비동식 방식의 연계로 두 컨텍스트 사이의 결합도를 낮춘다면 각 컨텍스트들의 독립성과 탄력성이 강화될 수 있다.
- 비동기 연동 방식은 동기 방식에 비해 마이크로서비스가 독립성을 갖게 하고 높은 가용성을 보장받을 수 있게 한다."
2023-05-12 22:06:49,"강민규","여러분 다들 퇴근하셨나요? 저는 어제부로 3년차 개발자가 되었습니다. 이년동안 도대체 뭘 한걸까 현타가 쎄게 와서 명상의 시간을 가지는 중입니다. 여러분들이라도 열심히 살고 계셔서 다행입니다.

@김형우 @Bo  @한종우 선생님들은 이틀치 분량 해보아요~

종우님께서는 미리 말씀해주셨지만 그냥 같이 언급 해드렸습니다~"
2023-05-12 22:32:06,"최윤지","17일차
[7가지코드]

https://quiet-jade-e60.notion.site/17-0512-7690f6c4ac824ec59451983d2f5a1043"
2023-05-12 23:04:25,"김형우","[16일차]
https://engineer-diary.tistory.com/220"
2023-05-12 23:49:30,"한종우","16일차

[헤드퍼스트 디자인 패턴]

- 어떤 클래스에 싱글턴 패턴을 적용하면 그 클래스의 인스턴스가 1개만 있도록 할 수 있다.
- 싱글턴 패턴을 사용하면 하나뿐인 인스턴스를 어디서든지 접근할 수 있도록 할 수 있다
- 자바에서 싱글턴 패턴을 구현할때는 private 생성자와 정적 메소드, 정적 변수를 사용한다
- 멀티 스레드를 사용하는 애플리케이션에서는 속도와 자원 문제를 파악해보고 적절히 구현해야 한다
- 클래스 로더가 여러 개 있는 경우에는 싱글턴이 제대로 작동하지 않고 여러 개의 인스턴스가 생길 수 있다.
- 싱글턴의 동기화 문제, 클래스 로딩 문제, 리플렉션, 직렬화와 역직렬화 문제를 자바의 enum을 사용하여 해결할 수 있다
- 싱글턴을 바꾸면 모든 객체도 바꿔야 할 가능성이 높아 싱글턴의 문제로 종종 느슨한 결합 원칙 위배가 이야기 나온다.
- 전역 변수는 객체의 정적 레퍼런스로 lazy하게 인스턴스 생성을 할 수 없고, 처음부터 끝까지 인스턴스를 가지고 있어야 하는 단점이 있다. 싱클턴 패턴은 클래스가 하나의 인스턴스만 가지도록 하고, 전역적인 접근을 제공할 때 사용한다. 또한 전역 변수를 사용하면 간단한 객체의 전역 레퍼런스를 자꾸 만들게 되어 네임스페이스가 지저분해질 수 있는데, 싱글턴 패턴은 그런 경우가 많이 없다."
2023-05-12 23:49:40,"한종우","17일차

[헤드퍼스트 디자인 패턴]

### 호출 캡슐화하기 - 커맨드 패턴

- 만능 IOT 리모컨을 만들어보자
    - 리모컨에는 그냥 ON/OFF 버튼만 있지만, 협력 업체에서 제공한 클래스는 다양한 메소드를 가지고 있고, 다른 제품이 추가될 수 있다
    - 새로운 클래스가 추가될때마다 리모컨에 코드를 고치는 것은 좋지 않다. 버그가 생길 가능성도 높아지고 매번 수정해야 하는 코드가 늘어난다
    - 커맨트 패턴을 통해 작업을 요청하는 쪽과 그 작업을 처리하는 쪽을 분리하자
- 객체 마을 식당에서 음식을 주문해보자
    - 고객 → 주문서 → 종업원 → 주방장
    - 주문서는 주문 내용을 캡슐화한다. 주문서는 주문 내용을 요구하는 객체이다.
    - 종원원은 주문스를 받고 orderUp() 메서드를 호출한다
    - 주방장은 식사를 준비하는데 필요한 정보를 가지고 있다.
    - 주반장과 종업원은 완전히 분리되어 있다
- 커맨트 패턴 (인보커 로딩)
    - 클라이언트는 커맨드 객체를 생성한다. 커맨드 객체는 리시버에 전달할 일련의 행동을 구성된다
    - 커맨드 객체에는 행동과 리시버의 정보가 같이 들어있다
    - 커맨드 객체에서 제공하는 메소드는 execute() 하나뿐이다. 이 메소드는 행동을 캡슐화하여 리시버에 있는 특정 행동을 처리한다.
    - 클라이언트는 인보커 객체의 setCommand() 메소드를 호출하는데, 이때 커맨드 객체를 넘겨준다. 그 커맨드 객체는 나중에 쓰이기 전까지 인보커 객체에 보관된다
    - 인보커에서 커맨드 객체의 execute() 메소드를 호출하면 리시버에 있는 행동 메소드가 호출된다"
2023-05-13 00:52:31,"Bo","16일차 
헤드퍼스트 

### 요약

- 싱글턴이 필요할 때 enum 을 써라
- 여러 개의 클래스 로더가 사용되는 상황이라면, 네임 스페이스가 달라 클래스를 여러 번 로드, 직 싱글턴이 깨질 수 있다
- 전역 변수보다 싱글턴이 갖는 장점은 lazy 하게 로드 할 수 있다는 점 ( 거의 안필요할 수도 있다..) 그리고 네임 스페이스를 전역 변수보다 깔끔하게 갖게 된다는 점이다.

### 발췌

> 싱글턴 패턴
> 
- 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역적 접근을 제공한다

### 메모

- 리플렉션, 역직렬화, 직렬화 문제도 싱글턴 패턴을 쓸 때 문제가 될 수 있다는데, 학습해 봐야곘다"
2023-05-13 08:53:06,"뚯뚜오","- 17일차 총균쇠
    요약
    비옥한 초승달지대의 축복받은 종자들 대비 빈약한 종자들로 스타팅하게 된 미국 동부와 뉴기니 (아메리카의 옥수수는 캐낼 가치가 없는 쓰레기에서 간신히 맛을 볼 수 있는 수준으로 진화하는데 수천 년 넘게 걸린것으로 추정됨)
    지중해성 기후처럼 기후 변화가 크면 종별 다양성이 크고, 진화의 속도가 빨라짐. 같은 지중해성 기후를 지닌 칠레, 캘리포니아, 남아공, 호주서남부 대비 유난히 종자들이 좋았음.
    비옥한 초승달지대가 지중해성 기후의 다른 지역과 다른 또 한가지는 다른 짧은 거리 안에서 고도 및 지형 변동이 크다는 점. 고도 변화가 크면 환경, 온도, 수확시기 등이 달라져 개량이 수월하고 굶는 시기가 없었을 것임. 저장기술이 빈약했던 시대에 일거에 수확하는 다른 지역은 풍년이 온다 하더라도 어려움을 겪었을 것임.
    또한, 대형 포유류 중 소, 돼지, 양, 염소와 같이 현재에도 꿀템인 가축들이 있었음. 뉴기니는 아예 없었고, 아메리카의 칠면조와 개는 농업을 발달시키기에 비옥한 초승달지대 대비 부족했음. 대형 포유류는 농업을 위한 노동력도 제공했으나 주요 단백질 공급원이기도 했음.
    당시 다른 지역의 원주민들은 좋은 종자가 들어오면 곧바로 확산시키고 개량한 흔적들이 있는 것으로 미루어보아 사람의 문제는 아니었으리라고 판단됨. 그냥 스타팅 포인트가 구린거였을 뿐.
    
    발췌
    고고학자들은 남북아메리카에서 아주 조그마했던 고대의 옥수수가 사람의 엄지손가락만큼 커지기까지 과연 몇백 년, 또는 몇천 년의 농작물 개발이 필요했는지에 대해서 지금도 활발한 논쟁을 벌이고 있다. ~~ 밀과 보리의 눈에 띄는 장점들과 돼지옥수수 문제점 사이의 이 대조적인 차이는 곧 신세계와 유라시아에서 인간 사회의 발전 양상이 서로 달라졌던 것에도 중요한 요인으로 작용했을 것이다."
2023-05-13 09:44:49,"강민규","여러분 좋은 아침입니다 날씨가 좋네요! 오늘도 화이팅입니다~"
2023-05-13 09:45:10,"강민규","사진"
2023-05-13 10:56:31,"Bo","17일차 
헤드퍼스트 
### 요약

> 커맨드 패턴이 필요한 상황
> 
- 작업을 요청하는 쪽과 (클라이언트) 와 작업을 처리하는 쪽 ( 예시에서, 주방장 ) 을 분리해야 할 때

> 커맨드 패턴 적용
> 
- 클라이언트는 커맨드를 만든다 ( createCommand)
    - 이 때 커맨드의 생성자에 리시버를 전달한다. 커맨드 안에 리시버는 필드로 선언된다
    - 커맨드에는 execute() 메서드가 제공된다. 외부에 제공되는 메서드는 이 메소드 뿐
    - execute() 의 구현에는 리시버가 할 행동들이 들어있다. 행동을 캡슐화하는 커맨드
- 클라이언트는 인보커에게 커맨드를 전달한다 ( setCommane )
    - 인보커 객체에 커맨드가 보관된다
- 인보커는 커맨드를 갖고 있다가 적정 시기에 자신이 갖고 있던 커맨드의 execute() 를 실행한다
- 리시버는 행동을 수행하게 된다"
2023-05-13 10:57:23,"뚯뚜오","- 18일차 총균쇠
    요약
    고지대 뉴기니인들의 토착적 식량 생산의 한계 : 아메리카 대륙으로부터 고구마가 들어와 비로소 안정적인 영양분을 확보하게 된 시점부터 급격하게 인구가 늘어나게 됨. 그러나 고구마에는 단백질이 부족하다는 한계가 있었음. 단백질을 보충하고 싶었지만 뉴기니에 대형 포유류는 캥거루, 화식조 정도가 끝. 살도 거의 없어 단백질 보충에 도움이 안됐음. 그나마 해안가의 뉴기니인은 물고기라도 간신히 잡아먹었는데, 고지대의 뉴기니인은 단백질 부족으로 배가 볼록 나온 상태로 살았음.
    
    발췌
    뉴기니 고지대의 어린이들은 올챙이배를 하고 있다. 그것은 양은 많지만 단백질이 부족한 식사를 할 때 나타나는 특징이다. 뉴기니인들은 남녀노소를 불문하고 가축화된 대형 포유류나 대형 야생 동물이 많은 지역에서는 먹지 않는 생쥐, 거미, 개구리를 비롯한 작은 동물들을 일상으로 잡아먹는다. 그리고 뉴기니의 전통적인 고지대 사회에 식인 풍습이 만연되어 있었던 궁극적인 이유도 아마 단백질 결핍 때문이었을 것이다.
    고구마는 고도가 높은 곳에서도 재배할 수 있고, 성장 속도도 빠르며 재배 면적당 생산량이나 노동 시간당 생산량도 높다. 고구마가 들어오고 나서 고지대의 인구는 폭발했다.
    … 그러므로 뉴기니의 토착적인 식량 생산에 한계가 있었던 것은 뉴기니인들과는 아무 상관도 없었다. 모든 것은 뉴기니의 생물상과 환경 때문이었던 것이다."
2023-05-13 11:28:27,"최다봄","17일차 (p. 227 ~ 239)

[헤드퍼스트 디자인 패턴]

**CHAPTER 06: 호출 캡슐화하기 - 커맨드 패턴**

- 메소드 호출을 캡슐화함으로써 계산 과정의 각 부분을 결정화할 수 있기에 계산하는 코드를 호출한 객체는 그 일이 어떤 식으로 처리되는지 전혀 신경 쓸 필요가 없다.
- 캡슐화된 메소드 호출을 로그 기록용으로 저장한다거나 재사용해서 취소 기능을 구현할 수도 있다.

### 요약

- 커맨드 패턴은 작업을 요청하는 클라이언트와 작업을 처리하는 리시버를 분리하는 패턴이다.
- 클라이언트는 **커맨드 객체**를 생성하고, 이 객체에 **행동과 리시버 정보를 저장**한다.
- 커맨드 객체는 **execute() 메소드**를 제공하며, 이 메소드는 **리시버의 특정 행동을 처리**한다.
- 클라이언트는 인보커에게 커맨드를 전달하여 보관시키고, 인보커는 적정 시기에 보관한 커맨드의 execute()를 호출하여 리시버가 행동을 수행하도록 한다. 이를 통해 클라이언트와 리시버 간의 결합도를 낮추고, 유연성을 높일 수 있다."
2023-05-13 11:43:44,"호02","17일차 제출

[초전 설득]

1. 요약 
 - 나와 직접적으로 관련된 정보에는 계속 관심을 가지게 된다. 그래서 한편으로는 상대방의 주의를 이끌러면 상대방 스스로가 집중해게되는 타이밍에 벗어나서 진행해야 한다.
 - 그래서 계속 집중을 유지하려면 과제를 완료하지 않고 놔두는 것이다. 이미 완료가 되었거나 결말이 예상이 되면 사람은 거기에 신경을 덜 쓰게 된다.
 
2. 메모
 - 시작이 반이라는 말이 생각났다. 시작을 하게되면 아무래도 거기에 집중을 할 수 밖에 없으니."
2023-05-13 12:00:00,"호02","18일차 제출

[초전 설득]

1. 요약 
 - 미스터리를 활용하면 주의를 유지시킬 수 있다. 대표적인 예시가 모나리자이다. (눈썹이 왜 없고, 모델이 누구이며 등등)
 - 정보 제공을 총 6단계로 나눠서 진행하면 효과적이라고 한다.
  > 미스터리를 제공한다.
  > 미스터리를 심화한다.
  > 대안 및 반론 제시 후 적절한 설명으로 넘어간다.
  > 설명의 단서를 제공한다.
  > 미스터리를 해결한다.
  > 현상의 시사점을 설명한다.
 
2. 메모
 - 이 책에서도 담배 회사가 TV 광고를 하지 않는 이유를 6단계에 걸쳐서 설명하는데, 나도 모르게 글에 더 집중이 됐던 거 같다. "
2023-05-13 13:54:10,"박소환","18일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/99"
2023-05-13 23:43:07,"김용기","18일차
DDD MSA

## 5.5 마이크로서비스 상세설계

## 5.5.1 프런트엔드 모델링

### 프런트 아키텍처 정의

- 모바일, 앱, 웹 채널을 모두 고려하고 어떤 매체에서나 사용자 경험에 민감하게 반응할 수 있는 반응형 UI를 지향하는 경향이 높아지고 있다.
- 이를 모두 지원하는 프런트엔드 프레임워크가 많이 등장했으며 최근에는 리액트와 뷰를 많이 사용하는 추세다.
- 프런트엔드 프로그램의 패키지 구조는 명확히 물리적으로 분리할 수도 있고, 모노리스 구조를 유지한다면 패키지별로 명확히 오너십이 구분되게 하자.

### 표준 레이아웃 정의

- 시스템의 목적과 기능을 고려해서 화면의 표준 레이아웃을 정의해야 한다.

### UI 레이아웃 설계

- 표준 유형을 기반으로 개별 UI 레이아웃을 정의한다.

### UI 디자인 및 UI 레이아웃 반영

- 표준 화면 유형에 맞는 UI 디자인을 정의한다.

### 이벤트 설계

- 화면의 이벤트 변화에 따라 백엔드 API를 호출하는 방식을 정의한다.

## 5.5.2 백엔드 모델링

- 헥사고날 아키텍처를 적용해 외부 영여고가 내부 영역으로 구분되어 진행한다.
- 이벤트 스토밍 결과를 반영해서 백엔드 마이크로 서비스의 내부를 헥사고날 구조로 정의하고 매핑할 수 있으며 이를 기반으로 발전시켜 나갈 수 있다.
- 커맨드는 렉사고날의 인바운드 어댑터의 하나인 REST API가 된다.
- 애그리거트는 헥사고날의 내부 영역인 도메인 모델이 된다.
- 도메인 이벤트는 헥사고날 외부 영역의 아웃바운드 메세지 처리 어댑터의 처리 대상이 된다.
- 외부 시스템은 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템으로 매핑된다.
- 외부 영역 설계는 프런트엔드와 연계되는 API 설계로 내부 영역은 비즈니스 로직을 구현하는 도메인 모델링, 데이터 모델링으로 구체화되어 진행된다.

### API 설계

- API 는 백엔드 서비스에 존재하지만 프런트엔드의 요구사항을 충족하도록 정의해야 한다.
- API 영역은 앞에서 언급한 바와 같이 헥사고날의 외부 영역이며 인바운드 어댑터로써 어떠한 호춟 ㅏㅇ식도 허용되는 유연한 공간이다.

### REST API 의 개념

- 아키텍처를 표현하는 구성요소로 자원(resource), 행위 (verb), 표현(representations)이 있다.

### REST API의 성숙도

- 레벨 0는 REST API의 메커니즘을 전혀 사용하지 않고 전통적인 우너격 프로시저 호출 방식으로 HTTP 프로토콜만사용한 것이다. 개발자가 백엔드 내부에서 비즈니스 로직을 통해 어떠한 결정을 하는지 사용자는 API를 보고는 알 수 없기 때문에 API 명세가 필요하다.
- 레벨 1은 URI에 개별적인 자원을 표현하는 것이다. 사용자는 특정 리소스가 어떤 정보를 제공하는지 인지할 수 있다.
- 레벨 2는 서비스의 기능을 처리하기 위해 약속된 HTTP 메서드를 사용하는 것이다. 사용자는 리소스에 어떠한 메서드를 사용했을 때 어떠한 행위가 발생할 지 인지할 수 있다.
- 레벨 3은 사용자에게 좀 더 리소스를 탐색해서 활용할 수 있는 가능성을 제공한다.
- REST API의 사용을 암묵적으로 가능하게 하는 레벨 2 정도를 지향하는 것이 좋다.

### API 설계 문서화

- 애자일 모델링 방식을 추구할 때 가급적이면 불필요한 설계물을 남기는 것은 바람직하지 않다. 산출물의 필요성은 항상 공유와 협업 측면에서 고려하자.
- REST API설계는 다른 설계 요소에 비해 공유가 중요하다."
2023-05-14 04:57:45,"리경","17일차
오브젝트

✨ 요약
#책임에 초점 맞춰라
디미터 법칙 준수 + 묻지 말고 시켜라 + 의도 드러내는 인터페이스 = 책임에 초점을 맞춰 메시지를 먼저 선택하고 그 후 메시지를 처리할 객체를 선택하는 것

07 객체 분해
실제 문제를 해결하기 위해 사용하는 저장소는 단기 기억. 단기기억 용량 초과시 문제 해결 능력 급격히 떨어짐. 인지 과부하. 방지 위해서는 보관 정보 양 조절 필요.
한 번에 다뤄야 하는 정보 수 줄이기 위해 본질적 정보만 남기고 불필요한 세부 사항만 걸러내는 단순화 = 추상화

현대적 프로그래밍 언어의 큰 추상화 메커니즘 : 프로시저 추상화, 데이터 추상화

#프로시저 추상화와 기능 분해
하향식 접근법 : 시스템 구성하는 최상위 기능 정의하고, 더 작은 단계 기능으로 분해
"
2023-05-14 09:16:53,"다운","17일차

사피엔스

요약

미국은 지리적 접근성, 노예소유시장존재, 질병의 면역성으로 아프리카인들을 노예로 삼았다. 또 그들의 행위를 정당화 시키기 위해 종교적, 과학적 신화를 동원하였다. 이런 역사가 반복되자 흑인 스스로도 자신을 무지하고 열등하다고 여겼으며 이 흑백위계질서는 더더욱 거세졌다.

모든 인간사회에서는 성별에 따른 차이가 보여지는데 많은 사회에서 여성은 남성의 소유물에 불과했다. 생물학적 차이가 문화적 개념과 규범을 만들었다. 

생물학적으로 동성애는 자연스러운 것이지만 기독교의 영향으로 동성애를 부자연스러운것으로 인식한다. 그들은 신체 장기가 각각 역할이 있다고 하지만 장기도 진화의 산물이며 그 사용방식은 계속 변화해왔다. 

발췌

자연은 가능하게 하고 문화는 금지한다.

곤충의 날개는 날지 못하는 벌레의 신체에서 돌출된 부위로부터 수백만년 진화했다.

역사의 특권을 누린 계층은 또 다시 특권을 누릴 가능성이 크다

역설적이게도 유전적우월성이 사회적 열등성으로 번역됐다

1958년 미국 미시시피 대학교에 지원한 흑인 학생 클레넌 킹은 정신병원에 강제 수용되었는데 판사가 미시시피 대학교에 들어갈 수 있다고 생각한 흑인은 제정신이 아니다라고 판결했기 때문이었다"
2023-05-14 09:49:27,"송예은","18일차
DDD MSA

# 5.5 마이크로서비스 상세설계

## 5.5.1 프런트엔드 모델링

프런트엔드 모델링의 설계 영역은 다음과 같다.

- 프런트 아키텍처 정의
- 표준 레이아웃 정의
- UI레이아웃 설계
- UI 디자인 및 UI레이아웃 반영
- 이벤트 설계

## 5.5.2 백엔드 모델링

- 백엔드 마이크로서비스를 위한 설계는 헥사고날 아키텍처를 적용해 외부 영역과 내부 영역으로 구분되어 진행된다.
- 이벤트 스토밍의 커맨드는 헥사고날 인바운드 어댑터의 하나인 REST API가 되고, 애그리거트는 헥사고날 내부 영역인 도메인 모델이 되며, 도메인 이벤트는 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상이 되고, 외부 시스템은 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템으로 매핑된다.

### API 설계

- API는 백엔드 서비스에 존재하지만 프런트엔드의 요구사항을 충족하도록 정의해야 한다.
- REST API
    - 직접적인 사용의 주체가 되는 요소를 자원이라 하며, URI 형식으로 표현된다.
    - API를 사용하기 위한 입출력 데이터로 JSON 포맷을 활용한다. 행위를 표현하기 위해 HTTP 메서드를 활용한다."
2023-05-14 11:47:40,"다운","18일차

사피엔스

요약

남성성과 여성성을 규정하는 법과 규범 등은 생물학적 실체보다  인간의 상상력을 더 많이 반영한다. 
농업혁명 이후부터 대부분의 인간사회는 부계사회였다.
이유에 여러 가설이 있는데 첫째는 근력, 하지만 근력은 사회적 권력에 직접적 연관이 없다. 사회성 높은 이가 권력을 차지한다. 둘째는 남성의 공격성, 하지만 전쟁시 칼을 휘두르지 않은 관리들이 리더가 된다. 온화함과 관용이 전쟁 승리에 결정적이다. 셋째는 가부장적 유전자. 하지만 여성은 남성에게 의존하는것이 아니라 보통 같은 여성들끼리 협력하고 유대한다.

발췌

협력이라는 우월한 사회적 기술을 이용해 공격적이고 자율적이머 자기중심적인 남자들의 허를 찌르구 조종하리라고 예상할 수 있다.

공격적인 야수는 전쟁 지휘관으로서 최악일때가 많다. 그보다는 유화정책을 쓸 줄 알고 사람들을 조작할줄 알고 사물을 다른 각도에서 볼 줄 아는 협동적인 인물이 훨씬 낫다.

칼이라고는 한 번도 휘둘러보지 못한 관리가 전쟁을 지휘하는 경우가 흔했다.

이십대 청년들이 연장자보다 훨씬 힘이 센 데도 불구하고 육삽대의 사람들이 이십대들에게 권력을 행사하는 것이 보통이다

수렵채집사회에서 정치작 지배력을 지닌 사란은 사회성이 가장 뛰어난 사람이다.

특히 남성은 자신의 남성성을 잃을까봐 끊임없이 두려워하며 살아간다. 역사를 통틀어 남성들은 오직 남들에게서 그는 진짜 남자야 라는 말을 듣기 위해서 기꺼이 생명을 무릅쓰거나 심지어 목숨을 바쳐왔다"
2023-05-14 12:59:02,"김연정","18일차
초전설득

요약
정말로 잘 쓴 글들은 모두 미스테리로 시작해서 흥미진진하게 만듬. 완료하지 못한 과제를 끝내고 싶은 인간의 욕구에수 비롯. 강의에 활용했을 때 학생들의 집중도가 높았음.
마찬가지로 설득할 때에는 잘 알려지지 않은 사실을 알리면 우위를 점할 수 있다.
효과적인 순서: 미스터리제공>심화>대안혹은반박내용>적절한설명>미스터리해결>시사점제공"
2023-05-14 13:35:13,"Bo","18일차 
헤드퍼스트 
### 요약

- 커맨드는 일련의 행동을 특정 리시버와 연결해서 캡슐화 한다
- 리모콘 예제 결과 :  리모컨과 실제 동작을 구현하는 쪽 ( concrete 를 분리했으며 ) 리모컨은 커맨드가 execute() 메소드가 있다는 것만 알고, 이를 실행 하면 된다
    - 추가적인 동작이 생산되더라도 ( 에어콘 제어 등 ) 리모컨에는 변화가 필요 없다
- 람다식 활용하기 :
    - 추상 메소드가 하나 뿐일 때, 람다식을 활용하면 LightCommandOn 같은 클래스 만들지 않고도 light.on() 메서드를 바로 전달해서 코드를 간결하게 만들 수 있다

## 메모

> null 객체
> 
- 이 책의 예제에서는 null 대신 NoCammnd, NoQuack 처럼 아무 것도 하지 않는 객체를 만드는데 이 방법이 나름 쓸모있는 것 같다. 클래스 이름으로 어떤 상태인지 알 수 있으며, nullable 로 안만들어도 되니까
- (발췌) 널객체를 일종의 디자인 패턴으로 분류하기도 한다

### 발췌

> 커맨드 패턴
> 

커맨드 패턴을 사용하면 요청 내용을 객체로 캡슐화해서 객체를 서로 다른 요청에 따라 매개변수화 할 수 있다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 이용할 수 있습니다 

- 커맨드로 묶는 것은 이해가 이제야 갔다. 커맨드로 묶음으로서 여러 요청들을 커맨드로 관리할 수 있는 것"
2023-05-14 14:53:05,"리경"," 18일차 
오브젝트

✨ 요약
#하향식 기능 분해의 문제점
비즈니스 로직이 사용자 인터페이스와 강한 결합
유연성 재사용성 저하
데이터 형식 변경시 파급효과 예측 불가
기능 추가 등 변경으로 인하 메인 함수 빈번히 수정. -> 버그 발생 확률 높아짐

하향식 설계와 관련된 모든 문제의 원인은 결합도.

의존성 관리 핵심 : 변경 영향 최소화 위해 영향 받는 부분과 받지 않는 부분 명확히 분리. 
잘 정의된 퍼블릭 인터페이스 통해 변경되는 부분에 대한 접근 통제.
데이터와 함께 변경되는 부분 = 구현 단위
외부에서 제공되는 함수만 이용해 데이터 접근."
2023-05-14 19:50:16,"강민규","여러분 좋은 주말을 보내고 계신가요? 2기는 완주율 80프로가 넘은 채로 마무리했습니다! 3기는 이미 많은 분들이 탈락하셨지만 남은 분들은 더 이상 탈락하지 않을 수 있도록 최선을 다해 동기부여를 해보도록 하겠습니다!

그런 의미에서 @이찬영 @수정 @궈노 @김형우 선생님들은 오늘까지 금, 토 분량 제출하여서 다음 주는 또 다음 주로 새롭게 시작할 수 있도록 해보아요"
2023-05-14 20:08:52,"김형우","[17일차]
https://engineer-diary.tistory.com/222"
2023-05-14 22:11:31,"최윤지","18일차
[7가지코드]

https://quiet-jade-e60.notion.site/18-0513-0040d079ccdc415091241bb1c9c99bf6"
2023-05-14 22:31:29,"수정","17일차
헤드퍼스트 디자인 패턴

- 인터페이스가 서로 다른 불특정다수 클래스들을 같은 인터페이스에 맞춰서 관리해야 하는 상황
    - 컨트롤러는 관리할 클래스에 대해 자세히 알 필요 없게 한다
    - **커맨드 객체**가 컨트롤러와 관리되는 클래스의 메소드 사이의 연결 역할을 한다
- 커맨드 객체 비유: 식당의 음식 주문 과정
    - 종업원: 주문서에 적힌 음식에 대해 전혀 모른다. 주문서를 주방으로 전달함 <리모컨>
    - 주방장: 주문서에 있는 음식 준비(메소드 호출) <실제 일하는 코드>
- 커맨드 패턴
    - 클라이언트에서 커맨드 객체 생성
    - setCommand()를 호출해서 인보커(종업원)에 커맨드(주문서) 객체를 저장
    - 나중에 클라이언트(고객)에서 인보커(종업원)에게 그 명령을 실행하라고 요청
    - 커맨드 구상클래스는 커맨드 인터페이스의 execute() 추상메소드 구현"
2023-05-14 22:32:06,"수정","18일차
헤드퍼스트 디자인 패턴

- 커맨드 패턴
    - 요청 내역을 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다.
        <가능한 것들>
        - 요청을 큐에 저장
        - 로그로 기록
        - 작업 취소
- 클라이언트는 ConcreteCommand(주문서)와 Receiver(어떤 행동을 할지 알고 있는 객체)를 설정
- Invoker(종업원)에는 커맨드가 들어있고, 커맨드.execute()를 호출함으로써 Receiver(주방장)에 실행 지시 전달함
- ConcreteCommand는 특정 행동과 Receiver를 연결해준다. execute를 호출할 때 ConcreteCommand 객체에서 리시버에 있는 메소드를 호출해 작업을 처리한다
- Invoker ( command.execute ) ⇒ receiver의 action() 호출
- NoCommand: null객체 대신 활용
    - 명령이 아직 할당되지 않은 슬롯에서 execute()가 호출되어도 문제생기지 않도록
    - 일종의 디자인 패턴으로 분류하기도
- 자바의 람다 표현식을 쓰면 구상 커맨드 객체를 생성하는 단계를 건너뛰고 그 자리에 **함수 객체**를 사용할 수 있다
    - Command 인터페이스에 추상 메소드가 하나뿐일 때만 사용 가능
- command.undo()
    - 마지막으로 실행된 명령을 기록해야 (⇒ 인스턴스 변수)
        - `undoCommand = noCommand;`
    - 선풍기의 속도를 이전 속도로 돌리기
        - prevSpeed를 저장해뒀다가 undo호출되면 그 스피드로 돌리기"
2023-05-15 00:39:48,"김연정","19일차 7장 시작~ 단어에대한자연스러운노출
20일차 ~부정적인 연상을 피하라
21일차 ~나는곧우리이고우리는최고다
22일차 ~8장 전까지
23일차 우리안에이미있는것
24일차 ~개인의 행복을 증가시키는 세개의 활동
@호02 다음주치입니다:)"
2023-05-15 00:42:15,"호02","@김연정 감사합니당~"
2023-05-15 01:22:09,"이찬영","17일차
헤드퍼스트 디자인패턴 [3주차_금요일] 
227-239pg

https://ribbon-utahraptor-ec5.notion.site/17-75d8797451404fc8b534b751412e72ed"
2023-05-15 02:00:18,"이찬영","삭제된 메시지입니다."
2023-05-15 02:00:40,"이찬영","18일차
헤드퍼스트 디자인패턴 [3주차_토요일] 
240-256pg

https://ribbon-utahraptor-ec5.notion.site/18-352911c5600c4a1db12d84c864a44078"
2023-05-15 07:41:06,"궈노","17일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_17_227-239.md"
2023-05-15 07:41:23,"궈노","18일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_3/day_18_240-256.md"
2023-05-15 08:58:46,"강민규","사진"
2023-05-15 08:59:40,"강민규","좋은 아침입니다. 이제 날이 슬슬 더워질까 말까 하는데 일교차가 크니 겉옷을 챙겨다녀봅시다"
2023-05-15 10:39:41,"송예은","19일차
ddd,msa

# 5.6 도메인 모델링

- 마이크로서비스 내부 구조는 폴리글랏하게 접근할 수 있다.
    
    서비스 내부 영역의 구조를 도메인 모델 중심으로 만들 수도 있고 트랜잭션 스크립트 형태로 만들 수도 있다.
    
- 도메인 모델 중심 구조
    
    도메인 모델을 중심으로 모델링을 수행해야 하며, 서비스가 모든 로직을 처리하지 않고 비즈니스 로직이 도메인 모델로 위임되어 적절히 분산된다.
    
- 모데인 모델이 없는 트랜잭션 스크립트 구조
    
    DTO는 데이터 묶음으로써의 역할만 수행하고, 서비스가 많은 로직을 보유하게 되어 시스템이 복잡해질수록 비대해진다.
    

## 5.6.1 DDD의 전술적 설계(도메인 모델링 구성요소)

기존 객체 모델링 방식은 자유도가 높아 문제 영역을 파고들수록 여러 층의 복잡한 계층 구조를 만들게 될 가능성이 높다. 이를 정리하기 위해 객체들의 역할에 따른 유형을 정의하고 이런 규칙에 따라 모델링하면 단순, 이해하기 쉬워진다.

- 엔티티
    
    엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체다. 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다.
    
- 값 객체
    
    값 객체는 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다.
    
    값 객체는 속성과 속성의 합에 의해 전체 개념이 부여되며, 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체다.
    
- 표준 타입
    
    표준 타입은 대상의 타입을 나타내는 서술적 객체다. 속성을 구분하는 용도로 사용한다.
    
- 애그리거트
    
    연관된 엔티티와 값 객체들의 묶음이 애그리거트다. 애그리거트 단위가 트랜잭션의 기본 단위가 된다.
    
    애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정하고, 이 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있다.
    
    애그리거트 간 참조는 애그리거트 루트의 식별자를 활용해 간접 참조하는 것이 바람직하다.
    
    도메인 이벤트를 통한 결과적 일관성을 사용해 다른 애그리거트를 갱신해서 일관성을 유지한다.
    
    DDD에서는 명확한 클래스의 유형과 애그리거트 단위 식별을 통해 또메인 모델을 간결하고 단순하게 유지하는 것을 추구한다.
    
- 도메인 서비스
    
    도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 하는데, 이를 도메인 서비스라 한다. 도메인 서비스에서는 상태를 관리하지 않고 행위만 존재한다.
    
- 도메인 이벤트
    
    도메인 이벤트는 DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체다. 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다."
2023-05-15 17:49:55,"수정","19일차
헤드퍼스트 디자인 패턴

- **커맨드 패턴 Q&A**
    - 항상 리시버가 필요한가? 커맨드 객체에서 execute()를 구현하면 안될까? ⇒ “스마트 커맨드 패턴”
        커맨드 객체에서 행동을 처리하면 
        - 인보커와 리시버를 구분하기 어려움
        - 리시버로 커맨드를 매개변수화할 수 없음
    - 작업 취소의 히스토리 기능을 구현하는 방법 (여러 번 UNDO)
        - 직전 커맨드 뿐 아니라 모든 실행한 커맨드를 스택에 넣는다
    - 파티 모드를 구현할 때 PartyCommand의 execute() 메소드에서 다른 커맨드 객체의 execute()를 호출해도 되는지?
        - 가능하지만 PartyCommand에 파티 모드 코드를 직접 넣어야하므로 유지보수 귀찮고 실행될 커맨드를 동적으로 결정할 수 없어서 유연하지 못하다
- **요청을 큐에 저장하기**
    - 커맨드들을 큐에 저장하고 실행
- 커맨드 로그를 쌓았다가 시스템이 다운되었을 때 순서대로 실행시키기
    - store(), load() 메소드 추가
- 정리
    - 커맨드 패턴을 사용하면 요청하는 객체와 그 요청을 수행하는 객체 분리
    - 커맨드는 인보커를 매개변수화할 수 있다
    - 커맨드 객체는 리시버를 캡슐화
    - 리시버에서 요청을 처리"
2023-05-15 20:59:50,"강민규","여러분 오늘 하루 어떘나요? 월요일 마지막을 독서로 장식해봅시다~ 이번 주 내내 승리의 마인드로 지내실 수 있습니다!

@김형우 @최다봄 @한종우 
선생님들은 이틀치 분량으로 해보아요~~"
2023-05-15 21:02:22,"최희윤","삭제된 메시지입니다."
2023-05-15 21:02:39,"최희윤","19일 DDD
https://www.notion.so/05-15-DDD-19-2144f588183b4d239a40002a69991768?pvs=4"
2023-05-15 22:31:19,"최윤지","19일차
[7가지 코드]

https://quiet-jade-e60.notion.site/19-0515-fc51a3ed338f473abc7a6f82ebd24951"
2023-05-15 22:50:12,"이찬영","19일차
헤드퍼스트 디자인패턴 [4주차_월요일] 
257-271pg

https://ribbon-utahraptor-ec5.notion.site/19-19724eb862164197b88eae3571904c6f"
2023-05-15 23:47:22,"박소환","19일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/100"
2023-05-15 23:49:06,"최다봄","18일차 (p. 240 ~ 256)

[헤드퍼스트 디자인 패턴]

**CHAPTER 06: 호출 캡슐화하기 - 커맨드 패턴**

- 메소드 호출을 캡슐화함으로써 계산 과정의 각 부분을 결정화할 수 있기에 계산하는 코드를 호출한 객체는 그 일이 어떤 식으로 처리되는지 전혀 신경 쓸 필요가 없다.
- 캡슐화된 메소드 호출을 로그 기록용으로 저장한다거나 재사용해서 취소 기능을 구현할 수도 있다.

**[슬롯에 명령 할당하기]**

- 리모컨 ⇒ 인보커
1. 슬롯마다 명령(커맨드 객체)이 할당된다.
2. 사용자가 버튼을 누르면 그 버튼에 맞는 커맨드 객체의 execute() 메소드가 호출된다.
3. execute() 메소드는 리시버가 특정 작업을 처리하도록 지시한다. 

**[커맨트 패턴 정의]**

- 커맨드 패턴을 사용하면 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화 할 수 있다.
- 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.
- 명령으로 객체를 **매개변수화**

**[NoCommand 객체]**

- 일종의 널 객체(null Object)
- 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용
- 4 ~ 6번 슬롯처럼 리모컨에 명령이 아직 할당되지 않은 부분에 NoCommand 객체를 넣어서 execute() 메소드가 호출되어도 문제 생기지 않도록 한다.

**[작업 취소 기능 - 상태를 저장해서 작업을 취소]**

- undo()메소드는 execute() 메소드에서 했던 작업과 정반대의 작업 처리하면 된다. (커맨드 클래스에 작업 취소 기능을 추가하기 전에 Command 인터페이스에 undo() 메소드를 추가해야한다.)
- 상태 지역 변수로 데이터를 저장하고, 취소하게 되면 이전 데이터로 되돌린다."
2023-05-15 23:49:11,"최다봄","19일차 (p. 257 ~271)

[헤드퍼스트 디자인 패턴]

**CHAPTER 06: 호출 캡슐화하기 - 커맨드 패턴**

**[여러 동작을 한 번에 처리하기 - 리모컨에 파티 모드 추가]**

- 다른 커맨드를 실행할 수 있는 새로운 종류의 커맨드를 만들어서 여러가지 커맨드를 한 번에 실행할 수 있을 것 같다..
    - Command 배열을 받아서 MacroCommand 안에 저장
    - 매크로를 실행하면 각 커맨드를 순서대로 실행

**[매크로 커맨드 사용하기]**

1. 매크로에 넣을 일련의 커맨드 만들기
2. ON 커맨드, OFF 커맨드용 배열을 만들고 필요한 커맨드를 넣는다.
3. MacroCommand 객체를 버튼에 할당한다.
4. 버튼을 눌러 보고 제대로 작동하는지 확인한다.

⇒ ON 매크로를 호출하면 매크로에 들어있는 모든 커맨드들이 실행된다 !

**[커맨드 패턴 활용 - 요청을 큐에 저장하기]**

- 커맨드로 컴퓨테이션(computation)의 한 부분(리시버와 일련의 행동)을 패키지로 묶어서 일급 객체 형태로 전달가능하다.
- 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 computation을 호출 할 수 있다.
    
    ⇒ 이를 활용하여 커맨드 패턴 적용: 스케줄러, 스레드 풀, 작업 큐
    
- **작업 큐** : 한 쪽 끝은 커맨드를 추가할 수 있고, 다른 쪽 끝에는 커맨드를 처리하는 스레드들이 대기하고 있다.
- **각 스레드는 우선 execute() 메소드를 호출하고 호출이 완료되면 커맨드 객체를 버리고 새로운 커맨드 객체를 가져온다.**
    - 작업 큐 클래스는 계산 작업을 하는 객체들과 완전히 분리되어있음.
    - 큐에 커맨드 패턴을 구현하는 객체를 넣으면 그 객체를 처리하는 스레드가 생기고 자동으로 execute() 메소드가 호출된다.

### 발췌

**[커맨드 패턴]**

- 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다."
2023-05-15 23:52:50,"김용기","19일차 
DDD MSA 

# 5.6 도메인 모델링

- 마이크로서비스의 내부 구조는 폴리글랏하게 접근할 수 있다. 폴리글랏은 애플리케이션을 구현하는 언어나 데이터를 저장하는 저장소를 서비스마다 다양하게 활용할 수 있다는 의미로, 내부 아키텍처 구조를 서비스 특성에 맞게 다양하게 수립할 수 있다는 의미다.
- 도메인 모델 중심의 구조는 도메인 모델을 중심으로 모델링을 수행해야하며, 서비스가 모든 로직을 처리하지 않고 비즈니스 로직이 도메인 모델로 위임되어 적절히 분산될 것이다.
- 비즈니스가 복잡해질수록 비즈니스 개념들을 잘 구조화할 수 있는 도메인 모델 구조가 효과적이다. 도메인 모델 구조는 복잡함을 다루어 쉽게 표현할 수 있는 구조를 제공하기 때문이다.

### 5.6.1 DDD의 전술적 설계

- DDD의 전술적 설계는 앞에서 언급한 것처럼 도메인 모델을 구성하기 위한 패턴들을 설명한다.
- 객체들의 역할에 따른 유형을 정의하고 이러한 규칙에 따라 모델링하면 단순하고 이해하기가 수월해지는데 이러한 설계 기법을 DDD의 전술적 설계에서 제공한다.

### 엔티티

- 엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체다.

### 값 객체

- 값 객체는 각 송석ㅇ이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다.
- 엔티티와 같이 식별자의 차이에 따라 구별되지 않고 속성과 속성으로 이뤄진 값의 비교에 의해 동일함이 결정된다.
- 값 객체는 일단 생성되면 변경할 수 없다.

### 표준 타입

- 표준 타입은 대상의 타입을 나타내는 서술적 객체다. 엔티티나 값 객체의 속성을 구분하는 용도로 사용한다.

### 애그리거트

- 엔티티와 값 객체로 모델링하게 되면 자연스럽게 객체 간의 계층구조가 만들어진다. 이처럼 연관된 엔티티와 값 객체들의 묶음이 애그리거트다.
- 애그리거트는 트랜잭션의 기본 단위가 된다.
- 다른 애그리거트를 참조해야할 필요가 있다면 직접 참조하지 않고 참조할 애그리거트 루트의 식별자를 통해 참조하게 한다. 직접 참조하는 경우 애그리거트 단위의 트랜잭션 처리도 힘들고 의존관계가 점점 복잡해질 것이다.
- 도메인 이벤트를 통한 결과적 일관성을 사용해 다른 애그리거트를 갱신해서 일관성을 유지한다.
- DDD에서는 명확한 클래스의 유형과 애그리거트 단위 식별을 통해 모데인 모델을 간결하게 단순하게 유지하는 것을 추구한다."
2023-05-16 00:00:58,"호02","19일차 제출

[초전 설득]

1. 요약 
 - 언어의 주된 존재 이유는 목적을 말하는 사람이 듣는 사람의 주의를 유도하는 것이다.
 - 생각을 전달하는 도구로만 여기면 안 된다.
 - 모든 개념은 서로 연결되어 있다.
 - 나쁜 말은 나쁜 생각과 행동으로 이어지기 때문에 단어 하나하나를 신경써야 한다. 
 - 한 예시로 SSM이라는 회사에서는 무찌르는 의미의 ""타켓""보다는 앞서나가는 의미의 ""목표""를 사용하여 비즈니즈 목표라고 표현한다.
 
2. 메모
 - 말을 할 때 생각을 전달하는 것에 그치는 게 아니라 주의를 유도한다는 관점을 가지는 게 일할 때 유리한 위치를 잡을 수 있겠다는 생각이 든다. "
2023-05-16 00:43:20,"한종우","18일차

[헤드퍼스트 디자인 패턴]

- 커맨드 패턴을 사용하면 요청 내역을 개겣로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 이있다.
- 커맨트 패턴을 사용하면 특정 인터페이스만 구현되어 있을때 그 커맨드 객체에서 실제로 어떤 일을 하는지 신경 쓸 필요가 없다.
- 리모컨 개발에서 리모컨이 인보커가 되는 것이고, 사용자가 버튼을 누르면 그 버튼에 맞는 커맨드 객체의 execute() 이 실행되면서 리시버(조명, 선풍기, 오디오) 등에서 특정 행동을 담당하는 메소드가 실행된다. execute() 메소드는 리시버가 특정 작업을 처리하도록 지시한다.
- Null 객체는 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게하고 싶을 때 사용하면 좋다. 매번 조건 검사를 통해 확인 후 실행하는 것이 아닌 아무것도 하지 않는 클래스를 만들어 사용할 수 있다. Null 객체는 여러 디자인 패턴에서 유용하게 사용된다
- 람다 표현식을 통해 구상 커맨드 객체의 인스턴스를 사용하지 않고 함수 객체를 사용하여 모든 구상 커맨드 클래스를 제거할 수 있다. 하지만 Command 인터페이스에 추상 메소드가 하나뿐일 때만 사용 가능하다
- 각 커맨드에 상태 지역 변수를 저장하여 여러 상태로 작업 취소/변경되도록 코드를 구현할 수 도 있다."
2023-05-16 00:43:28,"한종우","19일차

[헤드퍼스트 디자인 패턴]

- 커맨드 패턴을 사용하여 요청하는 객체와 요청을 수행하는 객체를 분리할 수 있고, 커맨드 객체가 행동이 들어 있는 리시버를 캡슐화한다.
- 인보커는 무언가 요청할 때 커맨드 객체의 execute() 메소드를 호출하면 된다. execute() 메소드는 리시버에 있는 행동을 호출한다.
- 매크로 커맨드를 구현하여 배열을 받아 여러 동작을 한번에 처리할 수 도 있다
- 리시버가 아닌 커맨드 객체에서 execute()을 구현할 수도 있지만 인보커와 리시버를 분리하기 어렵고, 리시버로 커맨드를 매개변수화할 수 없다는 단점이 있다.
- 실행한 커맨드 자체를 스택에 넣어 작업 취소할 때 히스토리 기능을 구현할 수 도 있다
- 커맨드로 컴퓨테이션의 한 부분(리비서와 일련의 행동)을 패키지로 묶어서 일급 객체 형태로 전달할 수도 있다. 그러면 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 컴퓨테이션을 호출할 수 있다. 다른 스레드에서 호출할 수도 있어 이를 통해 커맨드 패턴을 스케줄러나 스레드 풀, 작업 큐와 같은 다양한 작업에 적용할 수 있다.
- 어떤 애플리케이션이 다운되었을 때 커맨드 패턴을 통해 store(), load() 등의 메소드를 구현하여 복구할 수 있고, 트랜잭션을 활용해서 모든 작업이 완벽하게 처리되도록 하거나, 아무것도 처리되지 않게 롤백되도록 할 수 있다"
2023-05-16 04:39:33,"김형우","[18일차]
https://engineer-diary.tistory.com/224"
2023-05-16 06:47:00,"다운","19일차

농업혁명이후 문화가 발전했다. 문화는 외부에 의해 변화된것 뿐만 아니라 인간모순 덕분에 내부에 의해서도 변화 됐다. 인간 모순이란 중세 유럽이 기독교와 기사도를 동시에 믿은것, 현대가 자유와 평등을 동시에 추구하는 것이다. 

역사에는 방향성이 존재하는데 이는 통일을 향해 끊임없이 움직이고 있다. 문화는 균일 하지 않지만 논쟁에 사용되는 개념도 동일하고 무기도 동일하다. 오늘날에는 고유 문화란 존재하지 않으며 모두 근대 문화이다.

발췌

오늘날 세계는 자유와 평등을 조화시키는데 실패하고 있다.

갈등을 다루지 않는 위대한 예술작품을 떠올려볼수 있는가?
"
2023-05-16 07:53:23,"김용기","20일차
DDD MSA

### 도메인 서비스

- 도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 하는데 이를 도메인 서비스라 한다.
- 도메인 로직을 처리할 때 엔티티나 값 객체와 함께 특정 작업을 처리하고 상태를 본인이 가지고 있찌 않고 엔티티나 값 객체에 전달한다.

### 도메인 이벤트

- 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태를 담아 전달되도록 모델링한다.

# 5.7 정리

- 이벤트 스토밍은 전통적인 방식에서 오랜 기간 동안 수행했던 비즈니스 분석, 이해관계자 의견 개진, 공유, 리스크 도출 등을 가속화해서 진행하는 협업, 공유, 의사소통에 최적화된 설계 방식이다.
- 도메인 모델링은 DDD의 전술적 설계 구성요소를 통해 비즈니스 도메인 모델을 쉽고 단순하게 구성하도록 해준다."
2023-05-16 08:31:06,"강민규","사진"
2023-05-16 08:31:54,"강민규","여러분 좋은 아침입니다 충분한 수면 하셨나요? 책도 벌써 절반이 다와갑니다 화이팅"
2023-05-16 10:31:29,"Bo","19일차 
헤드퍼스트 
### 요약

> 매크로 커맨드
> 
- 여러 개의 커맨드를 호출하게 해주는 방법
- 커맨드를 확장해서 여러 커맨드를 관리하는 형태를 띈다

### 발췌

> 커맨드 패턴
> 

💡 요청 내용을 객체로 캡슐화해서 객체를 서로 다른 요청에 따라 매개변수화할 수 있습니다. 이러면 요청을 큐에 저장하거나 작업 취소 기능을 사용할 수 있습니다


- 커맨드 패턴을 사용하면 요청하는 객체와 요청을 수행하는 객체를 분리할 수 있다
- 이렇게 분리하는 과정의 중심에는 커맨드 객체가 있으며 이 객체가 행동이 들어있는 리시버를 캡슐화"
2023-05-16 18:25:37,"최희윤","20일차 DDD
https://www.notion.so/05-16-DDD-20-00615e03e3274354861954e998e6f645?pvs=4"
2023-05-16 20:32:50,"김연정","19일차
초전설득
요약
우리는 전달하려는 메시지와 관련해 듣는 사람이 가지고 있는 정신적 연상을 활성화하는 말을 통해 상대방을 설득할 수 있다. 
국가 품질상을 받은 한 건강회사에서 폭력을 연상시키는 단어를 모두 비폭력적인 단어로 대체하여 사용함 : 타깃->목표, 공격한다->접근한다

메모
없음"
2023-05-16 20:39:37,"강민규","여러분 가끔 가장 일찍 독서일지 제출해주신 분께 스타벅스 기프티콘 드린다고 했던 것 기억하시나요?

오늘이 바로 그날 중 하루입니다. 오늘은 희윤님께서 가장 먼저 올려주셨네요~ 따로 연락드리겠습니다.

아직 몇번 더 남았으니 기대해주세요"
2023-05-16 20:41:44,"김연정","이모티콘"
2023-05-16 20:42:42,"최희윤","이야아아 너무 감사합니다"
2023-05-16 21:06:33,"뚯뚜오","- 19일차 총균쇠
    요약
    아메리카 원주민의 스타팅 포인트 여건들.
    유용한 식물을 식별할 수 있었으나, 생태학적 선행 조건과 환경이 받쳐주지 않았던 고대인들.
    과거 시점으로 돌아간다면 어떤 운명의 수레바퀴가 돌아갈지 알 수 없으므로 어느 지역의 문명이 발달할지 예측하는 것은 불가능.
    8장 작물화하는데 적합한 식물의 식별과 성패의 원인 끝
    
    발췌
    …그렇지만 호프웰 문화가 꽃핀 시기는 비옥한 초승달 지대에서 촌락 생활이 시작되고 나서 거의 9000년이 흐른 뒤였다. 그리고 이른바 미시시피 문화는 아메리카 원주민들이 이룩한 것으로는 멕시코 이북에서 가장 규모가 큰 도시와 복잡한 사회를 낳았는데, 이 경우도 멕시코산 3대 작물이 더욱 큰 규모의 인구 폭증을 촉발시켰던 A.D. 900년 이후의 일이었다. 그러나 그 인구 폭증은 너무 늦게 찾아왔으므로 미국의 아메리카 원주민들은 미처 유럽의 식민지화라는 임박한 재앙에 대비할 겨를이 없었다.
    미국 동부산 작물에 대해 가장 잘 아는 농경민들은 바로 그 지역의 아메리카 원주민들이었다. 멕시코산 3대 작물이 도착하자 그들은 동부산 작물을 포기하거나 그 비중을 감소시키는 선택을 했다. 그러한 결과는 곧 아메리카 원주민들이 문화적 보수주의 따위에 구애받지 않았으며 좋은 식물을 보면 높이 평가할 줄 알았다는 증거다. 그러므로 뉴기니와 마찬가지로 미국 동부에서도 토착적 식량 생산의 취약점은 아메리카 원주민 때문이 아니라 전적으로 아메리카의 생물상과 환경때문이었다 할 수 있다."
2023-05-16 21:36:31,"김용기","오 오늘 제가 처음으로 올린거 같은데요 (궁금)"
2023-05-16 21:37:51,"강민규","그러네요 ~ 용기님도 연락드리겠습니다"
2023-05-16 21:38:00,"강민규","공지 전에 올리셔서 못봤네요"
2023-05-16 21:40:47,"강민규","다들 퇴근하셨나요? 일곱시 퇴근이니 집와서 청소하고 밥먹으면 아홉시가 넘는군요… 인생이 너무 짧아진 느낌입니다. 짧아진만큼 빡쎄게 살아야겠습니다

@궈노 @리경 @김형우 선생님들은 오늘 이틀치 분량으로 해봅시다!"
2023-05-16 21:54:37,"송예은","20일차 (사례연구라 내용이 많이 없네요ㅠㅠ)
ddd, msa

이번 장은 실제 업무 사례로 마이크로서비스를 도출하고 아키텍처를 구성한다.

다음과 같은 순서로 이루어진다.

요구사항 정의 → 이벤트 스토밍을 통한 마이크로서비스 도출 → 외부 아키텍처 정의 → 내부 아키텍처 정의 → JHipster를 이용한 아키텍처 구성

# 6.1 요구사항 정의

도서대출시스템은 다음과 같은 서브도메인으로 나눌 수 있다.

- 사용자 관리 및 로그인
- 도서 관리
- 도서 대출 및 반납
- 배송
- 이메일"
2023-05-16 22:30:15,"뚯뚜오","- 20일차 총균쇠
    요약
    동물로 얻을 수 있는 장점 : 단백질, 우유 등 영양 공급원, 쟁기질, 거름 등 농사를 위한 직,간접적 도움, 공격 및 운송수단, 의류, 보온품, 합성 병원균 등
    가축화된 대형초식동물은 고작 14종 (주요 5종 : 양, 염소, 소, 돼지, 말)
    가축의 특성 : 감금 상태에서 인간의 용도에 맞도록 선택적으로 번식시켜 야생 조상으로부터 더 유용한 방면으로 변화시킨 동물
    비유라시아 지역에서 토종 야생 포유류가 가축화되지 못한 이유 
    9장 선택된 가축화와 ‘안나 카레니나의 법칙’
    
    발췌
    …유럽인들이 개를 데리고 태즈메이니아에 정착할 때까지 태즈메이니아 원주민들은 개를 본 적도 없었다. 그로부터 채 10년이 지나기 전에 원주민들은 대량으로 개를 번식시켜 사냥에 이용하기 시작했다. 그러므로 오스트레일리아, 남북아메리카, 아프리카 등지에서 각양각색의 문화를 가지고 살아가던 수천의 민족들 사이에 동물의 가축화를 가로막는 보편적인 문화적 금기 따위는 존재하지 않았다."
2023-05-16 23:37:04,"박소환","20일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/101"
2023-05-17 00:14:06,"김형우","삭제된 메시지입니다."
2023-05-17 00:14:21,"김형우","[19일차]
https://engineer-diary.tistory.com/225"
2023-05-17 01:48:13,"리경","삭제된 메시지입니다."
2023-05-17 01:48:39,"리경","19일차
오브젝트

✨ 요약
#정보 은닉과 모듈
정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적 인터페이스 뒤로 감춰야 하는 것이 핵심.
복잡성과 변경 가능성을 감춰야함.

#모듈의 장점과 한계
* 모듈 내부의 변수가 변경되도 모듈 내부에만 영향 미침
* 비즈니스 로직과 사용자 인터페이스에 대한 관심사 분리
* 전역 변수와 전역 함수 제거함으로 네임스페이스 오염 방지
추상화 관점의 한계로 등장한 개념이 추상 데이터 타입

#추상 데이터 타입
개념적으로 사람들의 사고방식에 가까움.

#클래스는 추상 데이터 타입인가?
동일하지 않음.
클래스 : 상속, 다형성 지원 : 절차 추상화 : 타입을 기준으로 오퍼레이션을 묶음
추상 데이터 타입 : 지원 못함 : 타입 추상화 : 대표적 타입이 다수의 세부적 타입을 감추는 것 (오퍼레이션 기준으로 타입 묶는 방법)
"
2023-05-17 08:02:34,"강민규","사진"
2023-05-17 08:03:37,"강민규","여러분 좋은 아침입니다~ 어린이날이다 뭐다 하면서 잔뜩 쉰게 엊그제같은데 벌써 한달이 절반이나 지났네요. 오늘도 좋은 하루 보내봐요"
2023-05-17 08:23:43,"궈노","19일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_4/day_19_257-271.md"
2023-05-17 08:50:50,"뚯뚜오","- 21일차 총균쇠
    야생 포유류 가축화의 장애 주요 장애 요인  겁먹는 버릇, 사회적 구조
    - 초식 (또는 잡식) : 체중 450kg의 소를 키워내기 위해서는 옥수수 4500kg이 필요하다. 450kg의 소로 키워낼 수 있는 육식동물의 체중은 고작 45kg 수준으로 극도로 비효율적이다.
    - 성장속도 : 성체로 성장하는데 코끼리는 15년이나 걸리므로 야생 코끼리를 사육하는것보다는 포획하여 길들이는게 가성비가 좋다.
    - 번식환경 : 가축을 기르는 밀집되고 오픈된 환경에서 번식을 꺼려하는 성격의 동물들이 있다. 치타 등
    - 골치아픈 성격 : 공격성(곰, 아프리카들소), 미친성격(당나귀, 얼룩말 등)
    - 예민하고 겁먹는 버릇 : 가젤
    - 사회적 성향 : 우세한 지도자를 모시는 성향, 인간을 지도자로 따르는 성향 등"
2023-05-17 09:55:13,"Bo","20일차 
헤드퍼스트 
### 요약

> 어댑터 패턴
> 
- 객체지향 어댑터는 인터페이스를 클라이언트에서 요구하는 대로 변경하는 역할
- A 라는 인터페이스를 B 인터페이스의 규격에 맞게 변형시키려면, A 를 B 로 변경해주는 클래스를 만드는데, 그게 어댑터다
- 그렇기 때문에 어댑터 안에는 A 라는 클래스의 인스턴스가 들어가 있을 수밖에 없다. 어댑터는 B 인터페이스를 구현하면서 그를 위한 동작을 A 에게 시킨다

> 객체 어댑터와 클래스 어댑터
> 
- 클래스어댑터를 사용하기 위해서는 다중 상속이 필요한데, 자바에서는 다중 상속을 지원하지 않는다
- 객체 어댑터는 구성으로 어댑티에 요청을 전달하지만, 클래스 어댑터는 타깃과 어댑티 모두 서브클래스로 만들어 사용

### 발췌

> 어댑터 패턴 정의
> 
- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 함께 쓸 수 없던 클래스를 사용할 수 있게 한다

### 메모

- 대부분은 어댑터가 하나의 클래스만 감싸지만, 하나의 타깃 인터페이스를 구현 하기 위해 여러 클래스를 감싸야 할 때까 있는데, 이는 퍼사드 패턴이랑 관련이 있다 ( p278 )"
2023-05-17 10:21:20,"송예은","21일차
ddd, msa

# 6.2 이벤트 스토밍을 통한 마이크로서비스 도출

## 6.2.2 바운디드 컨텍스트 식별

- 사용자 관리 서브도메인
    - [로그인], [회원]으로 바운디드 컨텍스트 분리
- 게시판, 도서관리, 배송 서브도메인
    - 서브도메인 그대로 각각 바운디드 컨텍스트로 식별됨
- 대출,반납 서브도메인
    - [대출], [반납], [연체] 애그리거트는 [대출자] 액터 중심으로 밀접한 관계가 있으므로 [대출] 컨텍스트로 도출
    - [도서검색정보], [최다대출도서집계]는 [도서] 바운디드 컨텍스트로 식별하려했으나, 이 개념들은 도서 컨텍스트가 보유한 도서 정보보다 빈번하게 일반 회원에게 공개되어 사용돼야 하는 개념이므로 조회와 생성, 변경을 분리하는 CQRS 패턴 적용하여 [카탈로그] 바운디드 컨텍스트로 도출
    - [카탈로그] 컨텍스트는 도서 정보 조회 및 검색을 위한 역할만 전담하고, [도서] 컨텍스트의 도서가 변경됐을 때 도메인 이벤트에 의해 일관성을 맞춰야 한다.
- 이메일 서브도메인
    - [이메일] 바운디드 컨텍스트로 도출"
2023-05-17 10:21:22,"호02","20일차 제출

[초전 설득]

1. 요약 
 - 은유를 잘 활용하면 사람들을 나의 영향력으로 유도하기 쉬워진다.
 - 생명 보험을 파는 보험왕은 주저하는 고객에게 이런 은유 표현을 사용했다.
 - ""당신이 퇴장할 때 당신의 생명보험금이 입장합니다.""
 
 
2. 메모
 - 끊어진 상황을 계속 이어가게 한다면 집중을 더 높일 수 있을 거 같다.
 - 마치 내 스스로 발등에 불이 떨어진 상황을 만드는 것"
2023-05-17 10:33:20,"호02","21일차 제출

[초전 설득]

1. 요약 
 - 우리 자신이 가장 매력적이다.
 - 나 자신과 연결된 정보는 관심을 유도하는 강력한 힘이다. 그래서 이름, 생일, 고향이 같거나 비슷하면 쉽게 호감을 느낀다.
 - 자신과 연관있는 집단에 호감을 느끼는 현상도 있다. (암묵적 에고이즘이라고 불린다.)
 - 제품에 본인 이름과 동일한 글자가 있을 경우 더 강한 선호도를 보인다.
 
 
2. 메모
 - 이래서 학연, 지연, 혈연은 어쩔 수 없는 건가..?"
2023-05-17 11:14:24,"궈노","20일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_4/day_20_272-283.md"
2023-05-17 16:28:04,"수정","20일차
헤드퍼스트 디자인패턴

- 객체지향 어댑터: 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 형태로 인터페이스 바꿔주기
    - 기존 시스템과 업체에서 제공한 클래스 사이에 새 코드(타깃 인터페이스)를 끼워 다른 코드의 변화 없이도 동작하도록하는 중개인
- 클라이언트: 타깃 인터페이스(Duck)에 맞게 구현
- 어댑터: 타깃 인터페이스(Duck) 구현, 어댑티(Turkey)로 구성됨
- 클라이언트가 (객체)어댑터를 사용하는 과정
    - 클라이언트에서 타깃 인터페이스로 메소드를 호출해 어댑터에 요청을 보낸다
    - 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 메소드 호출로 변환한다
    - 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모른다
- **Q&A**
    - 하나의 어댑터에서 여러 클래스(어댑티)를 감싸는 경우도 ⇒ 퍼사드 패턴
    - 어떤 곳에서는 어댑터를 사용하고 어떤 곳에서는 사용하지 않는다면? ⇒ 두 인터페이스를 모두 지원할 수 있도록 다중 어댑터
- **어댑터 패턴에 적용된 객체지향 원칙들**
    - 어댑티를 새로바뀐 인터페이스로 감쌀 때 객체 구성(컴포지션) 사용
        - 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있다
    - 특정 구현이 아닌 인터페이스에 의존
        - 인터페이스만 유지하면 다른 구현 추가 가능
- 클래스 어댑터
    - 어댑터를 어댑티와 타깃클래스의 서브클래스로 만든다 (다중 상속)
- 객체 어댑터 vs 클래스 어댑터 (구성 vs 상속)
    - 객체 어댑터의 장점
        - 서브클래스에도 어댑터 가능
        - 어댑티에게 필요한 일 직접 시키기 (유연함)
        - 어댑터에 행동 추가하면 어댑티 서브클래스까지 적용됨
    - 클래스 어댑터
        - 특정 어댑티 클래스에만 적용 가능
        - 어댑티 전체를 다시 구현할 필요 없음(상속)
        - 어댑티 메소드 오버라이드 가능(어댑티의 서브클래스이므로)"
2023-05-17 18:26:16,"최윤지","20일차
[7가지코드]

https://quiet-jade-e60.notion.site/20-0516-c264df7c4cca4e05aaf5231ffd0b4a54"
2023-05-17 21:16:18,"강민규","다들 좋은 하루 보내고 계신가요? 저는 유래 없이 컨디션이 좋은 날입니다! 여러분 오늘 위기이신 분들이 많은데요, 빠르게 이틀치를 끝내고 다음 성실상을 노려봅시다

@최다봄 @리경 @김연정 @한종우 @김형우 @이찬영 @다운 "
2023-05-17 21:26:48,"다운","20일차

사피엔스

요약

기원전 첫 밀레니엄때 보편적 질서라는 것이 생겼는데 첫번째는 화폐이고 두번째는 제국, 세번째는 종교였다.
도시와 왕궁이 등장하고 수송 하부구조가 개선되자 전문화의 기회가 나타났다. 하지만 물물교환으로는 한계가 있었고 돈을 개발하였다

발췌
적어도 잠재적으로는 모두가 우리였다
"
2023-05-17 21:32:43,"최윤지","21일차
[7가지코드]

https://quiet-jade-e60.notion.site/21-0517-66e774288f964d7495c4c697a34227cf"
2023-05-17 21:35:12,"최다봄","20일차 (p. 272 ~283)

[헤드퍼스트 디자인 패턴]

**CHAPTER 07: 적응시키기 - 어댑터 패턴과 퍼사드 패턴**

- 어댑터: 한 인터페이스를 다른 인터페이스로 변환해 주는 역할
- 객체지향 어댑터: 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 형태로 인터페이스 바꿔주기
    - 연결하고자하는 인터페이스끼리 호환이 안 되면 어떻게 해야할까? ⇒ 새로운 인터페이스를 기존에 사용하던 인터페이스에 적응 시켜주는 클래스를 만들면 된다.
    - 기존 시스템(코드 변화 없음)-어댑터(새 코드)-업체에서 제공한 클래스(코드 변화 없음)
- 어댑터 패턴은 객체지향 원칙을 반영한다.
    - 새로 바뀐 인터페이스로 감쌀 때는 객체 구성(composition)을 사용한다.
    - 이로 인해 어댑터를 어댑터의 모든 서브 클래스에 적용할 수 있다.
    - 특정 구현이 아닌 인터페이스에 의존함으로써 다른 구현을 추가할 수 있는 유연성을 갖게 된다.
- 클래스 어댑터
    - 타깃과 어댑티 모두 서브 클래스로 만들어 사용
- 객체 어댑터
    - 어댑티에 요청을 전달
    - 객체 어댑터의 장점
        - 서브클래스에도 어댑터 가능
        - 어댑티에게 필요한 일 직접 시킬 수 있다.
        - 어댑터에 행동 추가하면 어댑티 서브클래스까지 적용됨

### 발췌

- **어댑터 패턴(adapter pattern**)은 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다."
2023-05-17 21:35:31,"최다봄","21일차 (p. 284 ~ 293)

[헤드퍼스트 디자인 패턴]

**CHAPTER 07: 적응시키기 - 어댑터 패턴과 퍼사드 패턴**

[데코레이터 패턴]

- ‘책임’ / 데코레이터가 적용된다는 것은 새로운 책임과 행동이 디자인에 추가된다는 뜻
- 기존 코드를 고치지 않고 클래스에 새로운 해동을 추가할 수 있다는 차이점은 어댑터와 동일

[어댑터(adapter) 패턴]

- 어떤 클래스의 인터페이스를 클라이언트가 원하는 인터페이스로 변환
- 자바에서는 호환성이 없는 인터페이스 객체를 올바른 인터페이스 객체로 감싸서 어댑터 패턴을 구현 가능

[퍼사드(facade) 패턴]

- 인터페이스를 단순하게 바꾸기 위해서 인터페이스를 변경하는 패턴
- 하나 이상의 클래스 인터페이스를 깔끔하면서도 효과적인 퍼사드로 덮어줌
- 복잡한 방법을 간단하게 처리할 수 있는 방법을 고려해보고자 !

### 발췌

- 데코레이터: 인터페이스는 바꾸지 않고 책임(기능)만 추가
- 어댑터: 하나의 인터페이스를 다른 인터페이스로 변환
- 퍼사드: 인터페이스를 간단하게 변경"
2023-05-17 21:44:35,"김용기","21일차
DDD MSA

## 6.2 이벤트 스토밍을 통한 마이크로서비스 도출

## 6.2.1 이벤트 스토밍 워크숍

- DDD에서는 문제 영역을 서비 도메인이라고 부른다.

### 대출, 반납 서브도메인

- 액터의 역할을 세밀하게 구분함으로써 커맨드와 이벤트가 좀 더 구체화되거나 새로 식별될 수 있다.

## 6.2.2 바운디드 컨텍스트 식별

- 이벤트 스토밍의 결과를 보고 경계를 그려 컨텍스트를 구분한다.
- 애그리거트의 응집도를 살펴 경계를 식별하는 것이 명확하다.
- 조회와 생성, 변경을 분리하는 CQRS 패턴을 활용할 수 있다.
- 바운디드 컨텍스트를 도출한 뒤 이전에 도출했던, 외부 시스템과의 연관관계, 정책 등을 살펴보면 컨텍스트 간 호출 관계를 정리할 수 있다."
2023-05-17 22:20:21,"박소환","21일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/103"
2023-05-17 23:23:37,"김연정","20일차
초전설득
요약~174
연상의 힘
우리는 올바른 주장이 아닌 올바른 단어를 신뢰해야 한다. 앞서 언급한 건강 회사에서는 비폭력 단어를 지양하고 성취와 관련한 단어를 많이 사용했다. 마찬가지로 승리를 연상시키는 포스터를 사무실에 붙여놓으면 직원들의 사기를 높일 수 있다. 
은유의 힘
범죄자 강경대응을 주장하는 정치인이라면 범죄자를 괴물로, 범죄를 일으키는 환경을 통제하고자 한다면 범죄자를 바이러스로 은유.
역대 보험왕 펠드먼: 당신이 퇴장할때 당신의 생명보험금이 퇴장합니다. 로 은유

무게,무거움=심각성,중요성
-> 연상: 면접관은 무거운 철에 있는 입사지원서를 더 중요하게 보고 더 많은 노력을 기울여 본다.
+ 차가운 음료보다 따듯한 음료를 상대방에게 주었을 때 더 협조적인 태도를 보인다.

메모
이번 장에는 유용한 예시가 많아서 실생활에 꼭 적용해봐야겠다."
2023-05-17 23:32:11,"김형우","[20일차]
https://engineer-diary.tistory.com/226"
2023-05-17 23:33:09,"김연정","21일차
초전설득
요약
부정적인 연상 피하기
중고차x 사용된 적 있는ㅇ
비용,가격x 투자ㅇ

이득이 되는 조건과는 연상을 강화하고, 손해가 되는 조건과는 같이 언급되지 않도록 해야 한다. 

가장 부정적인 것: 불신

자기 자신과 관련 있거나 관련 있어 보이는 정보는 전부 즉각적인관심을 받는다. 사소해 보이는 연결 고리마저 설득을 성공으로 이끄는중요한 발판이 될 수 있다. 내 이름과 스펠링이 비슷하거나, 나와 같은 생일을 가진 사람 등( 암묵적 에고이즘)

개인의 특성보다는 개인이 소속된 집단의 특성과 연관 있는 정보, 즉 사회적 자아 역시 즉각적인반응을 이끌어낼 수 있다. (한국인의 공통적인 특성 등)"
2023-05-18 00:43:31,"리경","20일차
오브젝트

✨요약
#변경을 기준으로 선택
클래스가 추상 데이터 타입 개념을 따르는지 확인하는 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지 살펴보는 것.

객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
개방-폐쇄 원칙 : 기존 코드에 아무 영향 미치지 않고 새 객체 유형과 행위 추가 가능

'타입 추가' 라는 변경의 압력이 강한 경우 객체 지향 선택.
'오퍼레이션 추가'라는 변경의 압력 강한 경우 추상 데이터 타입 선택 : 객체지향의 경우 상속 계층에 속하는 모든 클래스 한 번 수정 필요하기 때문.

#협력이 중요하다
객체가 참여할 협력을 결정하고, 협력에 필요한 책임 수행 위해 어떤 객체 필요한지 고민하라.
그 책임을 다양한 방식으로 수행해햐 할 때만 타입 계층 안에 각 절차를 추상화 하라.

08 의존성 관리하기 
협력을 위해 의존성이 필요하나 과한 의존성은 수정을 어렵게 함.
핵심은 협력위해 필요한 의존성 유지하며 변경 방해하는 의존성 제거!
이 관점에서 객체지향 설계란 의존성을 관리하는 것, 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술.

의존성 전이: 함께 변경될 가능성. 모든 경우에 전이되지 않음.
런타임의존성과 컴파일타임 의존성

클래스가 강하게 결합될수록 다른 문맥 사용 어려움. 
컨텍스트 독립성 :클래스가 최소한의 가정만으로 이뤄져 다른 문맥에서 재사용 쉬움

의존성 해결 : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
- 객체 생성 시점에 생성자 통해
- 생성 후 setter 메서드 통해
- 메서드 실행시 인자통해"
2023-05-18 01:42:34,"이찬영","20일차
헤드퍼스트 디자인패턴 [4주차_화요일] 
272-283pg

https://ribbon-utahraptor-ec5.notion.site/20-d296581eb64d4d14a2fd3f0156c40c27"
2023-05-18 02:00:04,"이찬영","21일차
헤드퍼스트 디자인패턴 [4주차_수요일] 
284-293pg

https://ribbon-utahraptor-ec5.notion.site/21-2a35840034e9451fbe2c5cd5b3865a31"
2023-05-18 02:06:31,"한종우","20일차

[헤드퍼스트 디자인 패턴]

### 어댑터 패턴

- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 사용할 수 없던 클래스를 사용할 수 있게 도와준다
- 실생활에서 어댑터는 종류가 많지만 모양이 다르다. (인터페이스가 다름) 어댑터는 모양을 바꿔 주고 전원을 그대로 보내준다. 객체 지향 어댑터도 인터페이스를 클라이언트에서 요구하는 형태로 적응하는 역할을 한다
- 어댑터는 클라이언트로부터 요청을 받아서 새로운 업체에서 제공하는 클래스를 클라이언트가 받아들일 수 있는 형태의 요청으로 변환해주는 중개인 역할을 한다
- 어댑터를 구현하기 위해서는 우선 적응시킬 형식의 인터페이스(클라이언트에서 원하는), 인터페이스에 있는 메소드를 모두 구현해야 한다

클라이언트에서 어댑터를 사용하는 방법

- 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청한다
- 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 메소드 호출로 변환한다
- 클라이언트는 호출 결과를 받긴 하지만 어댑티와 클리아이언트는 분리되어 있어 중간에 어댑터가 있다는 사실을 모른다

- 클라이언트에서 호출하는 부분을 새로운 인터페이스에 맞춰서 고치려면 많은 부분을 고려하고 코드 수정이 많이 필요하기 때문에 모든 변경 사항을 캡슐화할 클래스를 제공하는 어댑터 패턴은 유용하다
- 시스템에 오래된 부분과 새로운 부분이 공존한다면 두 인터페이스를 모두 지원하는 다중 어댑터를 통해 어댑터가 기존 인터페이스와 새로운 인터페이스 역할을 모두 할 수 있게 하면 된다"
2023-05-18 02:06:41,"한종우","21일차

[헤드퍼스트 디자인 패턴]

객체 어댑터

- 구성을 사용하여 어댑티 클래스와 그 서브 클래스에 대해서도 어댑터 역할을 할 수 있다
- 구성을 사용하여 더 유연하다
- 어댑터 코드에 어떤 행동을 추가하면 그 어댑터 코드는 어댑티 클래스와 그 서브 클래스에 적용된다

클래스 어댑터

- 특정 어댑티 클래스에만 적용할 수 있다
- 어댑티 전체를 다시 구현하지 않아도 된다
- 서브 클래스라서 어댑티의 행동을 오버라이드할 수 있다

- 어댑터 패턴을 적용하기 위해서는 클라이언트와 타겟 각각의 인터페이스의 메서드가 서로 어떻게 매핑되는지 확인해야 한다. 타겟 인터페이스를 구현하고 어댑티 객체로 구성된 어댑터를 구현하면 된다
- 데코레이터 패턴과 어댑터 패턴은 겉으로 보기에는 비슷해보이지만 내부에서 어떻게 캡슐화하는지는 다르다
- 인터페이스를 단순하게 바꾸기 위한 디자인 패턴으로 퍼사드 패턴이 있다"
2023-05-18 07:20:45,"다운","21일차

사피엔스

요약
화폐는 오래전부터 조가비, 가죽 등의 물질로 대체되어 사용되어졌다. 사람들이 돈을 원하는것은 모두가 돈을 원하고 그것이 자신이 필요로 하는 것으로 바꿀 수 있기 때문이다.
돈은 부의 전환과 저장, 이동을 쉽고 값싸게 하도록 만들었다.
돈은 물질적 실체가 아니라 심리적 구조물 즉 집단 상상력이다.
운반과 저장이 쉬운 주화는 보리와 달리 먹을 수는 없지만 은과 달리 무게를 재지도 않고 순수성을 따지지 않아도 되고 또한 왕이 돈 보증을 해주어 그 진실성 덕분에 더욱 자주 이용됐다

발췌
심지어 성관계를 구원으로 바꾸는 것도 가능하다. 15세기에 창녀들이 남자와 자는 대가로 받은 돈으로 카톨릭 교회의 면죄부를 사곤 했으니 말이다"
2023-05-18 08:42:15,"강민규","사진"
2023-05-18 08:43:10,"강민규","좋은 아침입니다! 날씨가 슬슬 더워지려고 하네요~ 봄이 얼마 남지않았으니 즐겨봅시다"
2023-05-18 08:44:33,"뚯뚜오","- 22일차 총균쇠
    유럽 사회가 대단히 유리해진 것은 바로 포유류의 지리, 역사, 생태 등 세 가지 기본적인 현실 때문이었다. 
    
    첫째, 유라시아는 그 넓은 면적과 생태학적 다양성에 걸맞게 처음부터 후보종 수가 가장 많았다.
    
    둘째, 오스트레일리아와 남북아메리카는 홍적세 말기에 닥친 엄청난 멸종의 파도 속에서 대부분의 후보군을 잃고 말았지만 유라시아와 아프리카는 그렇지 않았다. 아마도 앞의 두 대륙에서는 그 포유류들이 인류의 진화사에서 상당히 늦은 시기, 즉 우리의 사냥 기술이 이미 고도로 발달했을 때에 갑작스럽게 인간들 앞에 노출되었기 때문일 것이다.
    
    마지막으로, 거기서 살아남은 후보종 중에서도 유라시아의 경우에는 기타 대륙에 비해 가축화에 적합한 동물들의 비율이 높았다. 아프리카의 대형 군거 포유류처럼 결국 가축화되지 못한 후보종들을 잘 살펴보면 각각의 후보종이 실격하게 된 구체적인 이유들이 드러난다.  
    9장 선택된 가축화와 ‘안나 카레니나의 법칙’ 끝"
2023-05-18 09:44:21,"Bo","21일차 
헤드퍼스트 
### 요약

> 데코레이터 패턴과 어댑터 패턴의 비교
> 
- 객체를 감싸고 있다는 것은 비슷하지만, 데코레이터는 같은 인터페이스를 제공한다. 단, 기능을 확장한다. 어뎁터 패턴은 다른 인터페이스로의 전환이다. 기능의 확장은 아니다.

> 퍼사드 패턴
> 
- 인터페이스를 더 단순하게 바꾸기 위해 인터페이스를 변경하는 퍼사드 패턴

### 발췌

> 퍼사드
> 
- 퍼사드는 겉모양이나 외관이라는 뜻이다"
2023-05-18 10:54:49,"송예은","22일차
DDD, MSA

## 6.2.3 컨텍스트 다이어그램

이렇게 식별된 컨텍스트가 마이크로서비스 후보가 된다. 후보라고 언급한 이유는 서비스는 이후에 배포, 운영 효율성 등을 고려해 더 분할되거나 통합될 수 있기 때문이다.

## 6.2.4 이벤트 스토밍 결과를 헥사고날 아키텍처로 표현하기

이벤트 스토밍을 통해 식별한 애그리거트는 헥사고날의 내부 영역인 도메인 모델의 후보가 되고, 커맨드 요소는 외부 영역의 인바운드 어댑터인 API의 후보, 이벤트는 외부 영역의 아웃바운드 어댑터를 통해 전송될 메시지의 대상이 된다.

식별된 정책의 일부는 내부 비즈니스 로직 구현의 규칙으로, 또다른 일부는 다른 서비스와의 호출 방향을 결정할 자료가 된다.

# 6.4 내부 아키텍처 정의

## 6.4.1 패키지 구조 및 명명 규칙

### 내부 영역

- domain
    - 유형 : 클래스
    - 명명 규칙 : 명사형
    - 명칭 및 역할
        - 도메인 모델 : 비즈니스 개념 및 로직 표현
        - 애그리거트, 엔티티, VO 표준 타입 패턴으로 구현
    - 작성 기준 : 애그리거트 단위
- service
    - 유형, 명명 규칙 : 인터페이스는 ~Service, 클래스는 ~ServiceImpl
    - 명칭 및 역할
        - 서비스 인터페이스 : 서비스 퍼사드 역할
        - 서비스 구현체 : 업무 처리 흐름 구현
- repository
    - 유형, 명명 규칙 : 인터페이스로 ~Repository
    - 명칭 및 역할
        - 리포지토리: 저장소 처리
    - 작성 기준 : 엔티티당 1개"
2023-05-18 12:42:44,"궈노","21일차
헤드퍼서트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_4/day_21_284-293.md"
2023-05-18 12:42:59,"궈노","22일차
헤드퍼스트 디자인패턴

https://github.com/link-mozy/breakbook/blob/main/dailyLog/week_4/day_22_294-304.md"
2023-05-18 20:26:42,"최희윤","21일차 DDD
https://www.notion.so/05-17-DDD-21-425dc36752854dc6962422c444b4e510?pvs=4
22일차 DDD
https://www.notion.so/05-18-DDD-22-c23f3f87e8cc40d5a84789ac2b81ff8e?pvs=4"
2023-05-18 21:41:25,"강민규","여러분 목요일이 이렇게 끝나갑니다. 한주가 지나가네요. 금요일은 무슨 일이 있을지 모르는 날입니다! 오늘 분량을 하여 내일의 비상사태를 미리 대비할 수 있도록 해봅시다.

@리경 @김형우 @수정 여러분은 오늘 이틀치 분량 해보아요~"
2023-05-18 22:11:05,"수정","21일차
헤드퍼스트 디자인 패턴

- 어댑터 패턴 실전
    - Enumeration을 Iterator에 적응시키는 어댑터 패턴
        - Iterator: 타깃 인터페이스
        - Enumeration: 어댑티
        - EnumerationIterator: 어댑터
    - Enumeration에는 remove() 메소드가 없어서 일대일 대응이 불가능해, 어댑터를 완벽하게 적용하기 어렵다(remove() 메소드를 호출하면 런타임 예외를 던지는 식으로 대응)
- 어댑터에 인터페이스를 바꾸는 기능 외에 새로운 추가 기능이 붙는다면 어떤 패턴을 이용해야?
    - 어댑터의 용도는 인터페이스 바꾸기인데 거기에 추가 기능을 붙이는 건 이상하다
    - 데코레이터로 어댑터를 감싸서 기능을 덧붙일 수는 있겠다
- 데코레이터 패턴
    - 객체를 감싸 기존 코드를 고치지 않도록 해준다는 점이 어댑터 패턴과 같음
        - 어댑터 패턴은 인터페이스를 변환하지만, 데코레이터패턴은 객체의 행동과 책임을 확장한다
- 퍼사드 패턴
    - 인터페이스를 단순하게 바꾸기 위해 인터페이스를 변경한다
    - 퍼사드(facade): “겉모양, 외관”
    - 영화보기 예시⇒ 복잡하고 많은 일들을 간단하게 처리하게 하기"
2023-05-18 22:27:44,"이찬영","22일차
헤드퍼스트 디자인패턴 [4주차_목요일] 
294-304pg

https://ribbon-utahraptor-ec5.notion.site/22-8d1b7689cc4c4cf4810b97c1e6e848e5"
2023-05-18 23:15:38,"Bo","22일차 
헤드퍼스트 
### 요약

> 퍼사드 패턴
> 
- 여러 서브클래스 ( tv, 스피커 등 ) 가 있을 때 이를 묶어서 관리 ( 홈시어터 - 버튼 하나로 음악이 켜지고, 조명이 켜지고 스피커 켜지는 ) 하는 퍼사드 클래스를 만든다 → 서브 시스템의 기능을 사용할 수 있는 인터페이스 제공
- 인터페이스가 제공됨으로써, 클라이언트와 / 서브 클래스의 분리
- 퍼사드 패턴과 어댑터 패턴은 용도가 다르다
    - 어댑터 패턴은 클라이언트가 원하는 인터페이스로 적용 시키는 것
    - 퍼사드 패턴은 더 간단한 인터페이스를 제공하는 것

> 최소지식 원칙
> 
- 데메테르 법칙과 동일하다
- 단점 : 원칙을 준수하다 보면, 래퍼 클래스를 더 만들어야 할 수 있다"
2023-05-18 23:48:00,"김형우","[21일차]
https://engineer-diary.tistory.com/228"
2023-05-19 00:30:19,"박소환","22일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/104"
2023-05-19 06:54:45,"리경","21일차
오브젝트

✨ 요약
#의존성과 결합도
어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한하면 그 의존성은 바람직하지 못함.
재사용할 수 있는 유일한 방법은 구현을 변경하는 것. = 느슨한 결합도, 약한 결합도

#지식이 결합을 낳는다
한 요소가 다른 요소에 대해 더 적은 정보를 알수록 두 요소는 약하게 결합됨.
더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것.

#추상화에 의존하라
추상화 : 세부사항, 구조를 명확하게 이해하기 위해 특정 절차, 물체를 의도적으로 생략하거나 감춰서 복잡도를 극복하는 방법.
추상화를 통해 대상에 대해 알아야 하는 지식의 양 줄여 결합도 느슨하게 유지.
* 구체 클래스 의존성
* 추상 클래스 의존성 : 협력하는 대상 속한 클래스 상속 계층 알아야함
* 인터 페이스 의존성 : 상속 계층 몰라도 협력 가능

#명시적인 의존성
명시적 의존성 : 의존성은 명시적으로 퍼블릭 인터페이스에 노출됨

#new는 해롭다
new 잘못 사요시 클래스 사이 결합도 극단적으로 높아짐.
new를 사용하기 위해선 구체 클래스 이름 직접 기술해야하기 때문.
어떤 인자를 이용해 클래스 생성자 호출해야 하는지도 알아야하기 때문.

해결방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것.
Ex. movie는 외부로부터 이미 생성된 amountDiscountPolicy 인스턴스 전달받아야함. movie는 amountDiscountPolicy 를 사용하는 책임만 남도록.

#가끔은 생성해도 무방
주로 협력하는 기본 객체를 설정하고 싶은 경우.
Ex. movie가 대부분 amountDiscountPolicy 인스턴스와 협력, 가끔씩 percentDiscountPolicy 인스턴스와 협력시 ) 기본 객체 생성자 추가하고, 이 생성자에서 DiscountPolicy의 인스턴스를 인자로 받는 생성자를 체이닝

✨ 발췌
의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다는 것이다.

유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다. 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타밍 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있다. 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다는 점을 기억하라."
2023-05-19 07:42:28,"강민규","사진"
2023-05-19 07:43:27,"박소환","23일차
도메인 주도 설계로 시작하는 마이크로 서비스 개발
https://bleetoteelb.tistory.com/105"
2023-05-19 07:43:56,"강민규","여러분 좋은 아침입니다. 저희 다음 주는 공지 드린대로 복습 기간이 제공됩니다. 이번 주 잘 미무리해보아요"
2023-05-19 08:11:45,"호02","22일차 제출

[초전 설득]

1. 요약 
 - 2007년 아프간 텔레반에 납치된 한국 봉사자를 구하기 위해 국정원장이 가장 먼저한 일은 파슈툰족 말을 유창하게 하는 한국인으로 바꿨다.
 - 서로 간의 언어 소통을 쉽게 함으로써 긍정적인 연상을 불렀던 게 유리하게 작용했던 것
 - 사람들은 쉬운 이름, 얼굴 등을 가질수록 매력적이라고 생각한다. 
 - 회사명이 발음하기 쉬우면 그렇지 않은 회사보다 실적이 좋다는 분석도 있다.
 "
2023-05-19 08:22:08,"호02","23일차 제출

[초전 설득]

1. 요약 
 - 설득에도 지리학이 있다.
 - 대중적인 학문을 만들기 위해서는 학구적인 단서들이 많은 연구실보다는 일반 대중들이 많이 활동하는 시내 주변의 사무실에서 연구를 하는 게 더 효과적이다.
 - 큰 보상과 성취를 위해 목표와 단서들을 동기화하는 방법 중 하나는 지리학적 요소에 변화를 주는 것이다.
 
2. 메모
 - 재택 근무를 할 때와 사무실 출근할 때 나오는 결과물들이 달랐던 거 같다. "
2023-05-19 09:35:37,"김용기","22일차
DDD MSA

## 6.2.3 컨텍스트 다이어그램

- 최종적으로 다음과 같이 호출 관계를 명확하게 인지할 수 있도록 컨텍스트 다이어그램을 작성한다.
- 식별된 컨텍스트가 마이크로서비스 후보가 된다.

## 6.2.4 이벤트 스토밍 겨로가를 헥사고날 아키텍처로 표현하기

- 이벤트 스토밍 결과를 상세한 설계로 만들기 위해 헥사고날 아키텍처로 표현한 것이다.
- 이벤트 스토밍을 통해 식별한 애그리거트는 헥사고날의 내부 영역인 도메인 모델의 후보가 된다.
- 커맨드 요소는 외부 영역의 인바운드 어댑터인 API의 후보가 된다.
- 이벤트는 외부 영역의 아웃바운드 어댑터를 통해 전송될 메세지의 대상이 된다.
- 식별된 정책의 일부는 내부 비즈니스 로직 구현의 규칙으로, 또다른 일부는 다른 서비스와 의 호출 방향을 결정할 자료가 된다.

# 6.4 내부 아키텍처 정의

- 마이크로서비스의 내부 아키텍처도 폴리글랏하다.

### 6.4.1 패캐지 구조 및 명명 규칙

- 패키지 구조를 살펴보면 내부 영역을 담당하는 패키지와 외부 영역 처리를 담당하는 패키지를 분리했다.
- 내부 아키텍처 구조는 패키지 구조로 표현될 수 있다.
- 내부 영역에는 비즈니스 로직을 표현할 도메인 모델, 서비스 인터페이스, 서비스 구현체, 리포지토리가 존재한다.
- 외부 영역에는 API를 제공하고 저장소 및 다른 서비스와 연계할 웹 REST 컨트롤러, 어댑터, DTO가 존재하도록 구성한다.
- 도메인 클래스인 경우 도메인 개념을 명확히 표현할 수 있는 명사형으로 지정한다. 나머지 인터페이스나 클래스의 경우에는 클래스 역할 유형에 따른 접미사를 적용한다.
"
2023-05-19 09:37:00,"김용기","23일차

DDD MSA
# 6.5 JHipster를 활용한 아키텍처 구성

- JHipster는 콘솔 창으 ㅣ질의 응답을 통해 스프링 클라우드, 스프링 부트 기반의 마이크로서비스 개발 환경을 손쉽게 구성해준다.

## 6.5.1 MSA 외부 아키텍처 구성(게이트웨이, 레지스트리 서비스)

### JHipster란?

- JHipster란 모던 웹 애플리케이션과 마이크로서비스 아키텍처를 빠르게 적용, 개발, 배포할 수 있도록 도와주는 오픈소스 개발 플랫폼이다.

### JHipster의 목적

- 광범위한 테스트를 커버할 수 있는 우수한 성능의 강력한 서버 스택
- 세련되고 현대적인 모바일 친화적 UI를 위한 프론트 프레임워크와 CSS의 통합
- 애플리케이션을 빌드하는 강력한 워크 플로
- 클라우드에 빠르게 배포할 수있는 코드 기반 인프라

### JHipster 마이크로서비스 아키텍처

- JHipster 레지스트리 : MSA 디스커버리 패턴의 구현, 다른 모든 구성요소를 서로 연결하고 서로 통신할 수 있게하는 역할을 한다.
- 마이크로서비스 : 여러 마이크로서비스로 구성될 수 있으며, 몇 개의 엔티티와 비즈니스 규칙이 포함된다.
- 게이트웨이 : 전체 마이크로서비스에서 생성한 API를 사용한다."
2023-05-19 09:50:19,"송예은","23일차
ddd, msa

# 6.5 JHipster를 활용한 아키텍처 구성

- JHipster란?
    
    JHipster란 모던 웹 애플리케이션과 마이크로서비스 아키텍처를 빠르게 적용, 개발, 배포할 수 있도록 도와주는 오픈소스 개발 플랫폼이다.
    
    - 지원영역
        - 프론트엔드 : Angular, React, Vue.js
        - 백엔드 : Spring Boot, Micronaut, Quakus, Node.js, .NET
        - 배포 : Docker, k8s, Azure, GCP ..
- JHipster의 목적
    
    완전하고 현대적인 웹 애플리케이션과 마이크로서비스 아키텍처를 생성
    
- JHipster 마이크로서비스 아키텍처
    - JHipster 레지스트리
        
        MSA 디스커버리 패턴의 구현, 다른 모든 구성요소들을 서로 연결하고 서로 통신할 수 있게 한다.
        
    - 마이크로서비스
        
        백엔드 코드가 들어 있고, 실행 후 도메인에 대한 API를 노출한다. 여러 마이크로서비스로 구성될 수 있다.
        
    - 게이트웨이
        
        모든 프론트엔드 코드를 가지고 있으며, 전체 마이크로서비스에서 생성한 API를 사용한다.
        
    - 백엔드 소스코드
        
        src/main/java 폴더에 존재
        
    - 프론트엔드 소스코드
        
        src/main/webapp 폴더에 존재"
2023-05-19 10:21:00,"Bo","23일차 
헤드퍼스트
### 요약

- 어제 한 퍼사드패턴 복습
    - 어댑터 패턴 : 특정 클래스 인터페이스를 클라이언트가 요구하는 다른 인터페이스로 변환. 인터페이스가 달라 호환되지 않던 클래스를 같이 쓸 수 있게 도와줌
    - 퍼사드 패턴 : 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어준다. 고수준 인터페이스로 정의해서 (구체적인 메소드 몰라도 ) 더 편하게 (버튼 하나만 누르면..) 쓸 수 있게 해준다
    - 데코레이터패턴 : 인터페이스는 바꾸지 않고 기능만 추가"
2023-05-19 10:45:14,"다운","22일차

사피엔스

요약
로마주화는 인도까지 그 신뢰도를 떨치고 그 무렵 중국에서는 은으로된 화폐 시스템을 개발했다. 둘다 은과 금을 기반으로 만들어졌고 국경과 문화를 초월하는 단일화폐가 등장했다. 
돈은 보편적 전환성과 보편적 신뢰를 기반한다.
제국이란 1) 다른 문화적 정체성을 가진 많은 민족들을 지배한다 2)탄력적 국경이다. 군사적 정복만이 아닌 자발적 동맹이 가능하며 독재적 황제가 아닌 민주주의로 이루어진다.

발췌
하지만 역사에 정의란 없다. 과거에 존재했던 문화 대부분은 늦든 이르든 어떤 무자비한 제국의 군대에 희생되었고 제국은 이들 문롸를 망각속에 밀어넣었다.

돈은 인간이 창조한 신뢰 시스템중 유일하게 모든 문화적 간극을 메울 수 있고 종교나 사회적 성별, 인종, 연령, 성적 지향을 근거로 차별하지 않는 유일한 신뢰 시스템이다.
"
2023-05-19 11:00:30,"다운","23일차

사피엔스

요약
제국은 외부의 침공이나 지배 엘리트의 분열로 사라졌다. 이때 삼켜진 민족은 독립 하는것이 아니라 새로운 제국에 동화되었고 모든 문화는 고대 유대왕국이 아닌 제국에서 유래하였다.
제국을 유지하기 위해선 살해와 약탈, 억압이 필수적이었다 하지만 그때문에 철학과 예술 등도 발전할 수 있었다.
사피엔스는 이민족 공포증을 지녔지만 키루스 이래 제국의 이데올로기는 온 세상이 기본적으로 하나라는 생각을 가졌다. 이처럼 자애로운 제국관은 피지배 민족들의 반란 시도를 무효화 했으며 독립 된 민족들이 제국의 팽창에 대항하려는 시도까지 무효화 했다

발췌

페르시아인등은 우리가 너희를 정복하는 것은 너희를 위해서다 라고 말했다

로마 제국주의가 제공한 이익과 번역 덕분에 키케로와 세네카 성 아우구스티누스는 사색과 집필을 할 여유를 누릴 수 있었다"
2023-05-19 13:17:17,"최윤지","22일차
[7가지코드]

https://quiet-jade-e60.notion.site/22-0518-d5ebe1f0487148d1abe2e03d845b5173"
2023-05-19 16:17:21,"김형우","[22일차]
https://engineer-diary.tistory.com/229"
2023-05-19 18:45:22,"김연정","22일차
초전설득 ~182p

요약
우리는 막힘없이 이해할 수 있는 것, 그러니까 빠르고 효율적으로 구상하거나 처리할 수 있는 것을 더 좋아할 뿐만 아니라 더 타당하고 가치 있다고 여긴다. 
‘to make it climb, make it rhyme', 설득에성공하려면 운율을 만들어야 한다.
사람의 외모를 평가할 때도 우리는 인식하기 쉬운 얼굴 특징을 지녔거나 발음하기 쉬운 이름일수록 매력적이라고 생각한다. 미국 로펌 변호사 500명을 분석한 결과 이름이 발음하기 어려울 수록 직급이 낮았다. 발음하기 쉬운 이름의 회사일수록 주식 시장에서 실적이 더 좋다.

메모
핑크펭귄이라는 책에서도 이름의 중요성에 대해 언급했는데 마케팅 목적을 넘어서 정말 큰 영향력이 있는 것 같다."
2023-05-19 20:16:07,"수정","22일차
헤드퍼스트 디자인 패턴
https://bold-manta-a44.notion.site/22-e9609552b6894bc99fd679de7a79265e"
2023-05-19 21:02:38,"최다봄","22일차 (p. 284 ~ 293)

[헤드퍼스트 디자인 패턴] 

**CHAPTER 07: 적응시키기 - 어댑터 패턴과 퍼사드 패턴**

[퍼사드 패턴]

- 퍼사드 패턴의 정의
    - 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어 준다
    - 고수준 인터페이스를 정의해 서브시스템을 더 편하게 사용할 수 있다.
- 퍼사드 패턴의 장점
    - 단순화된 인터페이스를 제공하면서도, 클라이언트에서 필요로 한다면 시스템의 모든 기능을 사용할 수 있도록 해준다.
- 인터페이스가 제공됨으로써, 클라이언트와 / 서브 클래스의 분리
- 퍼사드 패턴과 어댑터 패턴은 용도가 다르다.
    - **어댑터 패턴**은 인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키는 용도 !
    - **퍼사드 패턴**은 어떤 서브시스템에 대한 간단한 인터페이스를 제공하는 용도 !

[최소지식 원칙]

- 최소 지식 원칙 === 데메테르의 법칙
- 단점 : 원칙을 준수하다 보면, 래퍼 클래스를 더 만들어야 하기에 시스템이 복잡해질 수 있다.
- 객체 지향 원칙
    - 최소 지식 원칙 (Principle of Least Knowledge) 시스템을 디자인 할 때 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수와 상호작용 방식에 주의를 기울여야 한다."
